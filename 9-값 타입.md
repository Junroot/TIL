---
title: 9-값 타입
tags:
  - 도서/자바-ORM-표준-JPA-프로그래밍
---
- 값 타입 3가지
	- 기본값 타입
		- 자바 기본 타입(`int`, `double`)
		- 래퍼 클래스(`Integer`)
		- `String`
	- 임베디드 타입
	- 컬렉션 값 타입

## 기본값 타입

- 값 타입은 다른 엔티티와 공유하면 안 된다.

## 임베디드 타입(복합 값 타입)

- ![](assets/Pasted%20image%2020250210205038.png)
- ![](assets/Pasted%20image%2020250210205046.png)
- 임베디드 타입을 사용하려면 다음 2가지 어노테이션이 필요하다. 참고로 둘 중 하나는 생략해도 된다.
	- `@Embeddable`: 값 타입을 정의하는 곳에 표시
	- `@Embedded`: 값 타입을 사용하는 곳에 표시
- 임베디드 타입은 기본 생성자가 필수다.

### 임베디드 타입과 테이블 매핑

- ![](assets/Pasted%20image%2020250210205355.png)
- 잘 설계한  ORM 애프리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많다.

### 임베디드 타입과 연관관계

- 임베디드 타입은 값 타입을 포함하거나 엔티티를 찹조할 수 있다.
- ![](assets/Pasted%20image%2020250210205806.png)

### @AttributeOverride: 속성 재정의

![](assets/Pasted%20image%2020250210210352.png)

### 임베디드 타입과 null

- 임베디드 타입이 null이면 매핑한 컬럼 값은 모두 null이 된다.

## 값 타입과 불변 객체

### 값 타입 공유 참조

- 값 타입을 여러 엔티티에서 공유하면 위험하다.
- 값 객체를 공유하면 엔티티의 값 객체를 수정하면 공유하는 다른 엔티티의 값도 변경되어 버린다.
- 이런 부작용을 막으려면 값을 복사해서 사용하면 된다.

### 값 타입 복사

- 값 객체를 복사하지 않고 원본의 참조 값을 직접 넘기는 것을 막을 방법이 없다.
- 따라서 근본적인 해결책이 필요한데 가장 단순한 방법은 값을 수정하지 못하게 막으면 된다.

### 불변 객체

- 객체를 불변하게 만들면 값을 수정할 수 없으므로 부작용을 원천 차단할 수 있다.
- 따라서 값 타입은 될 수 있으면 불변 객체로 설계 해야 한다.

## 값 타입의 비교

- 객체 비교 2가지
	- 동일성 비교: 인스턴스의 참조 값을 비교, `==` 사용
	- 동등성 비교: 인스턴스의 값을 비교, `equals()` 사용
- 값 타입을 비교할 때는 `a.equals(b)`를 사용해서 동등성 비교를 해야 한다.
-  `equals()`를 재정의할 때는 모든 필드의 값을 비교하도록 구현해야 한다.
	- `equals()`를 재정의하면 `hashCode()`를 재정의하는 것이 안전하다.

## 값 타입 컬렉션

![](assets/Pasted%20image%2020250210212636.png)

- 값 타입을 하나 이상 저장하려면 컬렉션에 보관하고 `@ElementCollection`, `@CollectionTable` 어노테이션을 사용하면 된다.
- `@CollectionTable`를 생략하면 기본값을 사용해서 매핑한다.
	- 기본값: {엔티티이름}\_{컬렉션 속성 이름}

### 값 타입 컬렉션 사용

![](assets/Pasted%20image%2020250210213706.png)

- 위 코드를 실행하면 실제 데이터베이스에 실행되는 INSERT SQL은 다음과 같다.
	- `member`: INSERT SQL 1번
	- `member.homeAddress`: 컬렉션이 아닌 임베디드 값 타입이므로 회원테이블에 저장하는 SQL에 포함된다.
	- `member.favoriteFoods`: INSERT SQL 3번
	- `member.addressHistory`: INSERT SQL 2번
- 값 타입 컬렉션은 영속성 전이 + 고아 객체 제거 기능을 필수로 가진다고 볼 수 있다.
- 값 타입 컬렉션도 조회할 때 페치 전략을 선택할 수 있는데 LAZY가 기본이다.
	- `@ElementCollection(fetch = FetchType.LAZY)`

![](assets/Pasted%20image%2020250210214054.png)

- 위 코드를 실행할 때 데이터베이스에 호출하는 SELECT SQL은 다음과 같다.
	- `member`: 값 타입인 `homeAddress`도 함께 조회한다. SELECT SQL을 1번 호출한다.
	- `member.favoriteFoods`: LAZY로 설정해서 실제 컬렉션을 사용할 때 SELECT SQL을 1번 호출한다.
	- `member.addressHistory`: LAZY로 설정해서 실제 컬렉션을 사용할 때 SELECT SQL을 1번 호출한다.

### 값 타입 컬렉션의 제약사항

- 값 타입 컬렉션에 보관된 값 타입들은 별도의 테이블에 보관된다.
	- 여기에 보관된 값 타입의 값이 변경되면 데이터베이스에 있는 원본 데이터를 찾기 어려워서, 값 타입 컬렉션이 매핑된 테이블의 연관된 모든 데이터를 삭제하고, 현재 값 타입 컬렉션에 있는 모든 값을 데이터베이스에 다시 저장한다.
- 따라서 실무에서는 값 타입 컬렉션이 매핑된 테이블에 데이터가 많다면 값 타입 컬렉션 대신 일대다 관계를 고려해야 한다.
- 추가로 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본 키를 구성해야 한다. 
	- 따라서 데이터베이스 기본 키 제약 조건으로 인해 컬럼에 null을 입력할 수 없고, 같은 값을 중복해서 저장할 수 없는 제약도 있다.
- 값 타입 컬렉션을 사용하는 대신, 일대다 관계의 엔티티에 영속성 전이(Cascade) + 고아 객체 제거(ORPHAN REMOVE) 기능을 적용하면 값 타입 컬렉션 처럼 사용할 수 있다.
- ![](assets/Pasted%20image%2020250210215648.png)
