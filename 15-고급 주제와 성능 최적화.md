---
title: 15-고급 주제와 성능 최적화
tags:
  - 도서/자바-ORM-표준-JPA-프로그래밍
---
## 예외 처리

### JPA 표준 예외 정리

- JPA 표준 예외들은 `PersistenceException`의 자식 클래스다.
	- 그리고 이 예외 클래스는 `RuntimeException`의 자식이므로 JPA 예외는 모두 언체크 예외다.
- JPA 표준 예외는 2가지로 나눌 수 있다.
	- 트랜잭션 롤백을 표시하는 예외: 
		- 심각한 예외이므로 복구해선 안 된다.
		- 트랜잭션을 강제로 커밋해도 트랜잭션이 커밋되지 않고 대신 `RollbackException`이 발생한다.
	- 트랜잭션 롤백을 표시하지 않는 예외
		- 심각한 예외가 아니다.
- ![](assets/Pasted%20image%2020250310203610.png)
- ![](assets/Pasted%20image%2020250310203614.png)

### 스프링 프레임워크의 JPA 예외 변환

- 서비스 계층에서 데이터 접근 계층의 구현 기술에 직접 의존하는 것은 좋은 설계라 할 수 없다.
- 스프링 프레임워크는 이런 문제를 해결하려고 데이터 접근 계층에 대한 예외를 추상화해서 개발자에게 제공한다.
	- 예) `javax.persistence.NoResultException` -> `org.springframework.dao.EmptyResultDataAccessException`

### 스프링 프레임워크에 JPA 예외 변환기 적용

- JPA 예외를 스프링 프레임워크가 제공하는 추상화된 예외로 변경하려면 `PersistenceExceptionTranslationPostProcessor`를 빈으로 등록하면 된다.
- 이것은 `@Repository` 어노테이션을 사용한 곳에 예외 변환 AOP를 적용해서 JPA 예외를 스프링 프레임워크가 추상화한 예외로 변환해준다.

### 트랜잭션 롤백 시 주의사항

- 트랜잭션을 롤백하는 것은 데이터베이스의 반영사항만 롤백하는 것이지 수정한 자바 객체까지 원상태로 복구해주지는 않는다.
- 따라서 트랜잭션이 롤백된 영속성 컨텍스트를 그대로 사용하는 것은 위험하다.
- 스프링 기본 전략인 트랜잭션당 영속성 컨텍스트 전략은 문제가 발생하면 트랜잭션 AOP 종료 시점에 트랜잭션을 롤백하면서 영속성 컨텍스트도 함께 종료하므로 문제가 발생하지 않는다.
- OSIV처럼 영속성 컨텍스트의 범위를 트랜잭션 범위보다 넓게 사용해서 여러 트랜잭션이 하나의 영속성 컨텍스트를 사용할 때 문제가 발생한다.

## 엔티티 비교

- 영속성 컨텍스트의 1차 캐시의 가장 큰 장점은 애플리케이션 수준의 repeatable read를 제공해준다는 것이다.
	- 같은 영속성 컨텍스트에서 엔티티를 조회하면 항상 같은 엔티티 인스턴스를 반환한다.
	- 이것은 단순히 동등성 비교 수준이 아니라 정말 주소값이 같은 인스턴스를 반환한다.
- 같은 영속성 컨텍스트의 관리를 받는 영속 상태의 엔티티는 항상 동등성 비교를 성공한다.
- 하지만 서로 다른 영속성 컨텍스트에서 관리를 받는 엔티티는 동등성 비교에 실패한다.
- `equals()`를 사용한 동등성 비교할 때, 비즈니스 키를 활용한 동등성 비교를 권장한다.

## 프록시 심화 주제

- 프록시를 사용하는 방식의 기술적인 한계로 예상하지 못한 문제가 발생할 수 있다.

### 영속성 컨텍스트와 프록시

![](assets/Pasted%20image%2020250310205828.png)

- 영속성 컨텍스트는 프록시로 조회된 엔티티에 대해서 같은 엔티티를 찾는 요청이 오면 원본 엔티티가 아닌 처음 조회된 프록시를 반환한다.
	- 엔티티의 동일성을 보장하기 위해서다.


![](assets/Pasted%20image%2020250310205915.png)

- 원본 엔티티를 먼저 조회하면 영속성 컨텍스트는 `em.getReference()`를 호출해도 프록시가 아닌 원본을 반환한다.
	- 엔티티의 동일성을 보장하기 위해서다.

### 프록시 타입 비교

- 프록시는 원본 엔티티를 상속 받아서 만들어지므로 프록시로 조회한 엔티티의 타입을 비교할 때는 `==` 비교를 하면 안 되고 대신에 `instanceof`를 사용해야 한다.
- ![](assets/Pasted%20image%2020250310210136.png)

### 프록시 동등성 비교

- IDE나 외부 라이브러리를 사용해서 구현한 `equals()` 메소드로 엔티티를 비교할 때, 비교 대상이 원본 엔티티면 문제가 없지만 프록시면 문제가 될 수 있다.
- ![](assets/Pasted%20image%2020250310210537.png)
	1. 프록시는 원본을 상속받은 자식 타입이므로 프록시의 타입을 비교할 때는 `==` 비교가 아닌 `instanceof`를 사용해야 한다.
	2. 프록시는 실제 데이터를 가지고 있지 않다. 따라서 멤버변수에 직접 접근하면 아무값도 조회할 수 없다. 멤버변수를 직접 접근하지 않고 접근자를 사용해서 해결해야 된다.
- ![](assets/Pasted%20image%2020250310210725.png)

### 상속관계와 프록시

![](assets/Pasted%20image%2020250310212122.png)

- 프록시를 부모 타입으로 조회하면 문제가 발생한다.
	- 아래와 같은 상속 관계가 되기 때문에 `proxyItem instanceof Book` 은 `false`가 된다.
	- 또한 하위 타입으로 다운캐스팅을 할 수 없다.
	- ![](assets/Pasted%20image%2020250310212143.png)
- 해결 방법1: JPQL로 대상 직접 조회
	- ![](assets/Pasted%20image%2020250310212327.png)
	- 단점1: 이 방법을 사용하면 다형성을 활용할 수 없다.
- 해결 방법2: 프록시 벗기기
	- ![](assets/Pasted%20image%2020250310212412.png)
	- 하이버네이트가 제공하는 기능을 사용하면 프록시에서 원본 엔티티를 가져올 수 있다.
	- 단점1: 이 방법을 사용하면 프록시 객체와 원본 엔티티의 동일성 비교가 실패한다.
- 해결 방법3: 기능을 위한 별도의 인터페이스 제공
	- ![](assets/Pasted%20image%2020250310212504.png)
	- 인터페이스를 제공하고 각각의 클래스가 자신에게 맞는 기능을 구현하는 것은 다형성을 활용하는 좋은 방법이다.
	- 장점1: 다양한 상품 타입이 추가되어도 `Item`을 사용하는 `OrderItem`의 코드는 수정하지 않아도 된다.
	- 장점2: 클라이언트 입장에서는 대상 객체가 프록시인지 아닌지를 고민하지 않아도 된다.
	- 단점1: 이 방법을 사용할 때는 프록시의 특징 때문에 프록시의 대상이 되는 타입에 인터페이스를 적용해야 된다.
- 해결 방법4: 비지터 패턴 사용
	- ![](assets/Pasted%20image%2020250310212752.png)
	- ![](assets/Pasted%20image%2020250310212806.png)
	- 장점1: 프록시에 대한 걱정 없이 안전하게 원본 엔티티에 접근할 수 있다.
	- 장점2: `instanceof`와 타입캐스팅 없이 코드를 구현할 수 있다.
	- 장점3: 알고리즘과 객체 구조를 분리해서 구조를 수정하지 않고 새로운 동작을 추가할 수 있다.
	- 단점1: 너무 복잡하고 더블 디스패치를 사용하기 때문에 이해하기 어렵다.
	- 단점2: 객체 구조가 변경되면 모든 Visitor를 수정해야 한다.
