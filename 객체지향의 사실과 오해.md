---
tags:
  - 도서/객체지향의-사실과-오해
title: 객체지향의 사실과 오해
---



## 협력하는 개체들의 공통체

### 협력하는 사람들

* 역할과 책임
  * 역할: 커피를 주문하는 손님, 주문을 받는 캐시어, 커피를 제조하느 바리스타
  * 책임 손님: 커피를 주문할 책임 캐시어: 손님의 주문을 받는 책임 바리스타: 주문된 커피를 제조하는 책임
  * 협력: 커피 주문
* 요청과 응답
  * 커피주문이라는 협력은 손님이 커피를 제공해 줄 것을 캐시어에게 요청하는 것이다.
  * 캐시어는 주문된 커피를 제조해줄 것을 요청한다.
  * 바리스타는 커피를 제조한후 제조가 완료됐음을 캐시어에게 알려주는 것으로 캐시어의 요청에 응답한다.
  * 캐시어는 진동벨을 울려 손님에엑 주문된 커피가 준비됐음을 알림으로써 손님의 주문에 응답한다.

### 역할, 책임, 협력

* 사람이라는 단어를 객체로, 에이전트의 요청을 메시지로, 에이전트가 요청을 처리하는 방법을 메서드로 바꾸면 객체지향이라는 문맥으로 옮겨올 수 있다.
* 객체의 역할
  * 여러 객체가 동일한 역할을 수행할 수 있다.
  * 역할은 대체 가능성을 의미한다.
  * 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있다.
  * 하나의 객체가 동시에 여러 역할을 수행할 수 있다.

### 협력 속에 사는 객체

* 객체의 덕목
  * 객체는 충분히 협력적이어야 한다. 다른 객체의 요청에 충실히 귀 기울이고 다른 객체에게 적극적으로 도움을 요청할 정도로 열린 마음을 지녀야 한다.
  * 객체가 충분히 자율적이어야 한다. 객체 공동체에 속한 객체들은 공동의 목표를 달성하기 위해 협력에 참여하지만 스스로 결정과 판단에 따라 행동하는 자율적인 존재다.
* 상태와 행동을 함께 지닌 자율적인 객체 객체는 상태와 행동을 함께 지닌 실체라고 정의한다. 협력을 참여하기 위해 어떤 행동을 해야한다면 그행동을 하는 데필요한 상태도 함께 지니고 있어야 한다. 객체의 자율성은 객체의 내부와 외부를 명확하게 구분하는 것으로부터 나온다. 객체는 다른 객체가 무엇을 수행하는지는 알 수 있지만 어떻게 수행하는지에 대해서는 알 수 없다.
* 협력과 메시지

    객체는 협력을 위해 다른 객체에게 메시지를 전송하고 다른 객체로부터 메시지를 수신한다. 이때 메시지를 전송하는 객체를 송신자(sender)라고 부르고 메시지를 수신하는 객체를 수신자(receiver)라고 부른다.

* 메서드와 자율성

    객체가 수신된 메시지를 처리하는 방법을 메서드라고 부른다. 외부의 요청이 무엇인지를 표현하는 메시지와 요청을 처리하기 위한 구체적인 방법인 메서드를 분리하는 것은 객체의 자율성을 높이는 핵심 메커니즘이다. 이것은 캡슐화라는 개념과도 깊이 관련돼 있다.

### 객체지향의 본질

객체지향의 본질은 클래스가 아니다. 자바스크립트 같은 프로토타입 기반의 객체지향 언어에서는 클래스가 존재하지 않으며 오직 객체만이 존재한다. 프로토타입 기반의 객체지향 언어에서는 상속 역시 클래스가 아닌 객체 간의 위임(delegration) 메커니즘을 기반으로한다. 핵심은 적절한 책임을 수행하는 역할 간의 유연하고 견고한 협력 관계를 구축하는 것이다.

## 이상한 나라의 객체

### 객체지향과 인지 능력

객체지향 패러다임의 목적은 현실 세계를 모방하는 것이 아니라 현실 세계를 기반으로 새로운 세계를 찾오하는 것이다. 따라서 소프트웨어 세계에서 살아가는 객체는 현실 세계에 존재하는 객체와는 전혀 다른 모습을 보이는 것이 일반적이다. 현실 세게의 전등은 사람의 손길 없이는 스스로 불을 밝힐 수 없짐나 소프트웨어 세계는 외부의 도움 없이도 스스로 전원클 켜거나 끌 수 있다.

### 객체, 그리고 소프트웨어 나라

* 객체: 식별 가능한 개체 또는 사물이다. 객체는 구별 가능한 **식별자**, 특징적인 **행동**, 변경 가능한 **상태**를 가진다.
* 상태: 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다. 객체의 프로퍼티는 단순한 **값**과 다른 객체를 참조하는 **링크**로 구분할 수 있다.
* 행동: 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다. 행동의 겨로가로 객체는 자신의 상태를 변경하거나 다른 객체에게 메시지를 전달할 수 있다. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야한다. 메시지 송신자는 메시지 수신자의 상태 변경에 대해서는 전혀 알지 못하게 하는 것이 캡슐화를 의미한다. 캡슐화하는 것은 객체의 자율성을 높이고 스스로 판단하고 스스로 결정하기 때문에 객체의 지능도 높아진다.
* 식별자: 어떤 객체를 다른 객체와 구분하는 데 사용하는 개체의 프로퍼티다. 값은 식별자를 가지지 않기 때문에 상태를 이용한 **동등성 검사**를 통해 두 인스턴스를 비교해야 한다. 객체는 상태가 변경될 수 있기 떄문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있다.
  * 참조 객체, 엔티티: 식별자를 지닌 전통적인 의미의 객체
  * 값 객체: 식별자를 가지지 않는 값을 가리키는 용어

### 행동이 상태를 결정한다

객체지향에 갓 입문한 사람들이 가장 쉽게 빠지는 함정은 상태를 중심으로 객체를 바라보는 것이다. 이런 방법은 아래와 같은 나쁜 영향을 끼친다.

* 캡슐화가 저해되고 공용 인터페이스에 그대로 노출되버릴 확률이 높아진다.
* 객체를 협력자가 아닌 고립된 섬으로 만든다. 협력이라는 문맥에서 멀리 벗어난 채 객체를 설계하게 함으로써 자연슬버게 협력에 적합하지 못한 객체를 창조하게 된다.
* 객체의 재사용성이 저하된다.

협력에 참여하는 훌륭한 객체를 만들기 위해서 가장 중요한 덕목은 상태가 아니라 행동에 초점을 맞추는 것이다. 애플리케이션에 필요한 협력을 생각하고 협력에 참여하는 데 필요한 행동을 생각한 후 행동을 수행할 객체를 선택하는 방식으로 수행된다. 협력 안에서 객체의 행동은 결국 객체가 협력에 참여하면서 완수해야 하는 책임을 의미한다. 이런 설계를 책임-주도 설계(Responsibility-Drivne Design, RDD)라고 부른다.

### 은유와 객체

객체지향 세계는 현실 세계의 단순한 모방이 아니다. 소프트웨어 안에 구현된 상품 객체는 실제 세계의 상품과는 전혀 다른 양상을 띤다. 객체지향은 현실 세계의 모방과 추상화가 아니다.

* 의인화: 현실 속에서 수동저긴 존재가 소프트웨어 객체로 구현도리 떄는 능동적으로 변한다. 현실의 전화기는 스스로 통화 버튼을 누를 수 없으며 계좌는 스스로 금액을 이체할 수 없지만 객체지향 세계에서는 가능하다.
* 은유: 현실 속의 객체의 의미 일부가 소프트웨어 객체로 전달되기 때문에 프로그램 내의 객체는 현실 속의 객체에 대한 은유다. 현실 속의 전화기는 스스로 전화를 걸 수 없다고 하더라도 우리는 익히 알고 있는 현실의 전화기라는 개념을 이용해 소프트웨어 객체를 묘사하면 그 객체가 전화를 걸 수 있다는 사실을 쉽게 이해하고 기억할 수 있게 된다.

## 타입과 추상화

### 추상화를 통한 복잡성 극복

어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.

복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다.

* 첫 번째 차원은 구체적인 사물들 간의 공톰점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것이다.
* 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것이다.

모든 경우에 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화하는 것이라는 점을 기억해야된다.

### 그룹으로 나누어 단순화하기

* 개념: 공통점을 기반으로 객체들을 묶기 위한 그릇 예를들어, 앨리스는 이 객체들 중에서 몸이 납작하고 두 손과 두 발이 네모난 몸 모서리에 달려 있는 객체만을 트럼프라는 개념으로 추상화했다. 개념을 이용하면 객체를 여러 그룹으로 분류할 수 있다.
* 인스턴스: 객체에 어떤 개념을 적용하는 것이 가능해서 개념 그룹의 일원이 될 때의 객체

### 개념의 세 가지 관점

* 심볼: 개념을 가리키는 간략한 이름이나 명칭
* 내연: 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다.
* 외연: 개념에 속하는 모든 객체의 집합

### 객체를 분류하기 위한 틀

* 분류: 객체에 특정한 개념을 적용하는 작업이다. 객체에 특정한 개념을 적용하기로 결심했을 때 우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것이다.
* 개념은 객체들의 복잡성을 극복하기 위한 추상화 도구다.

### 타입

* 타입: 개념과 동일하다. 따라서 타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의미한다. 어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다. 타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.
  * 타입은 데이터가 어떻게 사용되느냐에 관한 것이다.
  * 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다.
* 데이터 타입: 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터다.
* 객체를 타입에 따라 분류하고 그 타입에 이름을 붙이는 것은 결국 프로그램에서 사용할 새로운 데이터 타입을 선언하는 것과 같다. 객체는 데이터가 아니다. 객체에서 중요한 것은 객체의 행동이다.
  * 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다.
  * 객체의 내부적은 표현은 외부로부터 철저하게 감춰진다.
* 객체를 결정하는 것은 행동이다. 데이터는 단지 행동을 따를 뿐이다. 이것이 객체를 객체답게 만드는 가장 핵심적인 원칙이다.

### 타입의 계층

* 일반적인 타입은 특수한 타입에 비해 더 적은 수의 행동을 가지며 특수한 타입은 일반적인 타입에 비해 더 많은 행동을 가진다. 이 둘의 관계를 일반화/특수화 관계라고 한다.
* 일반화/특수화 관계는 좀 더 일반적인 한 타입과 좀 더 특수한 타입 간의 관계다. 이 때 좀 더 일반적인 타입을 슈퍼타입이라고 하고 좀 더 특수한 타입을 서브타입이라고 한다.
* 추상화의 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거시켜 단순하게 만드는 것이다. 일반화/특수화 계층은 객체지향 패러다임에서 상화의 두번째 차원을 적절하게 활용하는 대표적인 예이다.

### 정적 모델

* 타입을 이용하면 객체의 동적인 특성을 추상화할 수 있다. 타입은 시간에 따른객체의 상태 변경이라는 복잡성을 단순화할 수 있는 효과적인 방법이다.
* 객체를 생각할 떄 우리는 두 가지 모델을 동시에 고려한다.
  * 동적 모델: 실제로 객체가 살아 움직이는 동안 상태가 어떻게 변하고 어떻게 행동하는지를 포착하는 것
  * 타입 모델: 객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표현하는 것
* 객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현된다. 클래스와 타입은 동일한 것이 아니다. 타입은 객체를 분류하기위해 사용하는 개념이다. 반면 클래스는 타입을 구현할 수 있는 여러 구현 메커니즘 중 하나일 뿐이다.

## 역할, 책임, 협력

객체의 모양을 빚는 것은 객체가 참여하는 협력이다. 어떤 협력에 참여하는지가 객체에 필요한 행동을 결정하고, 필요한 행동이 객체의 상태를 결정한다.

### 책임

* 책임: 어떤 객체가 어떤 요청에 대해 대답해 줄 수 있거나, 적절한 행동을 할 의무가 있는 것
* 책임의 분류
  * 하는 것(doing)
    * 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
    * 다른 객체의 행동을 시작시키는 것
    * 다른 객체의 활동을 제어하고 조절하는 것
  * 아는 것(knowing)
    * 개인적인 정보에 관해 아는 것
    * 관련된 객체에 관해 아는 것
    * 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것
* 객체의 책임을 이야기할 때는 일반적으로 외부에서 접근 가능한 공용 서비스 관점에서의 이야기다. 따라서 책임은 객체 외부에 제공해 줄 수 있는 정보와 외부에 제공해 줄 수 있는 서비스의 목록인 공용 인터페이스를 구성한다.
* 책임과 메시지
  * 메시지 전송: 객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것(송신자-수신자)
  * 주의할 점은 책임과 메시지의 수준이 같지 않다는 점이다. 책임은 객체가 협력에 참여하기 위해 수행해야 하는 행위를 상위 수준에서 개략적으로 서술한 것이다. 책임을 결정한 후 실제로 협력을 정제하면서 이를 메시지로 변환할 때는 하나의 책임이 여러 메시지로 분할되는 것이 일반적이다.

### 역할

* 어떤 객체가 수행하는 책임의 집합은 객체가 협력 안에서 수행하는 역할을 암시한다.
* 역할은 협력 내에서 다른 객체로 대체할 수 있음을 나타내느 일종의 표식이다. 그리고 역할을 대체할 수 있는 객체는 그 역할의 동일한 메시지를 이해할 수 있는 객체로 한정된다.
* 역할은 객체지향 설계의 단순성, 유연성, 재사용성을 뒷받침하는 핵심 개념이다.
* 역할의 가장 큰 가치는 하나의 협력 안에 여러 종류의 객체가 참여할 수 있게 함으로써 협력을 추상화할 수 있다는 것이다.
* 객체가 역할을 대체 가능하기 위해서는 협력 안에서 역할이 수행하는 모든 책임을 동일하게 수행할 수 있어야 한다.

### 객체의 모양을 결정하는 협력

* 객체지향에 대한 선입견
  * 시스템에 필요한 데이터를 저장하기 위해 객체가 존재한다. ⇒ 데이터는 단지 객체가 행위를 수행하는 데 필요한 재료일 뿐이다. 객체가 존재하는 이유는 행위를 수행하며 협력하기 위해서다.
  * 객체지향이 클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을 둔다는 것이다. ⇒ 중요한 것은 정적인 클래스가 아니라 협력에 참여하는 동적인 객체다. 객체지향의 핵심은 클래스를 어떻게 구현할 것인가가 아니라 객체가 협력 안에서 어떤 책임과 역할을 수행할 것인지를 결정하는 것이다.
* 객체의 행위에 초점을 맞추기 위해서는 협력이라는 실행 문맥 안에서 책임을 분배해야 한다. 객체를 충분히 협력적으로 만든 후에 협력이라는 문맥 안에서 객체를 충분히 자율적으로 만드는 것이다.

### 객체지향 설계 기법

* 책임-주도 설계: 협력에 필요한 책임들을 식별하고 적합한 객체에게 책임을 할당하는 방식으로 설계한다. 절차는 아래와 같다.
  1. 시스템이 사용자에게 재공해야 하는 기능인 시스템 책임을 파악한다
  2. 시스템 책임을 더 작은 책임으로 분할한다.
  3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
  4. 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
  5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.
* 디자인 패턴: 전문가들이 반복적으로 사용하는 해결 방법을 정의해 놓은 설계 템플릿의 모음으로 책임-주도 설계의 결과를 표현한다. 만약 특정한 상황에 적용 가능한 디자인 패턴을 잘 알고 있다면 책임-주도 설계의 절차를 순차적으로 따르지 않고도 시스템안에 구현할 객체들의 역할과 책임, 협력 관계를 빠르고 손쉽게 포착할 수 있을 것이다. 대표적인 디자인 패턴으로 COMPOSITE 패턴이 있다. COMPOSITE 패턴은 클라이언트 입장에서 메시지 수신자가 부분인지 전체인지에 상관 없이 동일한 메시지를 이용해 동일한 방식으로 대상과 상호작용하고 싶을 때 사용할 수 있는 패턴이다.
* 테스트-주도 개발: 테스트를 먼저 작성하고 테스트를 통과하는 구체적인 코드를 추가하면서 완성해가는 방식이다. 객체가 이미 존재한다고 가정하고 객체에게 어떤 메시지를 전송할 것인지에 관해 먼저 생각한다. 테스트-주도 개발은 응집도가 높고 결합도가 낮은 클래스로 구성된 시스템을 개발할수 있게 해준다.

## 책임과 메시지

훌륭한 객체지향의 세계는 명확하게 정의된 역할과 책임을 지닌 객체들이 상호 협력하는 세계다.

### 자율적인 책임

* 자율적인 객체: 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체다. 타인이 정한 규칙이나 명령에 따라 판단하고 행동하는 객체는 자율적인 객체라고 부르기 어렵다.
* 적절한 책임이 자율적인 객체를 낳고, 자율적인 객체들이 모여 유연하고 단순한 협력을 낳는다.
* 무조건 포괄적이고 추상적인 책임을 선택한다고 해서 좋은 것은 아니다. 협력에 참여하는 의도를 명확하게 설명할 수 있는 수준 안에서 추상적이어야 한다.
* 자율적인 책임의 특징은 객체가 '어떻게' 해야 하는가가 아니라 '무엇'을 해야 하는가를 설명한다는 것이다.

### 메시지와 메서드

* 메시지 전송은 수신자, 메시지 이름, 인자의 조합으로 구성된다.
* 객체를 유일하게 이해할 수 있는 의사소통 수단은 메시지 뿐이며 객체는 메시지를 처리하기 위한 방법을 자율적으로 선택할 수 있다. 외부의 객체는 메시지에 관해서만 볼수 있고 객체의 내부는 볼 수 없기 떄문에 자연스럽게 객체의 외부와 내부가 분리된다.
* 객체는 메시지를 수신하면 먼저 해당 메시지를 처리할 수 있는지 여부를 확인한다. 처리할 수 있다면, 자신에게 주어진 책임을 다하기 위해 메시지를 처리할 방법인 메서드를 선택하게 된다.
* 다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미한다. 다형성은 메시지 송신자의 관점에서 동일한 역할을 수행하는 다양한 타입의 객체와 협력할 수 있게 한다.
* 송신자가 수신자에 대해 매우 적은 정보만 알고 있더라도(결합도가 낮다) 상호 협력이 가능하다는 사실은 설계의 품질에 큰 영향을 미친다.
  * 협력이 유연해진다. 송신자는 수신자가 메시지를 이해한다면 누구라도 상관하지 않는다.
  * 협력이 수행되는 방식을 확장할 수 있다. 송신자에게 아무런 영향을 미치지 않고서도 수신자를 교체할 수 있기 때문에 협력의 세부적인 수행 방식을 쉽게 수정할 수 있다.
  * 협력이 수행되는 방식을 재사용할 수 있다. 협력에 영향을 미치지 않고서도 다양한 객체들이 수신자의 자리를 대체할 수 있기 때문에 다양한 문맥에서 협력을 재사용할 수 있다.

### 메시지를 따라라

* 훌륭한 객체지향 설계는 어떤 객체가 어떤 메시지를 전송할 수 있는가와 어떤 객체가 어떤 메시지를 이해할 수 있는가를 중심으로 객체 사이의 협력 관계를 구성하느 것이다.
* 객체지향 설계의 중심에는 메시지가 위치한다. 객체가 메시지를 선택하는것이 아니라 메시지가 객체를 선택하게 해야 한다. 결과적으로 메시지가 수신자의 책임을 결정한다.
* What/Who 사이클: 객체 사이의 협력 관계를 설계하기 위해서는 먼저 '어떤 행위(what)`을 수행할 것인지를 결정한 후에 '누가(who)' 그 행위를 수행할 것인지를 결정해야 한다는 것이다. 여기서 '어떤 행위'가 메시지가 되고, '누가(who)`가 객체가 된다.
* 묻지 말고 시켜라(데메테르 법칙): 객체가 다른 객체의 상태를 묻는다는 것은 메시지를 전송하기 이전에 객체가 가져야 하는 상태에 관해 너무 많이 고민하고 있었다는 증거다. 단지 필요한 메시지를 전송하기만 하고메시지를 수신하는 객체가 스스로 메시지의 처리 방법을 결정하게 하라. '묻지 말고 시켜라' 스타일은 객체를 자율적으로 만들고 캡슐화를 보장하며 결합도를 낮게 유지시켜 주기 때문에 설계를 유연하게 만든다.
* 메시지를 기반으로 다양한 타입의 객체들이 동일한 협력 과정에 참여할 수 있기 때문에 다양한 상황에서 협력을 재사용할 수 있다. 다형성은 개별 객체가 아니라 객체들이 주고받는 메시지에 초점을 맞출 때 비로소 그 진가를 발휘하게 된다. 메시지를 중심으로 설계된 구조는 유연하고 확장 가능하며 재사용 가능하다.

### 객체 인터페이스

* 인터페이스: 어떤 두 사물이 마주치는 경계 지점에서 서로 상호작용할 수 있게 이어주는 방법이나 장치
* 인터페이스의 특징
  * 인터페이스의 사용법을 익히기만 하면 내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달할 수 있다.
  * 인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동방식만을 변경하는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않는다.
  * 대상이 변경되더라도 동일한 인터페이스를 제공하기만 하면 아무런 문제 없이 상호작용할 수 있다.
* 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록이다.
* 인터페이스는 외부에서 접근 가능한 공개된 인터페이스와 내부에서만 접근할 수 있는 감춰진 인터페이스로 구분된다. 외부에 공개된 인터페이스를 공용 인터페이스라고 한다.

### 인터페이스와 구현의 분리

* 객체지향적인 사고 방식을 이해하기 위한 세 가지 원칙

    * 좀 더 추상적인 인터페이스: 세부 사항을 제거하고 메시지의 의도를 표현하기 위해 추상화하라.
    * 최소 인터페이스: 외부에서 사용할 필요가 없는 인터페이스는 최대한 노출하지 마라.
    * 인터페이스와 구현 간에 차이가 있다는 점을 인식: 객체의 내부 구조와 작동 방식을 가리키는 용어는 구현이다. 자율적인 객체는 외부에 영향을 주지 않고도 메서드를 자유롭게 변경할 수 있어야 한다는 것을 의미한다.
    * 캡슐화: 객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 것
    * 캡슐화의 두 가지 관점
      * 상태와 행위의 캡슐화(데이터 캡슐화): 객체는 스스로 자신의 상태를 관리하며 상태를 변경하고 외부에 응답할 수 있는 행동을 내부에 함께 보관한다.
      * 사적인 비밀의 캡슐화: 캡슐화를 통해 변경이 빈번하게 일어나는 불안정한 비밀을 안정적인 인터페이스 뒤로 숨길 수 있다.

    #### 책임의 자율성이 협력의 품질을 결정한다

    * 자율적인 책임은 협력을 단순하게 만든다. 즉 책임이 적절하게 추상화된다.
    * 자율적인 책임은 객체의 외부와 내부를 명확하게 분리한다. 요청하는 객체가 몰라도 되는 사적인 부분이 객체 내부로 캡슐화되기 때문에 인터페이스와 구현이 분리된다.
    * 책임이 자율적일 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않는다. 변경의 파급효과가 객체 내부로 캡슐화되기 때문에 두 객체 간의 결합도가 낮아진다.
    * 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다. 설계가 유연해지고 재사용성이 높아진다.
    * 객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다. 객체는 동일한 목적을 달성하는 강하게 연관된 책임으로 구성되기 때문에 객체의 응집도를 높은 상태로 유지하기가 쉬워진다.

    ### 객체 지도

    구조를 중심으로 기능을 종속시키는 접근법은 범용적이고 재사용 가능하며 변경에 유연하게 대처할 수 있는 모델을 만든다. 자주 변경되는 기능이 아니라 안정적인 구조를 기반으로 시스템을 분할하는 객체지향적인 접근법은 역할, 책임, 협력을 기반으로 시스템의 기능을 구현하는 책임-주도 설계의 본질을 이해하는 데도 도움이 될 것이다.

    #### 기능 설계 대 구조 설계

    * 기능 측면 설계: 제품이 사용자를 위해 무엇을 할 수 있는지에 초점을 맞춘다.
    * 구조 측면 설계: 제품의 형태가 어떠해야 하는지에 초점을 맞춘다.
    * 훌륭한 설계는 사용자가 만족할 수 있는 훌륭한 기능을 제공하는 동시에 예측 불가능한 요구사항 변경에 유연하게 대처할 수 있는 안정적인 구조를 제공하는 것이다.
    * 전통적인 기능 분해는 기능이 변경될 경우 기능의 축을 따라 설계된 소프트웨어가 전체적으로 요동치기 때문에 취약하다.
    * 객체지향 접근방법은 자주 변경되지 않는 안정적인 객체 구조를 바탕으로 시스템 기능을 객체 간의 책임으로 분배한다. 기능이 변경되더라도 객체 간의 구조는 그대로 유지된다.

    #### 두 가지 재료: 기능과 구조

    * 구조는 사용자나 이해관계자들이 도메인에 관해 새각하는 개념과 개념들 간의관계로 표현한다. 구조를 수집하고 표현하기 위한 기법을 도메인 모델링이라고 한다.
    * 기능은 사용자의 목표를 만족시키기 우해 책임을 수행하는 시스템 행위로 표현한다. 기능을 수집하고 표현하기 위한 기법을 유스케이스 모델링이라고 한다.

    #### 안정적인 재료: 구조

    * 도메인: 사용자가 프로그램을 사용하는 대상 분야
    * 도메인 모델: 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태. 도메인 모델은 이해관계자들이 바라보는 멘탈 모델이다.
    * 멘탈 모델: 사람들이 자기 자신, 다른 사람, 환경, 자신이 상호작용하는 사물들에 대해 갖는 모형
    * 도메인 모델은 사용자들이 도메인을 바라보는 관점이며, 설계자가 시스템의 구조를 바라보는 관점인 동시에 소프트웨어 안에 구현된 코드의 모습 그 자체이다. 최종 코드는 사용자가 도메인을 바라보는 관점을 반영해야 되기 때문에 애플리케이션이 도메인 모델을 기반으로 설계돼야 하는 이유이다.
    * 도메인에 대한 사용자의 관점을 반영해야 되는 이유는 사용자들이 누구보다 도메인의 본질적인 측면을 가장 잘 이해하고 있기 때문이다.
    * 표현적 차이: 소프트웨어 객체가 현실 객체가 갖지 못한 특성을 가질 수 있고 현실 객체가 하지 못하는 행동을 할수 있는 의미적 거리. 표현적 차이는 소프트웨어를 이해하고 수정하기 쉽게 만들어준다.
    * 안정적인 구조를 제공하는 도메인 모델을 기반으로 소프트웨어의 구조를 설계하면 변경에 유연하게 대응할 수 있는 탄력적인 소프트웨어를 만들 수 있다.

    #### 불안정한 재료: 기능

    * 유스케이스: 사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상효작용을 텍스트로 정리한 것
    * 유스케이스의 가치는 사용자들의 목표를 중심으로 시스템의 기능적인 요구사항들을 이야기 형식으로 무을 수 있다는 점이다.
    * 유스케이스의 특성
      * 유스케이스는 사용자의 시스템 간의 상호작용을 보여주는 '텍스트'다. 다이어그램에 노력을 쏟지 마라.
      * 유스케이스는 하나의 시나리오가 아니라 여러 시나리오들의 집합이다. 시나리오는 유스케이스를 통해 시스템을 사용하는 하나의 특정한 이야기 또는 경로다.
      * 유스케이스는 단순한 피처 목록과 다르다. 피처는 시스템이 수행해야 하는 기능의 목록을 단순하게 나열한 것이다.
      * 유스케이스는 사용자 인터페이스와 관련된 세부 정보를 포함하지 말아야 한다.
      * 유스케이스는 내부 설계와 관련된 정보를 포함하지 않는다. 유스케이스는 시스템이 외부에 제공해야 하는 행위만 포함하기 때문에 유스케이스로부터 시스템의 내부 구조를 유추할 수 있는 방법은 존재하지 않는다.

    #### 재료 합치기: 기능과 구조의 통합

    * 변경에 유연한 소프트웨어를 만들기 위해서는 유스케이스에 정리된 시스템의 기능을 도메인 모델을 기반으로 한 객체들의 책임으로 분배해야한다.
    * 객체 설계는 요구사항들을 식별하고 도메인 모델을 생성한 후, 소프트웨어 클래스에 메서드들을 추가하고, 요구사항을 충족시키기 위해 객체들 간의 메시지 전송을 정의하는 것이다.
    * 유스케이스는 사용자에게 제공할 기능을 시스템의 책임으로 보게 함으로써 객체 간의 안정적인 구조에 책임을 분배할 수 있는 출발점을 제공한다. 도메인 모델은 기능을 수용하기 위해 은유할 수 있는 안정적인 구조를 제공한다.
    * 책임-주도 설계 방법은 시스템의 기능을 역할과 책임을 수행하는 객체들의 협력 관계로 바라보게 함으로써 유스케이스와 도메인 모델을 통합한다.
    * 도메인 모델이 안정적인 이유
      * 도메인 모델을 구성하는 개념은 비즈니스가 없어지거나 완전히 개편되지 않는 한 안정적으로 유지된다.
      * 도메인 모델을 구성하는 개념간의 관계는 비즈니스 규칙을 기반으로 하기 때문에 비즈니스 정책이 크게 변경하지 않는 한 안정적으로 유지된다.
    * 객체재향의 가장 큰 장점은 도메인을 모델링하기 위한 기법과 도메인을 프로그래밍하기 위해 사용하는 기법이 동일하다는 점이다. 이 같은 특성을 연결완전성이라고 한다.
    * 모델에서 코드로의 매끄러운 흐름을 의미하는 연결완전성과 반대로 코드에서 모델로의 매끄러운 흐름을 의미하는 것을 가역성이라고 한다.

## 함께 모으기

객체지향 설계 시에 3 가지의 상호 연고나된 관점이 존재한다.

* 개념 관점: 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다. 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심이다.
* 명세 관점: 사용자의 영역인 도메인을 벗어나 개발자의 영역인 소프트웨어로 초점이 옮겨진다. 명세 관점은 도메인의 개념이 아니라 실제로 소프트웨어 안에서 살아 숨쉬는 객체들의 책임에 초점을 맞추게 된다. 즉, 객체의 인터페이스를 바라보게 된다.
* 구현 관점: 실제 작업을 수행하는 코드와 연관돼 있다. 구현 관점의 초점은 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것이다.

클래스는 세 가지 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함꼐 드러내야 한다.

### 커피 전문점 도메인

* 어떤 객체가 다른 객체에 포함돼 있다고 할 수 있을 떄, 이를 포함 관계 또는 합성 관계라고 한다.
* 한 타입의 인스턴스가 다른 타입의 인스턴스를 포함하지 않지만 서로 알고 있어야 할 경우 이를 연관 관계라고 한다.
* 실제로 도메인 모델을 작성하는 단계에서 어떤 관계가 포함 관계이고 어떤 관계가 연곤 관계인지는 중요하지 않다. 초점은 어떤 타입이 도메인을 구성하느냐와 타입들 사이에 어떤 관계가 존재하는지를 파악함으로써 도메인을 이해하는 것이다.

### 설계하고 구현하기

* 구현하지 않고 머릿속으로 구상한 설계는 코드로 구현하는 단계에서 대부분 변경된다. 중요한 것은 설계가 아니라 코드다.
* 객체의 속성은 객체의 내부 구현에 속하기 때문에 캡슐화돼야 한다. 객체의 속성이 캡슐화 된다는 이야기는 인터페이스에는 객체의 내부 속성에 대한 어떤 힌트도 제공돼서는 안 된다는 것이다.

### 코드와 세 가지 관점

* 소프트웨어 클래스가 도메인 개념의 특성을 최대한 수용하면 변경을 관리하기 쉽고 유지보수성을 향상시킬 수 있다. 소프트웨어 클래스와 도메인 클래스 사이의 간격이 좁으면 좁을수록 기능을 변경하기 위해 뒤적거려야 하는 코드의 양도 점점 줄어든다.
* 명세 관점은 클래스의 인터페이스를 바라본다. 클래스의 public 메서드는 다른 클래스가 협력할 수 있는 공용 인터페이스를 드러낸다.
* 구현 관점은 클래스의 내부 구현을 바라본다. 클래스의 메서드와 속성은 구현에 속하며 공용 인터페이스의 일부가 아니다.
* 인터페이스와 구현을 분리하라. 인터페이스가 구현 세부 사항을 노출하기 시작하면 아주 작은 변동에도 전체협력이 요동치는 취약한 설계를 얻을 수밖에 없다. 명세 관점이 설계를 주도하게 하면 설계의 품질이 향상될 수 있다는 사실을 기억하라.

## 추상화 기법

### 추상화 기법

추상화 기법의 종류는 다음이 있다.

* 분류와 인스턴스화: 분류는 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정이다. 분류의 역은 범주로부터 객체를 생성하는 인스턴스화 과정이다.
* 일반화와 특수화: 일반화는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조한다. 일반화의 역을 특수화라고 한다.
* 집합과 분해: 집합은 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전첼르 형성하는 과정을 가리킨다. 집합의 반대 과정은 전체를 부분으로 분리하는 분해 과정이다.

### 분류와 인스턴스화

* 객체를 분류하고 범주로 묶는 것은 개체들의 특정 집합에 공통의 개념을 적용하는 것을 의미한다.
* 객체지향의 세계에서 개념을 가리키는 표준 용어는 타입이다.
* 한 객체가 한 시점의 하나의 타입에만 속하는 것을 단일 분류, 여러 타입에 속할 경우를 다중 분류라고한다.
* 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있다면 동적 분류, 없다면 정적 분류라고 한다.
* 다중 분류와 동적 분류는 상호 배타적인 개념이 아니다. 다중 분류와 동적 분류는 객제지향 프로그래밍 언어의 제약으로 인해 이를 구현으로 옮기기는 쉽지 않다. 다중 분류와 동적 분류 관점에서 도메인 모델의 초안을 만든 후 실제 구현에 적합하도록 단일 분류와 정적 분류 방식으로 객체들의 범주를 재조정하는 편이 분석과 구현 간의 차이를 메울 수 있는 가장 현실적인 방법이다.

### 일반화와 특수화

* 어떤 타입이 다른 타입보다 일반적이라면 이 타입을 슈퍼타입이라고 한다. 어떤 타입이 다른 타입보다 좀 더 특수하다면 이 타입을 서브타입이라고 한다.
* 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 다음의 규칙들을 준수해야 된다.
  * 100% 규칙: 슈퍼타입의 정의가 100% 서브타입에 적용돼야만 한다. 서브타입은 속서과 연관관계 면에서 슈퍼타입과 100% 일치해야 한다.
  * Is-a 규칙: 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다. 이는 대개 영어로 서브타입은 슈퍼타입이다라는 구문을 만듦으로써 테스트할 수 있다.
* 상속은 서브타이핑과 서브클래싱의 두 가지 용도로 사용될 수 있다. 서브클래스가 슈퍼클래스를 대체할 수 있는 경우 이를 서브타이핑이라고 한다. 서브클래스가 슈퍼클래스를 대체할 수 없는 경우에는 서브클래싱이라고 한다. 서브타이핑은 설계의 유연성이 목표인 반면 서브클래싱은 코드 중복 제거와 재사용이 목적이다.
* 여러 클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스 간의 우임을 사용하는 것이다.

### 집합과 분해

* 안정적인 형태의 부분으로부터 전체를 구축하는 행위를 집합이라고 하고 집합과 반대로 전체를 부분으로 분할하는 행위를 분해라고 한다.
* 집합은 많은 수의 사물들의 형상을 하나의 단위로 다룸으로써 복잡성을 줄을 수 있는데, 집합은 전체의 내부로 불필욯나 세부 사항을 감춰주기 때문에 추상화 메커니즘인 동시에 캡슐화 메커니즘이다.
* 객체와 객체 사이의 전체-부분 관계를 구현하기 위해서는 합 성관계를 사용한다. 합성 관계는 부분을 전체 안에 캡슐화함으로써 인지 과부하를 방지한다.
* 객체 사이의 전체-부분 관계가 아니고 단순한 물리적 통로가 존재하는 관계를 연관 관계라고 한다. 일반적으로 합성 관계로 연결된 객체는 포함하는 객체가 제거될 때 내부에 포함된 객체도 함께 제거된다. 이에 반해 연관 관계로 연결된 두 객체는 생명주기와 관련된 어떤 제약도 부과하지 않는다.
* 합성 관계를 이용해 커다락 객체 그룹을 단순화하더라도 클래스의 수가 많아지면 많아질수록 얽히고 설킨 클래스 간의 복잡도가 높아진다. 상공에서 바라본 소프트웨어의 전체적인 구조를 표현하기 위해 관련된 클래스ㅇ 집합을 하나의 논리적이 단위로 묶는 구성 요소를 패키지 또느 모듈이라고 한다.
