---
title: 9-웹 크롤러 설계
tags:
  - 도서/가상-면접-사례로-배우는-대규모-시스템-설계-기초
---
- 웹 크롤러 용도
	- 검섹 엔진 인덱싱: 웹 페이지를 모아 검색 엔진을 위한 로컬 인덱스를 만든다.
	- 웹 아카이빙: 나중에 사용할 목적으로 장기보관하기 위해 웹에서 정보를 모으는 절차를 말한다.
	- 웹 마이닝: 인터넷에서 유용한 지식을 도출한다.
	- 웹 모니터링: 인터넷에서 저작권이나 상표권이 침해되는 사례를 모니터링할 수 있다.

## 문제 이해 및 설계 범위 확정

- 좋은 웹 크롤러가 만족시켜야 할 속성
	- 규모 확장성: 병행성을 활용하면 효과적으로 웹 크롤링을 할 수 있다.
	- 안정성: 잘못 작성된 HTML, 아무 반응이 없는 서버, 장애, 악성 코드가 붙어 있는 링크에 잘 대응할 수 있어야 한다.
	- 예절: 크롤러는 수집 대상 웹 사이트에 짧은 시간 동안 너무 많은 요청을 보내서는 안 된다.
	- 확장성: 새로운 형태의 콘텐츠를 지원하기가 쉬워야 한다.(예: 이미지 파일 등)
- 개략적 규모 추정
	- 매달 10억 개의 웹 페이지를 다운로드한다.
	- QPS: 10억/30일/24시간/3600초 = 대략 400페이지/초
	- 최대 QPS = 2 \* QPS = 800
	- 웹 페이지의 크기 평균은 500K라고 가정
	- 10억 페이지 \* 500k = 500TB/월
	- 1개월치 데이터를 보관하는 데 500TB, 5년간 보관한다고 가정하면 500TB \* 12개월 \* 5년 = 30PB 저장용량이 필요할 것이다.

## 개략적 설계안 제시 및 동의 구하기

![](assets/Pasted%20image%2020260128213709.png)

- 시작 URL 집합: 웹 크롤러가 크롤링을 시작하는 출발점
	- 시작 URl을 고를 때 좀 더 창의적일 필요가 있다.
	- 크롤러가 가능한 한 많은 링크를 탐색할 수 있도록 하는 URL을 고르는 것이 바람직할 것이다.
- 미수집 URL 저장소: 
	- 웹 크롤러는 상태를 (1) 다운로드할 URL, (2) 도운로드된 URL 두 가지로 나눠 관리한다.
	- 다운로드할 URL을 '미수집 URl 저장소'에 저장한다.
- HTML 다운로드: 웹 페이지를 다운로드하는 컴포넌트
- 도메인 이름 변환기: URL을 IP 주소로 변환한다.
- 콘텐츠 파서: 다운드한 웹 페이지를 파싱과 검증한다.
	- 문제가 있는 웹 페이지를 저장 공간에 낭비하지 않게 한다.
	- 크롤링 서버 안에 콘텐츠 파서를 구현하면 크롤링 과정이 느려지게 될 수 있으므로, 독립된 컴포넌트로 만들었다.
- 중복 콘텐츠?: 중복을 줄여서 데이터 처리에 소요되는 시간을 줄인다.
	- 중복을 확인하는 효과적인 방법은 웹 페이지의 해시값을 비교하는 것이다.
- 콘텐츠 저장소: HTML 문서를 보관하는 시스템
- URL 추출기: HTML 페이지를 파싱하여 링크들을 골라낸다.
	- 상대 경로는 전부 절대 경로로 변환한다.
- URL 필터: 특정한 콘텐츠 타입이나 파일 확장자를 갖는 URL, 접속 시 오류가 발생하는 URl, 접근 제외 목록에 포함된 URl 등을 크롤링 대상에서 배제하는 역할을 한다.
- 이미 방문한 URL: 
	- 이미 방문한 URL이나 미수집 URL 저장소에 보관된 URL을 추적할 수 있도록 하는 자료 구조를 사용한다.
	- 블룸 필터나 해시 테이블이 널리 쓰인다.
- URL 저장소: 이미 방문한 URL을 보관하는 저장소

## 상셰 설계

### DFS vs BFS

- 크롤러는 보통 BFS를 사용한다.
	- 이유: 그래프 크기가 클 경우 어느 정도로 깊숙이 가게 될지 가늠하기 어려워서다.
- BFS에도 두 가지 문제점이 있다.
	- 한 페이지에서 나오는 링크의 상당수는 같은 서버로 되돌아간다. 이때 링크들을 병렬로 처리하게 된다면 수많은 요청으로 과부하에 걸리게 될 것 이다. 이런 크롤러를 '예의 없는' 크롤러로 간주한다.
	- 표준적인 BFS 알고리즘은 URL 간에 우선순위를 두지 않는다. 하지만 모든 웹 페이지가 같은 수준의 품질, 같은 수준의 중요성을 갖지 않는다.

### 미수집 URL 저장소

#### 예의

- 예의 바른 크롤러를 만드는 데 있어서 지켜야 할 한 가지 원칙은, 동일 웹 사이트에 대해서는 한 번에 한 페이지만 요청하나는 것이다.
- 이 요구사항을 만족시키려면 웹사이트의 호스트명과 다운로드를 수행하는 작업 스레드 사이의 관계를 유지하면 된다.
	- 각 다운로드 스레드는 별도 FIFO 큐를 가지고 있어서, 해당 큐에서 꺼낸 URL만 다운로드한다.
	- 큐 라우터: 같은 호스트에 속한 URL은 언제나 같은 큐로 가도록 보장한다.
	- 매핑 테이블: 호스트 이름과 큐 사이의 관계를 보관하는 테이블
	- FIFO 큐:  같은 호스트에 속한 URL은 언제나 같은 큐에 보관한다.
	- 큐 선택기: 큐들을 순회하면서 큐에서 URL을 꺼내서 해당 큐에서 나온 URL을 다운로드하도록 지정된 작업 스레드에 전달하는 역할을 한다.
	- 작업 스레드: 전달된 URL을 다운로드하는 작업을 수행한다.

![](assets/Pasted%20image%2020260128220445.png)

#### 우선순위

- 페이지의 유용성에 따라 URL의 우선순위를 나눌 때는 페이지랭크, 트래픽 양, 갱신 빈도 등 다양한 척도를 사용할 수 있을 것이다.
- URL 우선순위 고려한 설계가 필요하다.
	- 순위결정장치: URL을 입력으로 받아 우선순위를 게산한다.
	- 큐(f1, ..., fn): 우선순위별로 큐가 한씩 할당된다. 우선순위가 높으면 선택될 확률도 올라간다.
	- 큐 선택기: 임의 큐에서 처리할 URL을 꺼내는 역할을 담당한다. 순위가 높은 큐에서 더 자주 꺼내도록 프로그램되어 있다.

#### 예의를 고려한 모듈과 우선 순위 모듈을 모두 합친 결과

![](assets/Pasted%20image%2020260128221213.png)

#### 신선도

- 데이터의 신선함을 유지하기 위해서 이미 다운로드한 페이지라도 주기적으로 재수집할 필요가 있다.
- 모든 URL을 재수집하지 않고 최적화하기 위한 전략으로는 다음과 같은 것들이 있다.
	- 웹 페이지의 변경 이력 활용
	- 우선순위를 활용하여, 중요한 페이지는 좀 더 자주 재수집

### HTML 다운로더

#### Robots.txt

- Robots.txt는 웹사이트와 크롤러와 소통하는 표준적 방법이다.
- 이 파일에는 크롤러가 수집해도 되는 페이지 목록이 들어이다.

#### 성능 최적화

- 분산 크롤링: 성능을 높이기 위해 크롤링 작업을 여러 서버에 분산하는 방법.
	- ![](assets/Pasted%20image%2020260128221848.png)
- 도메인 이름 변환 결과 캐시: 
	- DNS 요청을 보내고 결과를 받는 작업은 성능의 병목 중 하나다.
	- DNS 조회 결과로 얻어진 도메인 이름과 IP 주소 사이의 관계를 캐시에 보관해 놓고 크론 잡 등을 돌려 주기적으로 갱신하도록 해 놓으면 성능을 효과적으로 높일 수 있다.
- 지역성: 크롤링 서버가 크롤링 대상 서버와 지역젹으로 가까우면 페이지 다운로드 시간은 줄어들 것이다.
- 짧은 타임아웃: 대기 시간이 길어지면 좋지 않으므로, 최대 얼마나 기다릴지 미리 정해두고 응답하지 않으면 해당 페이지 다운로드를 중단하고 다음 페이지로 넘어간다.

#### 안정성

- 시스템 안정성을 향상시키기 위한 접근법
	- 안정 해시: 다운로더 서버들에 부하를 분산할 때 적용 가능한 기술
	- 크롤링 상태 및 수집 데이터 저장: 장애가 발생한 경우에도 쉽게 복구할 수 있도록 크롤링 상태와 수집된 데이터를 지속적 저장장치에 기록해 두는 것이 바람직하다.
	- 예외 처리: 대구모 시스템에서 에러는 불가피할 뿐 아니라 흔하게 벌어지는 일이다. 예외가 발생해도 전체 시스템이 중단되는 일 없이 그 작업을 이어나갈 수 이써야 한다.
	- 데이터 검증: 시스템 오류를 방지하기 위한 중요 수단 가운데 하나다.

#### 확장성

- 새로운 형태의 콘텐츠를 쉽게 지원할 수 있도록 신경 써야 한다.
- ![](assets/Pasted%20image%2020260128222538.png)

#### 문제 있는 콘텐츠 감지 및 회피

- 중복 콘텐츠: 해시나 체크섬을 사용해서 중복 콘텐츠를 탐지한다.
- 거미 덫: 
	- 크롤러가 무한 루프에 빠지도록 설계된 웹 페이지가 거미 덫이다.
	- 예시: `spidertrapexample.com/foo/bar/foo/bar/foo/bar/...`
	- 덫을 자동으로 피해가는 알고리즘을 만들어내는 것은 까다롭다.
		- 한 가지 방법은 사람이 수작업으로 덫을 확인하고 찾아낸 후 덫이 있는 사이트를 크롤러 탐색 대상에서 제외하거나 URL 필터 목록에 걸어두는 것이다.
- 데이터 노이즈:
	- 광고나 스크립트 코드, 스팸 URL 같은 가치 없는 컨텐츠는 제외해야 한다.
