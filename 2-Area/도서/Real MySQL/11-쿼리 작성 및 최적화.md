# 쿼리 작성 및 최적화

## 쿼리 작성과 연관된 시스템 변수

### SQL 모드

- MySQL 서버의 `sql_mode` 라는 시스템 설정에는 여러 개의 값이 동시에 설정될 수 있다.
	- `sql_mode`를 설정할 때는 구분자(,)를 이용해 키워드를 동시에 여러 개 설정할 수 있다.
- MySQL 서버의 `sql_mode` 시스템 변수에 설정된 값들은 SQL 문장 작성 규칙뿐만 아니라 MySQL 서버 내부적으로 자동 실행되는 데이터 타입 변환 및 기본값 제어 등과 관련된 옵션도 가지고 있다.
	- 그래서 일단 MySQL 서버에 사용자 테이블을 생성하고 데이터를 저장하기 시작했담녀 가능한 한 `sql_mode` 시스템 변수의 내용은 변경하지 않는 것이 좋다.
- 명시 가능한 시스템 변수
	- `STRICT_ALL_TABLES`, `STRICT_TRANS_TABLES`
	- `ANSI_QUATES`
	- `ONLY_FULL_GROUP_BY`
	- `PIPE_AS_CONCAT`
	- `PAD_CHAR_TO_FULL_LENGTH`
	- `NO_BACKSLASH_ESCAPES`
	- `IGNORE_SPACE`
	- `REAL_AS_FLOAT`
	- `NO_ZERO_IN_DATE`, `NO_ZERO_DATE`
	- `ANSI`
	- `TRADITIONAL`

### 영문 대소문자 구분

- MySQL 서버는 설치된 운영체제에 따라 테이블명의 대소문자를 구분한다.
	- 이는 MySQL의 DB나 테이블이 디스크의 디렉터리나 파일로 매핑되기 때문이다.
	- 윈도우에 설치된 MySQL에서는 대소문자를 구분하지 않지만 유닉스 계열의 운영체제에서는 대소문자를 구분한다.
- MySQL 서버가 운영체제와 관계없이 대소문자 구분의 영향을 받지 않게할면 MySLQ 서버 설정 파일에 `lower_case_table_names` 시스템 변수를 설정하면 된다.
	- 1로 설정하면 모두 소문자로만 저장되고, MySQL 서버가 대소문자를 구분하지 않는다.
	- 기본값인 0은, DB나 테이블명에 대해 대소문자를 구분한다.
	- 윈도우와 macOS에서는 2를 설정할 수 있는데, 이 경우에는 저장은 대소문자를 구분해서 하지만 MySQL의 쿼리에서는 대소문자를 구분하지 않게 해준다.
- 이러한 설정 자체를 떠나서 가능함녀 초기 DB나 테이블을 생성할 때 대문자 또는 소문자만으로 통일해서 사용하는 편이 좋다.

### MySQL 예약어

- 생성하는 데이터베이스나 테이블, 컬럼의 이름을 예약어와 같은 키워드로 생성하면 해당 컬럼이나 테이블을 SQL에서 사용하기 위해 항상 역따옴표(\`)나 쌍따옴표로 감싸야 한다.
- 예약어를 모두 구분해서 기억하기란 쉽지 않기 때문에, 테이블을 생성할 때 역따옴표로 테이블을 명이나 컬럼명을 둘러싸지 않고 생성해보는 것이 좋다.
	- 예약어가 존재한다면 에러가 발생할 것이다.

## MySQL 연산자와 내장 함수

- MySQL에서만 사용되는 연산자나 표기법이 있다.
- 이번 절에서는 MySQL에서만 사용 가능한 연산자도 함께 살펴보겟지만, 가능하면 SQL의 가독성을 높이기 위해 ANSI 표준 형태의 연산자를 사용하기를 권장한다.

### 리터럴 표기법 문자열

#### 문자열

- SQL 표준에서는 항상 홀따옴표(')를 사용해서 표시한다.
- 하지만 MySQL에서는 다음과 같이 쌍따옴표를 사용해 문자열을 표기할 수도 있다.
	- ![](assets/Pasted%20image%2020240822030808.png)
- SQL 표준에서는 문자열 값에 홀땅모표가 포함돼 있을 때 홀따옴표를 두번 연속해서 입력하면 된다.
- 하지만 MySQL에서는 쌍따옴표와 홀따옴표를 혼합해서 이러한 문제를 피해 가기도 한다.
	- ![](assets/Pasted%20image%2020240822030849.png)
- SQL에서는 사용되는 식별자가 키워드와 충돌할 때 오라클이나 PostgreSQL에서는 쌍따옴표나 대괄호로 감싸서 충돌을 피한다.
- MySQL에서는 역따옴표(\`)를 감싸서 사용하면 예약어와의 충돌을 피할 수 있다.
	- ![](assets/Pasted%20image%2020240822030948.png)
	- ![](assets/Pasted%20image%2020240822031015.png)

#### 숫자

- 숫자 값을 상수로 사용할 때는 따옴표(' 또는 ") 없이 숫자 값을 입력하면 된다.
- MySQL은 숫자 타입과 문자열 타입 간의 비교에서 숫자 타입을 우선시하므로 문자열 값을 숫자 값으로 변환한 후 비교를 수행한다.
	- 첫 번째 쿼리는 주어진 상숫값을 숫자로 변환하는데, 이때는 상숫값 하나만 변환하므로 성능과 관련된 문제가 발생하지 않는다.
	- 두 번째 쿼리는 `string_column`  컬럼의 모든 문자열 값을 숫자로 변환해 비교하므로 인덱스가 있더라도 이를 이용하지 못한다.
	- ![](assets/Pasted%20image%2020240822031300.png)

#### 날짜

- 다른 DBMS에서 날짜 타입을 비교하거나 INSERT 하려면 문자열을 DATE 타입으로 변환하는 코드가 필요하다.
- 하지만 MySQL에서는 정해진 형태의 날짜 포맷으로 표기하면 MySQL 서버가 자동으로 DATE나 DATETIME 값으로 변환한다.
- 아래 두 쿼리는 MySQL에서 동작에 차이가 없다.
	- ![](assets/Pasted%20image%2020240822031539.png)

#### 불리언

- BOOL 이나 BOOLEAN이라는 타입이 있지만 사실 이것은 TINYINT 타입에 대한 동의어일 뿐이다.
- MySQL에서는 FALSE가 정숫값이 0이 되지만 TRUE는 C/C++ 언어와 달리 1만을 의미한다는 점에 주의해야한다.
- 그래서 숫자 값이 저장된 컬럼을 TRUE나 FALSE로 조회하려면 0이나 1이외의 숫자 값은 조회되지 않는다.
	- ![](assets/Pasted%20image%2020240822031919.png)

### MySQL 연산자

#### 동등(Equal) 비교(=, <=>)

- 동등 비교는 "=" 기호를 사용해 비교를 수행하면된다.
- MySQL에서는 추가로 NULL-Safe 동등 비교를 위해 "<=>" 연산자도 제공한다.
	- ![](assets/Pasted%20image%2020240822032154.png)
	- ![](assets/Pasted%20image%2020240822032200.png)

#### 부정(Not-Equal) 비교(<>, !=)

- 일반적으로 "<>"를 많이 사용한다.
- "!=" 도 사용 가능한데, SQL 문장에서 혼용되면 가독성이 떨어지므로 통일해서 사용하는 방법을 권장한다.


#### NOT 연산자(!)

- TRUE 또는 FALSE 연산의 겨로갈르 반대로 만드는 연산자로 "NOT"을 사용한다.
- 불리언 값뿐만 아니라 숫자나 문자열 표현식에서도 사용할 수 잇지만 부정의 결괏값을 정확히 예측할 수 없는 경우에는 사용을 자제하는 것이 좋다.
- ![](assets/Pasted%20image%2020240822032431.png)
- ![](assets/Pasted%20image%2020240822032437.png)

#### AND(&&)와 OR(||) 연산자

- MySQL에서는 AND와 OR 뿐만 아니라 "&&"dhk "||"의 사용도 허용한다.
- 오라클에서는 "||"를 불리언 표현식의 결합 연산자가 아니라 문자열을 결합하는 연산자로 사용한다.
- sql_mode 시스템 변수값에 `PIPE_AS_CONCAT`을 설정하면 MySQL에서도 "||"를 문자열을 결합하는 연산자로 사용할 수 있다.
- SQL의 가독성을 높이기 위해 다른 용도로 사용될 수 있는 "&&" 연산자와 "||" 연산자는 사용ㅇ르 자제하는 것이 좋다.
	- ![](assets/Pasted%20image%2020240822032724.png)

#### 나누기(/, DV)와 나머지(%, MOD) 연산자

- 일반적인 나누기 연산자 "/"
- 나눈 곲의 정수 부분만 가져오려면 DIV
- 나눈 결과의 나머지를 가져오는 연산자로는 "%" 또는 MOD 연산자
- ![](assets/Pasted%20image%2020240822033002.png)

#### REGEXP 연산자

- 비교 대상 문자열 값 또는 문자열 컬럼을 정규 표현식을 사용해서 검증할 때 `RLIKE` 또는 `REGEXP`를 사용할 수 있다.
	- ![](assets/Pasted%20image%2020240827213535.png)
- `REGEXP` 조건의 비교는 인덱스 레인지 스캔을 사용할 수 없기때문에, WHERE 조건절에 `REGEXP` 연산자를 단독으로 사용하는 것은 성능상 좋지 않고 데이터 조회 범위를 주일 수 있는 조건과 함께 사용하길 권장한다.

#### LIKE 연산자

- `LIKE`는 단순한 문자열 패턴 비교 연산자이지만, `REGEXP` 연산자보다 훨씬 더 많ㅇ ㅣ사용한다.
- `LIKE` 연산자는 인덱스를 이용해 처리할 수도 있다.
- 와일드카드 문자인 '%'나 '\_'문자 자체를 비교한다면 `ESCAPE` 절을 `LIKE` 조건 뒤에 추가해 이스케이프 문자를 설정할 수 있다.
	- ![](assets/Pasted%20image%2020240827214121.png)
- 와일드 카드문자인 (%, \_)가 검색어 뒤쪽에 이싸면 인덱스 레인지 스캔으로 상요할수 있지만, 검색어의 앞쪽에 있다면 Left-most 특성으로 인덱스 레인지 스캔을 사용하지 못한다.

#### BETWEEN 연산자

- "크거나 같다"와 "작거나 같다"라는 두 개의 연산자를 하나로 합친 연산자다.
- `BETWEEN` 연산자는 다른 비교 조건과 결합해 하나의 인덱스를 사용할 때 주의해야할 점이 있다.
	- `BETWEEN` 연산자는 범위를 읽어야 하는 연산자라 `dept_no`가 'd003'이상 'd005' 이하인 모든 인덱스의 범위를 검색해야만 한다.
	- `IN` 연산자는 여러 개의 동등 비교를 하나로 묶는 것과 같은 연산자라서 `IN`과 동등 비교 연산자는 같은 형태로 인덱스를 사용한다.
	- ![](assets/Pasted%20image%2020240827214843.png)
	- ![](assets/Pasted%20image%2020240827214856.png)
	- ![](assets/Pasted%20image%2020240827214904.png)

#### IN 연산자

- 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자
- 여러 개의 값이 비교되지만 범위로 검색하는 것이 아니라 여러 번의 동등 비교로 실행하기 때뭉네 일반적으로 빠르게 처리된다.
- IN 연산자는 두 형태를 구분해서 생각해볼 필요가 있다.
	- 상수가 사용된 경우: `IN (?, ?, ?)`
	- 서브쿼리가 사용된 경우: `IN (SELECT ... FROM ...)`
- 상수가 사용된 경우는 동등 비교와 동일하기 작동하기 때문에 매우 빠르게 처리될 수 있다.
	- IN 절에 튜플을 사용한 경우 MySQL 8.0 이전 버전 까지는 항상 풀 테이블 스캔이었지만, MySQL 8.0 부터는 인덱스를 최적으로 사용할 수 있다.
	- ![](assets/Pasted%20image%2020240827220448.png)
- 서브쿼리가 사용된 경우는 최적화가 까다로운데, MySQL 8.0 이전 버전까지만 해도 최적화가 상당히 불안했다. 하지만, MySQL8.0 부터는 최적화가 많이 안정화됐다.
- `NOT IN` 은 부정형 비교여서 인덱스를 이용해 처리 범위를 줄이는 조건으로는 사용할 수 없다.

### MySQL 내장 함수

- MySQL의 함수는 MySQL에서 기본으로 제공하는 내장 함수와 사용자가 직접 작성해서 추가할 수 있는 사용자 정의 함수(UDF, User Defined Function)로 구분된다.
- MySQL에서는 제공하는 C/C++ API를 이요해 사요앚가 원하는 기능을 직접 함수로 만들어 추가할 수 있는데 ,이를 사용자 정의 함수라고 한다.

#### NULL 값 비교 및 대체(IFNULL, ISNULL)

- `IFNULL()`은 두 개의 인자를 전달하는데, 첫 번째 인자는 NULL인지 아닌지 비교하려는 컬럼이나 표현식을, 두 번째 인자로는 첫 번째 인자의 값이 NULL 일 경우 대체할 값이나 컬럼을 설정한다.
	- 첫 번째 인자가 NULL이 아니면 첫 번째 인자의 값을, 첫 번째 인자의 값이 NULL이면 두 번째 인자의 값을 반환한다.
- `ISNULL()` 함수는 이름 그대로 인자를 전달한 표현식이나 컬럼의 값이 NULL이면 TRUE(1), 아니면 FALSE(0)을 반환한다.
- ![](assets/Pasted%20image%2020240827221254.png)

#### 현재 시각 조회(NOW, SYSDATE)

- 하나의 SQL에서 모든 `NOW()` 함수는 같은 값을 가지지만 `SYSDATE()` 함수는 하나의 SQL 내에서도 호출되는 시점에 따라 결괏값이 달라진다.
	- ![](assets/Pasted%20image%2020240827221600.png)
- `SYSDATE()` 함수는 이러한 특성 탓에 두 가지 큰 잠재적인 문제가 있다.
	- `SYSDATE()` 함수가 사용된 SQL은 레플리카 서버에서 안정적으로 복제되지 못한다.
	- `SYSDATE()` 함수와 비교되는 컬럼은 인덱스를 효율적으로 사용하지 못한다.
- 아래와 같이 `SYSDATE()` 함수와 비교된 컬럼은 인덱스를 사용하지 못하고 있다.
	- ![](assets/Pasted%20image%2020240827221750.png)

#### 날짜와 시간의 포맷(DATE_FORMAT, STR_TO_DATE)

- `DATE_FORMAT()` 함수: `DATETIME` 타입의 컬럼이나 값을 원하는 형태의 문자열로 변환
- `STR_TO_DATE` 함수: 문자열을 `DATETIME`으로 변환
- 아래는 대표적인 지정자만 나열했으며, 나머지 더 자세한 사항은 매뉴얼을 참조하자.
	- ![](assets/Pasted%20image%2020240827222350.png)

#### 날짜와 시간의 연산(DATE_ADD, DATE_SUB)

- 특정 날짜에서 연도나 월일 또는 시간 등을 더하거나 뺄 때는 `DATE_ADD()` 함수나 `DATE_SUB()` 함수를 사용한다.
- 두 번째 인자는 `INTERVAL n [YEAR< MONTH< DAY, HOUR, MINUTE, SECOND, ...]` 형태로 입력해야 한다.
- ![](assets/Pasted%20image%2020240827222658.png)
- ![](assets/Pasted%20image%2020240827222715.png)

#### 타임스탬프 연산(UNIX_TIMESTAMP, FROM_UNIXTIME)

- `TIMESTAMP`는 '1970-01-01 00:00:00'으로부터 경과된 초의 수를 말한다.
- `UNIX_TIMESTAMP()` 함수: 인자가 없으면 현재 날짜와 시간의 타임스탬프 값을, 인자로 특정 날짜를 전달하면 그 날짜와 시간의 타임스탬프를 반환한다.
- `FROM_UNIXTIME()` 함수: 인자로 전달한 타임스탬프 값을 `DATETIME` 타입으로 변환하는 함수다.
- MySQL의 `TIMESTAMP` 타입은 4바이트 숫자 타입으로 저장되기 때문에 실제로 가질 수 있는 값의 범위는 '1970-01-01 00:00:00'~'2038-01-09 03:14:07'까지의 날짜 값만 가능하다.

#### 문자열 처리(RPAD, LPAD / RTRIM, LTRIM, TRIM)

- `RPAD()`와 `LPAD()` 함수는 문자열의 좌측 또는 우측에 문자를 덧붙여서 지정된 길이의 문자열로 만다는 함수다.
	- 3개의 인자가 필요하다.
		- 패딩 처리를 할 문자열
		- 패딩 적용 후 결과로 반환될 문자열의 최대 길이
		- 패딩할 문자
- `RTRIM()`와 `LTRIM()` 함수는 문자열의 우측 또는 좌측에 연속된 공백 문자(Space, NewLine, Tab 문자)를 제거하는 함수다.
	- `TRIM()` 함수는 `LTRIM()`과 `RTRIM()`을 동시에 수행하는 함수다.

#### 문자열 결합(CONCAT)

- `CONCAT()`: 여러 개의 문자열을 연결해서 하나의 문자열로 반환하는 함수로, 인자의 개수는 제한이 없다.
	- ![](assets/Pasted%20image%2020240827230658.png)
- `CONCAT_WS()`: 각 문자열을 연결할 때 구분자를 넣어준다.
	- ![](assets/Pasted%20image%2020240827230704.png)

#### GROUP BY 문자열 결합(GORUP_CONCAT)

- `COUNT()`, `MAX()` 등과 같은 그룹 함수 중 하나다.
- 주로 `GROUP BY`와 함께 사용하며, `GROUP BY`가 없는 SQL에서 사용하면 하나의 결과값만 만들어낸다.
- 아래 예시는 `dept_emp` 테이블에서 `emp_no`를 역순으로 정렬해서, `dept_no` 컬럼의 값을 연결해서 가져오는 쿼리다.
- ![](assets/Pasted%20image%2020240827231338.png)
- `GROUP_CONCAT()` 함수는 지정한 컬럼의 값들을 연결하기 위해 제한적인 메모리 버퍼 공간을 사용한다.
	- 어떤 쿼리에서 `GROUP_CONCAT()` 함수의 겨로가가 시스템 변수(`group_concat_max_len`)에 지정된 크기를 초과하면 경고 메시지가 발생한다.
	- 하지만 JDBC로 실행될 때는 경고가 아니라 에러로 취급되어 쿼리가 실패한다.

#### 값의 비교와 대체(CASE WHEN ... THEN ... END)

- 2가지 방법으로 사용할 수 있다.
- 동등 비교하는 연산
	- ![](assets/Pasted%20image%2020240827231838.png)
- 표현식으로 비교하는 방식
	- ![](assets/Pasted%20image%2020240827231912.png)
- `CASE WHEN` 구문에서 한 가지 중요한 사실은 `CASE WHEN` 절이 일치하는 경우에만 `THEN` 이하의 표현식이 실행된다는 점이다.

#### 타입의 변환(CAST, CONVERT)

- `CAST()`
	- ![](assets/Pasted%20image%2020240827232812.png)
- `CONVERT()` 함수는 타입을 변환하는 용도 뿐만아니라 문자 집합을 변환하는 용도로도 사용할 수 있다.
	- ![](assets/Pasted%20image%2020240827232851.png)

#### 이진값과 16진수 문자열(Hex String) 변환(HEX, UNHEX)

- `HEX()`: 이진값을 사람이 읽을 수 있는 형태의 16진수의 문자열로 변환하는 함수
- `UNHEX()`: 16진수 문자열을 이진값(BINARY)으로 변환하는 함수다.


#### 암호화 및 해시 함수(MD5, SHA, SHA2)

- `SHA()`: SHA-1 암호화 알고리즘을 사용하며, 결과로 160비트(20바이트) 해시 값을 반환한다.
- `SHA2()`: SHA-2 암호화 알고리즘을 사용하며, 더 강력한 224비트부터 512비트 암호화 알고리즘을 사용해 생성된 해시 값을 반환한다.
- `MD5()`: 메시지 다이제스트 알고리즘을 사용해 128비트(16바이트) 해시 값을 반환한다.
- 해시 함수들은 사용자의 비밀번호와 같은 암호화가 필요한 정보를 인코딩하는 데 사용된다.
- 위 함수들은 16진수 문자열 형태로 반환되기 때문에 저장하려면 해시 값 사이즈의 2배가 필요하다.
	- 저장 공간을 원래 사이즈로 줄이고 싶다면 `CHAR`나 `VARCHAR` 가아닌 `BINARY` 또는 `VARBINARY` 형태의 타입에 저장하면된다.
	- ![](assets/Pasted%20image%2020240827234629.png)
- 해시 결괏값은 중복 가능성이 매우 낮기 때문에 길이가 url 같이 긴 데이터의 크기를 줄여서 인덱싱하는 용도로도 사용된다.
	- MySQL 8.0 버전부터는 함수 기반의 인덱스를 생성하면 별도 컬럼을 추가하지 않고도 해시를 기준으로 인덱스를 만들 수 있다.
	- ![](assets/Pasted%20image%2020240827234830.png)
	- ![](assets/Pasted%20image%2020240827234847.png)

#### 처리 대기(SLEEP)

- 디버깅 용으로 주로 사용한다.
- 쿼리 실행 도중 멈춰서 대기하는 기능이다.
- ![](assets/Pasted%20image%2020240827235021.png)

#### 벤치마크(BENCHMARK)

- 디버깅이나 간단한 함수의 성능 테스트용으로 사용하는 함수다.
- 첫 번째 인자는 반복해서 수행할 횟수이며, 두 번째 인자로는 반복해서 실행할 표현식을 입력하면 된다.
	- 두 번째 인자의 표현식은 반드시 스칼라값을 반화하는 표현식이어야 한다.
	- ![](assets/Pasted%20image%2020240827235355.png)
- 주의할 점은 `SELECT BENCHMARK(10, expr)`와 `SELECT expr`을 10번 직접 실행하는 것과는 차이가 있다.
	- 전자는 쿼리 네트워크, 쿼리 파싱 및 최적화 비용이 한 번 밖에 소요되지 않지만, 후자는 10번 소요된다.
	- 전자는 expr 표현식이 할당받은 메모리 자원을 공유하기 때문에 메모리 할당에 소요되는 비용도 1/10밖에 일어나지 않는다.
	- 그래서 전자가 후자보다 짧은 시간에 완료된다.

#### IP 주소 변환(INET_ATON, INET_NTOA)

- IP 주소는 4바이트의 부호없는 정수이다.
- MySQL에서는 `INET_ATON()` 함수와 `INET_NTOA()` 함수를 이용해 IPv4 주소를 문자열이 아닌 부호 없는 정수 타입에 저장할 수 있게 제공한다.
	- `INET_ATON()`: 문자열로 구성된 IPv4 주소를 정수형으로 변환
	- `INET_NTOA()`: 정수형의 IPv4 주소를  사람이 읽을 수 있는 형태의 '.'으로 구분된 문자열로 변환
- ![](assets/Pasted%20image%2020240902202525.png)

#### JSON 포맷(JSON_PRETTY)

- `JSON_PRETTY()` 함수를 이용하면 JSON 컬럼의 값을 읽기 쉬운 포맷으로 변환해준다.
- ![](assets/Pasted%20image%2020240902202729.png)

#### JSON 필드 크기(JSON_STORAGE_SIZE)

- JSON 데이터는 텍스트 기반이지만 MySQL 서버는 디스크의 저장 공간을 절약하기 위해 JSON 데이터를 실제 디스크에 저장할 때 BSON(Binary JSON) 포맷을 사용한다.
- `JSON_STORAGE_SIZE()` 함수를 이용해서 실제로 저장 곤간의 크기를 확인할 수 있다.
- ![](assets/Pasted%20image%2020240902202853.png)

#### JSON 필드 추출(JSON_EXTRACT)

- JSON 도큐먼트에서 특정 필드의 값을 가져오는 가장 일반적인 방법은 `JSON_EXTRACT()` 함수를 사용하는 것이다.
	- ![](assets/Pasted%20image%2020240902203035.png)
- `JSON_EXTRACT()` 함수의 결과는 따옴표가 붙은 상태인데, `JSON_UNQUOTE()` 함수를 사용하면 따옴표 없이 값만 가져올 수 있다.
	- ![](assets/Pasted%20image%2020240902203118.png)
- 사용자 편의성을 위해 MySQL 서버는 다음과 같이 JSON 연산자를 제공한다.
	- `->` 연산자는 `JSON_EXTRACT()` 함수와 동일
	- `->>` 연산자는 `JSON_UNQUOTE()` 홤수와 `JSON_EXTRACT()` 함수를 조합한 것과 동일한 기능이다.
	- ![](assets/Pasted%20image%2020240902203229.png)
	- ![](assets/Pasted%20image%2020240902203237.png)

#### JSON 오브젝트 포함 여부 확인(JSON_CONTAINS)

- JSON 도큐먼트 또는 지정된 JSON 경로에 JSON 필드를 가지고 있는지 확인하는 함수다.
- ![](assets/Pasted%20image%2020240902203501.png)

#### JSON 오브젝트 생성(JSON_OBJECT)

- RDBMS 컬럼의 값을 이용해 JSON 오브젝트를 생성하는 함수다.
- ![](assets/Pasted%20image%2020240902203547.png)

#### JSON 컬럼으로 집계(JSON_OBJECTAGG & JSON_ARRAYAGG)

- `JSON_OBJECTAGG()`와 `JSON_ARRAYAGG()` 함수는 `GROUP BY` 절과 함께 사용되는 집계 함수로서, RDMBS 컬럼의 값들을 모아 JSON 배열 또는 도큐먼트를 생성하는 함수다.
- `JSON_OBJECTAGG()`의 첫번째 인자는 키, 두번째 인자는 값에 해당한다.
	- ![](assets/Pasted%20image%2020240902204203.png)
- `JSON_ARRAYAGG()`의 하나의 인자로 배열을 만든다.
	- ![](assets/Pasted%20image%2020240902204256.png)

#### JSON 데이터를 테이블로 변환(JSON_TABLE)

- JSON 데이터의 값들을 모아서 RDBMS 테이블을 만들어 반환한다.
- `JSON_TABLE()` 함수는 항상 내부 임시 테이블을 이용하기 때문에 임시 테이블에 레코드가 많이 저장되지 않게 주의해야된다.
- ![](assets/Pasted%20image%2020240902204527.png)

## SELECT

- 웹 서비스 같이 일반적인 온라인 트랜잭션 처리 환경의 데이터베이스의 SELECT는 여러 개의 테이블로부터 데이터를 조합해서 빠르게 가져와야 하기 때문에 여러 개의 테이블을 어떻게 읽을 것인가에 많은 주의를 기울여야 한다.

### SELECT 절의 처리 순서

- SELECT 문장의 처리 순서
	- CTE와 윈도우 함수를 사용할 때를 제외하고는 아래 순서가 바뀌는 경우가 거의 없다.
	- ORDER BY나 GROUP BY 절이 있더라도 인덱스를 이용해 처리할 때는 그 단계 자체를 생략한다.
	- ![](assets/Pasted%20image%2020240902205307.png)
- 예외적으로 GROUP BY 절이 없이 ORDER BY만 사용된 쿼리에서는 아래와 같은 순서로 사용될 수도 있다.
	- 첫 번째 테이블만 읽어서 정렬을 수행한 뒤에 나머지 테이블을 읽는 것이다.
	- ![](assets/Pasted%20image%2020240902205424.png)
- 위에서 소개한 실행 순서를 벗어난 쿼리가 필요하다면 서브쿼리로 작성된 인라인 뷰를 사용해야된다.
	- 인라인 뷰가 사용되면 임시 테이블이 사용되기 때문에 주의해야한다.
	- ![](assets/Pasted%20image%2020240902205521.png)

### WHERE 절과 GROUP BY 절, ORDER BY 절의 인덱스 사용

#### 인덱스를 사용하기 위한 기본 규칙

- 기본적으로 인덱스된 컬럼의 값 자체를 변환하지 않고 그대로 사용한다는 조건을 만족해야 한다.
	- 인덱스는 컬럼의 값을 아무런 변환 없이 B-Tree에 정렬해서 저장하기 때문이다.
	- 비교 조건에서 연산자 양쪽의 두 비교 대상 값은 데이터 타입이 일치해야 한다.
- 복잡한 연산을 수행한다거나 `MD5()` 함수와 같이 해시 값을 만들어서 비교해야 하는 경우라면 미리 계산된 값을 저장하도록 MySQL의 가상 컬럼을 추가하고 그 컬럼에 인덱스를 생성하거나 함수 기반의 인덱스를 사용하면 된다.

#### WHERE 절의 인덱스 사용
\
- WHERE 조건이 인덱스를 사용하는 방법은 크게 작업 범위 결정 조건과 체크 조건 두 가지 방식으로 구분할 수 있다.
	- 작업 범위 결정 조건: WHERE 절에서 동등 비교 조건이나 IN으로 구성된 조건에 사용된 컬럼들이 인덱스의 컬럼 구성과 좌측에서부터 비교했을 때 얼마나 일치하는가에 따라 달라진다.
	- 체크 조건: 인덱스의 컬럼이 작업 범위 결정 조건으로 사용되지 못하는 경우를 말한다.
- ![](assets/Pasted%20image%2020240902211054.png)

#### GROUP BY 절의 인덱스 사용

- GROUP BY가 인덱스를 사용할 수 있는 조건
	- GROUP BY 절에 명시된 컬럼이 인덱스 컬럼의 순서와 위치가 같아야 한다.
	- 인덱스를 구성하는 컬럼 중에서 뒤쪽에 있는 컬럼은 GROUP BY 절에 명시되지 않아도 인덱스를 사용할 수 있지만, 인덱스의 앞쪽에 있는 컬럼이 GROUP BY 절에 명시되지 않으면 인덱스를 사용할 수 없다.
	- WHERE 조건절과 달리 GROUP BY 절에 명시된 컬럼이 하나라도 인덱스에 없으면 GROUP BY 절은 전혀 인덱스를 이용하지 못한다.
- (COL_1, COL_2, COL_3, COL_4) 로 만들어진 인덱스가 있을 때
	- 아래는 인덱스를 사용하지 못한다.
		- ![](assets/Pasted%20image%2020240902211612.png)
	- 아래는 인덱스를 사용할 수 있다.
		- ![](assets/Pasted%20image%2020240902211628.png)
	- WHERE 절과 GROUP BY 절이 혼용된 쿼리의 경우는 WHERE 조건절에 동등 비교 조건으로 사용된 컬럼을 GROUP BY 절로 옮겨보면 된다.
		- ![](assets/Pasted%20image%2020240902211709.png)
