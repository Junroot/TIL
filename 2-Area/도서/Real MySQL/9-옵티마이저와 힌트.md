# 옵티마이저와 힌트

- 옵티마이저의 기능: 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하며, 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립한다.
- `EXPLAIN` 명령으로 쿼리의 실행 계획을 확인할 수 있다.

## 개요

### 쿼리 실행 절차

1. SQL 파싱: 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
	- SQL 파서라는 모듈에서 처리한다.
2. 최적화 및 실행 계획 수립: SQL의 파싱 트리를 확인하면서 어떤 테이블부터 읽거 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
	- MySQL 서버의 옵티마이저에서 처리한다.
	- 불필요한 조건 제거 및 복잡한 연산의 단순화
	- 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
	- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
	- 가져온 테이블을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

### 옵티마이저의 종류

- 규칙 기반 최적화 (Rule-based optimizer, RBO)
	- 대상 테이블의 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립한다.
	- 같은 쿼리에 대해서 거의 항상 같은 실행 방법을 만든다.
	- 사용자의 데이터는 분포도가 매우 다양하기 때문에 규칙 기반의 최적화는 이미 오래전부터 많은 DBMS에서 사용하지 않는다.
- 비용 기반 최적화 (Cost-based optimizer, CBO)
	- 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, ㅁ각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다.

## 기본 데이터 처리

### 풀 테이블 스캔과 풀 인덱스 스캔

- InnoDB는 풀 테이블 스캔이나 풀 인덱스 스캔을 실행할 때 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있다.
- 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(Read ahead) 작업이 자동으로 시작한다.
	- 리드 어헤드: 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것
- 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다.
	- 백그라운드 스레드가 읽기를 넘겨받은 시점부터는 한 번에 4개 또는 8개씩 페이지를 읽으면서 계속 그 수를 증가시킨다.
	- 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히빨리 처리되는 것이다.
- 백그라운드 스레드로 넘어가는 시점은 `innodb_read_ahead_threshold` 시스템 변수에 설정된 개수만큼 연속된 데이터가 읽히는 시점이다.

### 병렬 처리

- MySQL 8.0 버전부터는 한정적으로 하나의 쿼리를 여러 스레드가 작업을 나누어 동시 처리할 수 있다.
- `innodb_parallel_read_threads`라는 시스템 변수를 이용하면, 아무런 `WHERE` 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있다.

![](assets/Pasted%20image%2020240724001324.png)

### ORDER BY 처리(Using filesort)

- 정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 "Filesort"라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.
	- 인덱스 이용
		- 장점: 이미 인덱스가 정렬돼 있어서 순서대로 읽기만하면 되므로 매우 빠르다.
		- 단점: `INSERT`, `UPDATE`, `DELETE` 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. 인덱스 때문에 디스크 공간이 더 많이 필요하다. 인덱스의 개수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요하다.
	- Filesort 이용
		- 장점: 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때 단점이 장점으로 바뀐다. 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 되므로 충분히 빠르다.
		- 단점: 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 응답 속도가 느리다.
- MySQL 서버에서 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 `Extra` 컬럼에 "Using filesort" 메시지가 표시되는지 여부로 판단할 수 있다.
- 소트 버퍼: MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 소트 버퍼라고 한다.
	- 소트 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가하지만 최대 사용 가능한 소트 버퍼의 공간은 `sort_buffer_size`라는 시스템 변수로 설정할 수 있다.
	- 정렬해야 할 레코드의 건수가 소트 버퍼의 최대 용량보다 커지면, 정렬해야할 레코드를 여러 조각으로 나눠서 처리하고 이 과정에서 임시 저장을 위해 디스크를 사용한다.
		- 메모리의 소트 버퍼에서 정렬을 수행하고 그 결과를 임시로 디스크에 기록해두고, 그 다음 레코드를 가져와 다시 정렬해서 반복적으로 수행한다.
		- 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행한다.
	- `sort_buffer_size`가 클수록 처리가 빨라질 것으로 예상하지만, 너무 클 경우 큰 메모리 공간 할당 때문에 성능이 훨씬 떨어질 수도 있다.
	- ![](assets/Pasted%20image%2020240724002905.png)
- 정렬 알고리즘
	- 공식 명칭은 아니지만 "싱글 패스(single-pass)"와 "투 패스(two-pass)" 2가지 정렬 모드로 나눌 수 있다.
		- 싱글 패스: 정렬할 때 레코드 전체를 소트 버퍼에 담음
		- 투 패스: 정렬할 때 정렬 기준 컬럼만 소트 버퍼에 담음
	- 싱글 패스 방식은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보이며, 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적이다.
	- 최신 버전에서는 일반적으로 싱글 패스 정렬을 주로 사용하지만, 다음의 경우에는 투 패스 정렬 방식을 사용한다.
		- 레코드의 크기가 `max_length_for_sort_data` 시스템 변수에 설정된 값보다 클 때
		- BLOB이나 TEXT 타입의 컬럼이 SELECT 대상에 포함할 때
	- `SELECT` 쿼리에서 꼭 필요한 컬럼만 조회하고, 모든 컬럼(`*`)을 가져오지 않도록 개발하라고 권장하는 이유 중 하나가 이런 정렬 알고리즘의 선택 때문이다.
	- 현재 어떤 정렬 모드를 사용하는지는 다음과 같이 옵티마이저 트레이스 기능으로 확인할 수 있다.
	- 아래 출력된 내용에서 "filesort-summary" 섹션의 "sort_algorithm" 필드에 정렬 알고리즘이 표시된다.
		- `<sort_key, rowid>`: 정렬 키와 레코드의 로우 아이디만 가져와서 정렬하는 방식(투 패스)
		- `<sort_key, additional_fields>`: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 컬럼들을 고정 사이즈로 메모리 저장(원 패스)
		- `<sort_key, packed_additional_fields>`: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 컬럼들은 가변 사이즈로 메모리 저장(원 패스)
	- 아래 출력된 내용에서 "sort_algorithm" 필드에 보여진 "std:stable_sort"는 MySQL 서버에서 실제 정렬을 수행할 때 사용한 라이브러리의 함수 이름을 보여준다. (C++의 STL에서 제공된 `stable_sort()` 함수를 사용함)
		- 운영체제별로 STL의 `stable_sort()` 함수가 어떤 정렬 알고리즘을 사용하는지는 조금씩 차이가 있다. 리눅스 서버에서 사용하는 GNU C++의 STL에서는 퀵 소트와 힙 소트 알고리즘을 복합적으로 사용한다.
	- ![](assets/Pasted%20image%2020240724003913.png)
	- ![](assets/Pasted%20image%2020240724003924.png)
