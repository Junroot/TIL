# 데이터

- 이 장에서는 간접 쿼리 최적화를 다룬다.

## 세 가지 비밀

### 인덱스가 도움이 되지 않을 수 있다

- 인덱스는 성능에서 핵심이지만 좋은 인덱스라도 쿼리가 느릴 수 있다.
- 인덱스 없이는 성능을 달성할 수 없지만 무한한 데이터 크기에 대해 무한한 영향력을 제공한다는 의미는 아니다.
- 인덱스 스캔의 경우 
	- 테이블의 행 수가 증가할수록 인덱스 스캔을 사용하는 쿼리에 대한 응답 시간도 늘어나므로 반드시 지연 시간이 발생한다.
	- 더 이상 최적화할 수 없으면 간접 쿼리 최적화를 한다.
- 행 찾기의 경우
	- 아래 나열된 것 처럼 한 행만 일치하는 인덱스 조회 접근 유형이 아니라면, rows 필드에 주의를 기울여야 한다.
		- system
		- const
		- eq_ref
		- unique_subquery
	- 선택도가 낮은 인덱스는 인덱스 조회를 느리게하는 공범일 가능성이 높다.
- 테이블 조인의 경우
	- 테이블 조인할 때는 한 행만 일치하는 인덱스 조회 접근 유형 중 하나를 사용하여 하나의 행만 일치 시키는 것이 좋다.
	- 다른 테이블에서 더 나은 인덱스를 생성하여 MySQL이 조인 순서를 변경할 수 있도록 하는 방법도 있다.
- 작업 세트 크기
	- 작업 세트: 자주 사용하는 인덱스값과 참조하는 프라이머리 키 행
	- 일반적으로 작업 세트는 테이블 크기에서 작은 비율을 차지한다.
	- 인덱스를 구성하는 B-트리 노드는 16KB 페이지에 저장되고, MySQL은 필요에 따라 메모리와 디스크 간에 페이지를 교환한다.
	- 작업 세트의 크기가 사용할 수 있는 메모리보다 커지면, 인덱스가 메모리를 놓고 경쟁하게되어 인덱스가 도움이 되지 않을 수 있다.
	- 작업 세트 크기가 적절한 크기의 메모리에 맞지 않을 정도로 많은 데이터를 저장하고 접근해야 할 때 해결책은 샤딩이다. (이후 5장에서 다룬다.)

### 데이터가 적을 수록 좋다

- 데이터 크기가 클수록 성능 최적화가 더 어렵고 관리가 위험해 진다.
- 데이터 크기 때문에 문제가 발생하기 전에 제한 없이 증가하는 데이터가 있다면 문제를 제기해야 한다.

### QPS가 낮을수록 좋다

- QPS는 일반적으로 쿼리나 성능에 대해 질적인 정보를 제공하지 않는다. 숫자에 불과하다.
	- 똑같은 QPS에서도 수많은 질적 차이가 발생한다.
- QPS는 좋거나 나쁘지도 않고, 높거나 낮지도 않으며, 전형적이거나 비전형적이지도 않다.
	- QPS값은 애플리케이션과 관련해서만 의미가 있다.
	- 한 애플리케이션의 평균이 2000QPS라면 100QPS는 중단을 나타내는 급격한 하락일 수 있다.
- 데이터 크기는 1GB에서 100GB로 비교적 쉽게 증가할 수 있다. 그러나 QPS는 100 높이기는 매우 어렵다.
- 위 3가지를 요약하면 QPS는 도움이 되지 않는다. 자산이라기보다는 부채에 가깝다.
	- 숙련된 엔지니어는 QPS가 낮을수록 성장 잠재력이 있기 때문에 QPS가 의도적으로 감소하는 것을 반가워한다.

## 최소 데이터 원칙

- 필요 데이터만 저장 및 접근한다.

### 데이터 접근

- 데이터 접근 효율성을 확인하기 위한 점검 목록
	- 필요한 열만 반환
	- 쿼리 복잡성 감소
	- 행 접근 제한
	- 결과 세트 제한
	- 행 정렬 피하기
- 위 목록을 모두 만족해야되다는 의미는 아니다. 예를 들어 '행 정렬 피하기'는 성능에 영향을 미치지 않기에 무시된다.
- 필요한 열만 반환
	- `SELECT *` 쿼리를 실행하지 않는다.
	- 테이블에 `BLOB`, `TEXT`, `JSON` 열이 있을 때 특히 중요하다.
- 쿼리 복잡성 감소
	- 쿼리 복잡도는 쿼리를 구성하는 모든 테이블, 조건, SQL 절을 나타낸다.
	- 쿼리가 복잡할수록 분석하고 최적화하기가 더 어렵다.
	- 단순 쿼리는 테이블, 조건, SQL 절이 몇 개 없어서 MySQL에 대한 작업이 더 단순해지기 때문에 더 작은 데이터에 접근하는 경향이 있다.
- 행 접근 제한
	- 접근하는 행의 범위와 목록을 제한하지 않으면, 데이터가 커지면서 느린 쿼리가 될 수 있다.
	- `LIMIT` 절은 행을 일치시킨 후 결과 세트에 `LIMIT`가 적용되므로 행 접근을 제한하지 않는다.
	- 하지만 `ORDER BY ... LIMIT` 최적화는 예외이다.
		- MySQL이 인덱스 순서대로 행에 접근할 수 있을 때, 일치하는 행을 찾다가 `LIMIT` 수만큼 발견되면 행 읽기를 중지한다.
		- 하지만 `EXPLAIN`에는 이 최적화가 사용될 때 보고되지 않는다.
		- `EXPLAIN SELECT * FROM elem WHERE a > 'Ag' ORDER BY a LIMIT 2`
			- 아래 사진처럼 EXPLAIN에는 보고되지 않는다.
			- ![](assets/Pasted%20image%2020240522025427.png)
			- 하지만 슬로 쿼리 로그에 있는 쿼리 메트릭에는 `Rows_examined: 2`로 접근한 행의 수가 2인 것을 확인할 수 있다.
			- ![](assets/Pasted%20image%2020240522025617.png)
	- 쓰기는 일반적으로 InnoDB가 일치하는 행을 갱신하기 전에 접근하는 모든 행을 잠그므로 행 접근을 제한하는 것이 중요하다
	- 테이블을 조인할 때도 행 접근을 제한하는 것이 중요하다.
- 결과 세트 제한
	- 쿼리는 될 수 있는 한 적은 수의 행을 반환해야된다.
	- result set 전체를 사용하지 않는 경우
		- 의도로 또는 의도하지 않게 `WHERE` 절에 충분한 조건으로 필터링하지 않는 경우
			- 의도적으로 쿼리의 복잡도를 낮추거나 응답 시간을 단축시키기 위해서 그런 경우는 허용 한다.
		- 쿼리에 `ORDER BY` 절이 있고 애플리케이션이 정렬된 행의 일부분만 사용할 때
			- `ORDER BY ... LIMIT` 최적화를 사용할 수 있을 때만 `LIMIT`으로 가져오는 것을 줄인다.
		- 애플리케이션이 result set을 집계 용도로만 사용하는 경우
			- 통계 함수를 통해서 MySQL이 행을 반환하는 대신 MySQL이 계산을 수행하도록 한다.
			- 열값 더하기: `SUM(column)`
			- 행의 개수 세기: `COUNT(*)`
			- 값의 개수 세기: `COUNT(column) ... GRUOP BY column`
			- 고윳값의 개수 세기: `COUNT(DISTINCT column)`
			- 고유값 추출하기: `DISTINCT`
		- `COUNT(*)` vs `COUNT(column)`
			- `COUNT(*)`는 일치하는 행의 수를 계산한다.
			- `COUNT(column)`은 일치하는 행의 열에서 NULL이 아닌 값의 수를 계산한다.
- 행 정렬 피하기
	- 쿼리는 행 정렬을 피해야한다.
	- MySQL 대신 애플리케이션에서 행을 정렬하면 `ORDER BY`절을 제거하여 쿼리 복잡성을 줄이고 애플리케이션 인스턴스에 작업을 분산시켜 더 좋은 확장성을 가질 수 있다.
	- `LIMIT` 절이 없는 `ORDER BY` 절은 삭제하여 애플리케이셔넹서 행을 정렬하도록 한다.

### 데이터 스토리지

- 필요 이상으로 많은 데이터를 저장하지 않아야 한다.
- 효율적으로 데이터 를 저장하는지 확인하는 점검표
	- 필요한 행만 저장됨
	- 모든 열이 사용됨
	- 모든 열이 간결하고 실용적임
	- 모든 값이 간결하고 실용적임
	- 모든 세컨더리 인덱스가 사용되며 중복되지 않음
	- 필요한 행만 유지됨
- 필요한 행만 저장됨
	- 애플리케이션이 커지면서 애플리케이션이 저장하고 있는 내용을 추적하지 못 할 수 있다.
	- 애플리케이션이 저장하고 있는 데이터를 살펴봐야한다.
- 모든 열이 사용됨
	- ORM 등을 사용하면서 사용하지 않는 열을 추적하지 못할 수 있다.
	- 수동으로 검토해서 사용하지 않는 열이 있는지 비교해본다.
- 모든 열이 간결하고 실용적임
	- 간결함: 가장 작은 데이터 타입을 사용하여 값을 저장한다.
	- 실용적: 너무 작아서 사용자나 애플리케이션에 번거롭거나 오류가 발생하기 쉬운 데이터를 사용하지 않는 것
		- 비트 필드를 부호 없는 `INT`로 저장하는 것은 간결하지만 실용적이지 않다.
	- `VARCHAR(255)`는 대표적인 안티 패턴
		- 데이터 타입과 크기는 일반적이지만 잘못된 값이 쉽게 들어갈 수 있다.
	- `BLOB`, `TEXT`, `JSON` 데이터 타입은 매우 보수적으로 사용해야 된다.
		- 불필요한 공간이나 쓸데없는 데이터, 일반 버킷 용도로 사용하지 말아야한다.
		- 예를 들어, 이미지를 `BLOB`에 저장할 수 있지만 Amazon S3와 같은 훨씬 더 나은 해결책이 있다.
