# 인덱스와 인덱싱

## 성능 향상과 관련 없는 딴짓

- 레드헤링(Red Herring): 목표로부터 주의를 딴 데로 돌리는 상황
- MySQL 성능을 향상하기 위한 방법을 찾을 때 일반적으로 두 가지 레드헤링이 있다.
	- 하드웨어를 구매하는 것
	- MySQL 튜닝

### 더 좋고 빠른 하드웨어!

- MySQL 성능이 만족스럽지 않을 때 성능 향상에 도움이 되는지 확인하기 위해 스케일업부터 시작하지 말라.
- 이 경우가 합리적인 2가지 상황
	- 하드웨어 성능 부족으로 명백하게 느린 경우
		- 예) 500GB의 데이터에 1GB의 메모리를 사용하는 경우
	- 애플리케이션의 사용량이 급증하고 있으며, 하드웨어 스케일업이 애플리케이션 실행에 있어 안정성을 담보하기 위한 임시 방편인 경우
- 단순 스케일업은 아무것도 배우지 못하며, 고사양의 하드웨어 구매로 문제를 대강 뭉개는 데 익숙해질 것이다.
- 하드웨어 확장은 지속 가능한 접근 방법이 아니다.
	- 물리적인 하드웨어 업그레이드는 간단하지 않다.
	- 스케일업에 따라 더 커다란 비용을 지불해야 한다.

### MySQL 튜닝

- 튜닝: 연구개발을 목적으로 MySQL 시스템 변수를 조정하는 행위로 구체적인 목표와 기준이 있는 실험실 수준의 작업
- 구성: 시스템 변수를 하드웨어와 환경에 적합한 값으로 설정하는 행위로 목표는 변경해야 하는 몇 가지 기본값을 가장 적합한 값으로 구성하는 것
	- 단위가 달라질 정도로 데이터 규모가 대량으로 증가했을 때 재구성이 필요하다.
- 최적화: 워크로드를 줄이거나 효율성을 높여 MySQL 성능을 향상시키는 행위
- 튜닝이 헤드헤링인 이유
	- MySQL 성능은 복잡하므로 튜닝 결과가 의심될 수 있다.
	- MySQL은 이미 고도로 최적화 되었으므로 튜닝의 결과는 기대보다 성능에 큰 영향을 미치지 않는다.
- 재구성이 무의미한 이유
	- MySQL 8.0에서는 `innodb_dedicated_server` 매개변수를 활성화하여 자동으로 서버를 구성한다. 직접 재구성이 무의미하다.

## MySQL 인덱스: 시각적 소개

- 아래 내용은 InnoDB 테이블의 표준 인덱스(`PRIMARY KEY`, `[UNIQUE] INDEX`)에만 적용된다.
- 아래 내용에서 사용할 테이블
	- 프라이머리 키를 가진 `id` 열
	- `a`, `b` 열로 구성된 비고유 세컨더리 인덱스

```sql
CREATE TABLE `elem`(
	`id` int unsigned NOT NULL,
	`a` char(2) NOT NULL,
	`b` char(2) NOT NULL,
	`c` char(2) NOT NULL,
	PRIMARY KEY (`id`),
	KEY `idx_a_b` (`a`, `b`)
) ENGINE=InnoDB;
```

![](assets/Pasted%20image%2020240429203522.png)

### InnoDB 테이블은 인덱스다

- ![](assets/Pasted%20image%2020240429205009.png)
- 위 테이블의 프라이머리 키로 구성된 B-트리 인덱스는 아래와 같다.
	- 테이블의 행은 인덱스 구조에서 리프 노드에 저장된 인덱스 레코드가 된다.
	- 각 인덱스 레코드에는 로우 락, 트랜잭션 격리 등에서 사용되는 메타데이터(`...`로 표시됨)가 포함되어 있다.
	- 프라이머리 키 조회는 매우 빠르고 효율적이다.
	- 프라이머리 키는 MySQL 성능에 핵심적인 역할을 한다.
	- MySQL의 세계에서 모든 것은 프라이머리 키를 중심으로 돌아간다.
	- ![](assets/Pasted%20image%2020240429205044.png)
- 위 테이블의 세컨더리 인덱스는 아래와 같다.
	- 세컨더리 인덱스도 B-트리 인덱스지만 리프 노드는 프라이머리 키값을 저장한다.
	- ![](assets/Pasted%20image%2020240429205823.png)
- 아래 그림은 `SELECT * FROM elem WHERE a='Au' AND b='Be'` 쿼리에 대한 세컨더리 인덱스 조회 상황이다. 
	- ![](assets/Pasted%20image%2020240429210047.png)

### 테이블 접근 방법

- 세 가지 테이블 접근 방법
	- 인덱스 조회
	- 인덱스 스캔
	- 테이블 스캔
- 성능을 발휘하기 위해서는 인덱스 스캔과 테이블 스캔은 피해야 한다.
- 인덱스 조회
	- 인덱스의 정렬된 구조와 접근 알고리즘을 활용하여 특정 행이나 행 범위를 찾는다.
	- 대량의 데이터를 대상으로 한 빠르고 효율적인 접근
- 인덱스 스캔
	- 인덱스 조회가 불가능할 때 MySQL은 전체 데이터 순차 찾기 같은 억지 기법으로 행을 찾아야 한다. 즉, 행을 읽고 일치하는 않는 행을 필터링한다.
	- 유일한 대안이 풀 데이블 스캔이 아닌 이상 인덱스 스캔으로 최적화 하면 안된다.
	- 인덱스 스캔의 2가지 유형
		- 풀 인덱스 스캔
		- 인덱스 전용 스캔
	- 풀 인덱스 스캔
		- 인덱스 순서대로 모든 행을 읽는다.
		- 모든 행을 읽는 것은 일반적으로 성능에 매우 불리하지만 인덱스 순서가 `ORDER BY` 쿼리와 일치할 때 행 정렬을 피할 수 있다.
		- 아래는 `SELECT * FROM elem FORCE INDEX (a) ORDER BY a, b` 쿼리에 대한 상황이다.
			- `FORCE INDEX` 하는 이유: 테이블 크기가 작아서 테이블 풀 스캔이 될 수 있기 때문에 
			- ![](assets/Pasted%20image%2020240429212716.png)
	- 인덱스 전용 스캔(index-only scan)
		- 인덱스에서 열 값을 읽는다.
		- 이를 위해서는 커버링 인덱스가 필요하다.
		- 전체 행을 읽기 위해서 프라이머리 키 조회를 해야 하는 상황이 아니므로 풀 인덱스 스캔보다 빠르다.
- 풀 테이블 스캔
	- 프라이머리 키 순서로 모든 행을 읽는다.
	- 테이블 전체를 스캔하기 때문에 피하는게 최선이다.
	- 테이블 스캔이 허용하거나 괜찮은 경우
		- 테이블이 작고 접근 빈도가 낮을 때
		- 테이블 선택도가 매우 낮을 때(2.4 절에서 설명)
	- ![](assets/Pasted%20image%2020240429220545.png)

### 맨 왼쪽 접두사(leftmost prefix) 요구사항

- 기본적인 인덱스 구조는 인덱스 열 순서에 따라 정렬되므로, 인덱스를 사용하려면 맨 왼쪽 인덱스 열로 시작하는 열을 순서대로 사용해야 한다.
- 인덱스 `(a, b)`와 `(b, a)`는 서로 다르다.
- `(a)`와 `(a, b)` 대신 `(a, b, c)`를 사용할 가능성이 크다.
- 모든 세컨더리 인덱스의 끝에는 프라이머리 키가 숨겨져 있다.
	- `(a, b)` 세컨더리 인덱스는 사실상 `(a, b, id)`

### EXPLAIN: 쿼리 실행 계획

- `EXPLAIN` 명령은 쿼리 실행 계획을 보여준다.
- ![](assets/Pasted%20image%2020240429223011.png)
- ![](assets/Pasted%20image%2020240429223023.png)
- ![](assets/Pasted%20image%2020240429223033.png)
- `table`: 테이블이나 참조된 서브 쿼리. 쿼리에 보여지는 순서가 아니라 MySQL이 결정한 조인 순서로 나열된다.
- `type`: 테이블 접근 방법이나 인덱스 조회의 접근 유형
	- `ALL`: 테이블 풀 스캔
	- `index`: 인덱스 스캔
	- `const`, `ref`, `range` 등의 다른 값: 인덱스 조회의 접근 유형
- `possible_keys`: 맨 왼쪽 접두사 요구사항에 충족되어 MySQL이 사용할 수 있는 인덱스
- `key`: MySQL이 사용할 인덱스의 이름이거나 인덱스를 사용할 수 없을 때에는 `NULL`이다.
- `ref`: 행을 조회하는 데 사용되는 값의 소스를 나열한다.
	- 단일 테이블 쿼리나 조인의 첫 번째 테이블에서는 상수 조건을 나타내는 `const`
		- 예시: `a='Au'`
	- 여러 테이블을 조인하는 쿼리에서 조인 순서상 이전 테이블의 열 참조
- `rows`: MySQL이 일치하는 행을 찾기 위해 조회할 예상하는 행의 수
	- 추정치고 실제 조회하는 행과 같지는 않다.
- `Extras`: 쿼리 실행 계획에 대한 부가 정보를 제공한다.
	- MySQL이 적용할 수 있는 쿼리 최적화를 나타내므로 중요하다.

### WHERE

- `EXPLAIN SELECT * FROM elem WHERE 1d = 1`
	- `key: PRIMARY` 인덱스 조회로 프라이머리 키를 사용함
	- `type: const` 프라이머리 키 조회로 조회
		- 매우 빠른 접근 유형이다.
	- `ref: const` 프라이머리 키나 유니크 세컨더리 인덱스의 모든 인덱스 열에 상수 조건이 있을 때만 발생한다.
		- const 접근 유형의 결과는 상수 행이다.
		- 상수 행: 오직 하나만 일치하거나 또는 없는 행
	- `EXTRA: NULL` MySQL이 행과 일치시켜볼 필요가 없음을 의미한다.
		- 프라이머리 키로 조회한 행은 상수 행이다.
	- ![](assets/Pasted%20image%2020240502003032.png)
- `EXPLAIN SELECT * FROM eme WHERE id > 3 AND id < 6 AND c = 'Cd'`
	- `type: range` 범위 스캔
	- `ref: NULL` id 열의 조건이 상수가 아니므로
	- `rows: 2` 2개 행을 조회할 것으로 추정한다.
	- `Extra: Using where`: MySQL이 WHERE 조건을 사용하여 일치하는 행을 찾는다는 의미다.
	- ![](assets/Pasted%20image%2020240502004417.png)
- `EXPLAIN SELECT * FROM elem WHERE a = 'Au'`
	- 인덱스 a만 사용한다.
	- `type: ref` 인덱스의 맨 왼쪽 접두사에 대한 동등 조회를 나타내는 접근 유형
		- ref 접근은 조회할 예상 행의 수가 적절하다면 매우 빠르다.
		- 인덱스가 비고유라 조회가 하나 이상의 행과 일치할 수 있기 때문에 const 접근 유형은 불가능하다.
	- `Extra: NULL` 인덱스만 사용하여 일치하는 행을 찾을 수 있다.
	- ![](assets/Pasted%20image%2020240502005256.png)
- `EXPLAIN SELECT * FROM elem WEHRE a = 'Au' AND b = 'Be'`
	- a, b 열의 두 인덱스 부분을 사용한다.
	- ![](assets/Pasted%20image%2020240502010140.png)
- `EXPLAIN SELECT * FROM elem WHERE a = 'Al' AND c = 'Co'`
	- a 열의 인덱스 부분을 사용한다.
	- `Extra: Using where` c 열의 조건과 일치하는 행을 찾는다.
	- ![](assets/Pasted%20image%2020240502010358.png)
	- ![](assets/Pasted%20image%2020240502010407.png)
- `EXPLAIN SELECT * FROM elem WHERE b= 'Be'`
	- `type: ALL` 인덱스를 사용할 수 없어 풀 테이블 스캔을 수행해야 한다.
		- `possible_keys: NULL`
		- `key: NULL`
		- `rows: 10`
	- ![](assets/Pasted%20image%2020240502010622.png)

### GROUP BY

- MySQL은 값이 인덱스 순서에 따라 암문적으로 그룹화되므로 `GROUP BY`를 최적화하기 위해 인덱스를 사용할 수 있다.
- `EXPLAIN SELECT a, COUNT(1) FROM elem GROUP BY a`
	- 인덱스가 정렬되어 있으므로 a 열을 읽다가 값이 바뀌면 새로운 그룹인 것으로 처리한다.
	- `Extra: Using index` MySQL이 인덱스에서 오직 a 열의 값만 읽고 프라이머리 키에서 전체 행을 읽지 않음을 나타낸다. (커버링 인덱스)
	- `type: index` 인덱스 스캔
	- ![](assets/Pasted%20image%2020240502013418.png)
- `EXPLAIN SELECT a, COUNT(a) FROM elem WHERE a != 'Ar' GROUP BY a`
	- `Extra: Using where`:  `WHERE a != 'Ar'`을 나타낸다.
	- `type: range` 인덱스 조회 중 범위 조회.  `a != Ar`은 `a < 'Ar' OR a > 'Ar'`와 같기 때문이다.
	- ![](assets/Pasted%20image%2020240502013840.png)
- `EXPLAIN SELECT a, b FROM elem WHERE b = 'B' GROUP BY a`
	- WHERE 절의 b 열에 대한 조건은 다른 SQL 절에 있더라도 맨 왼쪽 접수다에 대한 요구 사항을 충족하므로 인덱스를 여전히 사용할 수 있다.
	- `Extra: Using index for group-by` WHERE 절의 b 열에 대한 동일 조건과 SELECT 절에서 a와 b 열 선택이라는 세부 정보 때문에 특별한 최적화가 활성화된다.
	- ![](assets/Pasted%20image%2020240502014314.png)
	- ![](assets/Pasted%20image%2020240502014321.png)
- `EXPLAIN SELECT b, COUNT(*) FROM elem GROUP BY b`
	- 특이사항: a 열에 조건이 없음에도 인덱스를 사용한다.
		- 인덱스 스캔(`type: index`)을 하면서 `a = a`와 같이 항상 참인 a열 조건이 있다고 볼 수 있다.
		- `GROUP BY C`인 경우에는 a열에 대해서 계속 인덱스 스캔을 하지 않고 풀 테이블 스캔을 한다.
	- `Extra: Using Temporary` 맨 왼쪽 접두사 조건이라는 엄격한 세트를 가지지 않은 것에 대한 부작용이다.
		- MySQL은 인덱스에서 a 열값을 읽을 때 임시 테이블(메모리)에서 b 열값을 수집한다.
		- a 열의 모든 값을 읽은 후 `COUNT(*)`에 의해 그룹화되고 집계된 임시 테이블에 대해 테이블 스캔한다.
	- ![](assets/Pasted%20image%2020240502015049.png)
	- ![](assets/Pasted%20image%2020240502015058.png)