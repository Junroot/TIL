# 인덱스와 인덱싱

## 성능 향상과 관련 없는 딴짓

- 레드헤링(Red Herring): 목표로부터 주의를 딴 데로 돌리는 상황
- MySQL 성능을 향상하기 위한 방법을 찾을 때 일반적으로 두 가지 레드헤링이 있다.
	- 하드웨어를 구매하는 것
	- MySQL 튜닝

### 더 좋고 빠른 하드웨어!

- MySQL 성능이 만족스럽지 않을 때 성능 향상에 도움이 되는지 확인하기 위해 스케일업부터 시작하지 말라.
- 이 경우가 합리적인 2가지 상황
	- 하드웨어 성능 부족으로 명백하게 느린 경우
		- 예) 500GB의 데이터에 1GB의 메모리를 사용하는 경우
	- 애플리케이션의 사용량이 급증하고 있으며, 하드웨어 스케일업이 애플리케이션 실행에 있어 안정성을 담보하기 위한 임시 방편인 경우
- 단순 스케일업은 아무것도 배우지 못하며, 고사양의 하드웨어 구매로 문제를 대강 뭉개는 데 익숙해질 것이다.
- 하드웨어 확장은 지속 가능한 접근 방법이 아니다.
	- 물리적인 하드웨어 업그레이드는 간단하지 않다.
	- 스케일업에 따라 더 커다란 비용을 지불해야 한다.

### MySQL 튜닝

- 튜닝: 연구개발을 목적으로 MySQL 시스템 변수를 조정하는 행위로 구체적인 목표와 기준이 있는 실험실 수준의 작업
- 구성: 시스템 변수를 하드웨어와 환경에 적합한 값으로 설정하는 행위로 목표는 변경해야 하는 몇 가지 기본값을 가장 적합한 값으로 구성하는 것
	- 단위가 달라질 정도로 데이터 규모가 대량으로 증가했을 때 재구성이 필요하다.
- 최적화: 워크로드를 줄이거나 효율성을 높여 MySQL 성능을 향상시키는 행위
- 튜닝이 헤드헤링인 이유
	- MySQL 성능은 복잡하므로 튜닝 결과가 의심될 수 있다.
	- MySQL은 이미 고도로 최적화 되었으므로 튜닝의 결과는 기대보다 성능에 큰 영향을 미치지 않는다.
- 재구성이 무의미한 이유
	- MySQL 8.0에서는 `innodb_dedicated_server` 매개변수를 활성화하여 자동으로 서버를 구성한다. 직접 재구성이 무의미하다.

## MySQL 인덱스: 시각적 소개

- 아래 내용은 InnoDB 테이블의 표준 인덱스(`PRIMARY KEY`, `[UNIQUE] INDEX`)에만 적용된다.
- 아래 내용에서 사용할 테이블
	- 프라이머리 키를 가진 `id` 열
	- `a`, `b` 열로 구성된 비고유 세컨더리 인덱스

```sql
CREATE TABLE `elem`(
	`id` int unsigned NOT NULL,
	`a` char(2) NOT NULL,
	`b` char(2) NOT NULL,
	`c` char(2) NOT NULL,
	PRIMARY KEY (`id`),
	KEY `idx_a_b` (`a`, `b`)
) ENGINE=InnoDB;
```

![](assets/Pasted%20image%2020240429203522.png)

### InnoDB 테이블은 인덱스다

- ![](assets/Pasted%20image%2020240429205009.png)
- 위 테이블의 프라이머리 키로 구성된 B-트리 인덱스는 아래와 같다.
	- 테이블의 행은 인덱스 구조에서 리프 노드에 저장된 인덱스 레코드가 된다.
	- 각 인덱스 레코드에는 로우 락, 트랜잭션 격리 등에서 사용되는 메타데이터(`...`로 표시됨)가 포함되어 있다.
	- 프라이머리 키 조회는 매우 빠르고 효율적이다.
	- 프라이머리 키는 MySQL 성능에 핵심적인 역할을 한다.
	- MySQL의 세계에서 모든 것은 프라이머리 키를 중심으로 돌아간다.
	- ![](assets/Pasted%20image%2020240429205044.png)
- 위 테이블의 세컨더리 인덱스는 아래와 같다.
	- 세컨더리 인덱스도 B-트리 인덱스지만 리프 노드는 프라이머리 키값을 저장한다.
	- ![](assets/Pasted%20image%2020240429205823.png)
- 아래 그림은 `SELECT * FROM elem WHERE a='Au' AND b='Be'` 쿼리에 대한 세컨더리 인덱스 조회 상황이다. 
	- ![](assets/Pasted%20image%2020240429210047.png)

### 테이블 접근 방법

- 세 가지 테이블 접근 방법
	- 인덱스 조회
	- 인덱스 스캔
	- 테이블 스캔
- 성능을 발휘하기 위해서는 인덱스 스캔과 테이블 스캔은 피해야 한다.
- 인덱스 조회
	- 인덱스의 정렬된 구조와 접근 알고리즘을 활용하여 특정 행이나 행 범위를 찾는다.
	- 대량의 데이터를 대상으로 한 빠르고 효율적인 접근
- 인덱스 스캔
	- 인덱스 조회가 불가능할 때 MySQL은 전체 데이터 순차 찾기 같은 억지 기법으로 행을 찾아야 한다. 즉, 행을 읽고 일치하는 않는 행을 필터링한다.
	- 유일한 대안이 풀 데이블 스캔이 아닌 이상 인덱스 스캔으로 최적화 하면 안된다.
	- 인덱스 스캔의 2가지 유형
		- 풀 인덱스 스캔
		- 인덱스 전용 스캔
	- 풀 인덱스 스캔
		- 인덱스 순서대로 모든 행을 읽는다.
		- 모든 행을 읽는 것은 일반적으로 성능에 매우 불리하지만 인덱스 순서가 `ORDER BY` 쿼리와 일치할 때 행 정렬을 피할 수 있다.
		- 아래는 `SELECT * FROM elem FORCE INDEX (a) ORDER BY a, b` 쿼리에 대한 상황이다.
			- `FORCE INDEX` 하는 이유: 테이블 크기가 작아서 테이블 풀 스캔이 될 수 있기 때문에 
			- ![](assets/Pasted%20image%2020240429212716.png)
	- 인덱스 전용 스캔(index-only scan)
		- 인덱스에서 열 값을 읽는다.
		- 이를 위해서는 커버링 인덱스가 필요하다.
		- 전체 행을 읽기 위해서 프라이머리 키 조회를 해야 하는 상황이 아니므로 풀 인덱스 스캔보다 빠르다.
- 풀 테이블 스캔
	- 프라이머리 키 순서로 모든 행을 읽는다.
	- 테이블 전체를 스캔하기 때문에 피하는게 최선이다.
	- 테이블 스캔이 허용하거나 괜찮은 경우
		- 테이블이 작고 접근 빈도가 낮을 때
		- 테이블 선택도가 매우 낮을 때(2.4 절에서 설명)
	- ![](assets/Pasted%20image%2020240429220545.png)

## 맨 왼쪽 접두사(leftmost prefix) 요구사항

- 기본적인 인덱스 구조는 인덱스 열 순서에 따라 정렬되므로, 인덱스를 사용하려면 맨 왼쪽 인덱스 열로 시작하는 열을 순서대로 사용해야 한다.
- 인덱스 `(a, b)`와 `(b, a)`는 서로 다르다.
- `(a)`와 `(a, b)` 대신 `(a, b, c)`를 사용할 가능성이 크다.
- 모든 세컨더리 인덱스의 끝에는 프라이머리 키가 숨겨져 있다.
	- `(a, b)` 세컨더리 인덱스는 사실상 `(a, b, id)`

## EXPLAIN: 쿼리 실행 계획

- `EXPLAIN` 명령은 쿼리 실행 계획을 보여준다.
- ![](assets/Pasted%20image%2020240429223011.png)
- ![](assets/Pasted%20image%2020240429223023.png)
- ![](assets/Pasted%20image%2020240429223033.png)
- `table`: 테이블이나 참조된 서브 쿼리. 쿼리에 보여지는 순서가 아니라 MySQL이 결정한 조인 순서로 나열된다.
- `type`: 테이블 접근 방법이나 인덱스 조회의 접근 유형
	- `ALL`: 테이블 풀 스캔
	- `index`: 인덱스 스캔
	- `const`, `ref`, `range` 등의 다른 값: 인덱스 조회의 접근 유형
- `possible_keys`: 맨 왼쪽 접두사 요구사항에 충족되어 MySQL이 사용할 수 있는 인덱스
- `key`: MySQL이 사용할 인덱스의 이름이거나 인덱스를 사용할 수 없을 때에는 `NULL`이다.
- `ref`: 행을 조회하는 데 사용되는 값의 소스를 나열한다.
	- 단일 테이블 쿼리나 조인의 첫 번째 테이블에서는 상수 조건을 나타내는 `const`
		- 예시: `a='Au'`
	- 여러 테이블을 조인하는 쿼리에서 조인 순서상 이전 테이블의 열 참조
- `rows`: MySQL이 일치하는 행을 찾기 위해 조회할 예상하는 행의 수
	- 근사치고 실제 조회하는 행과 같지는 않다.
- `Extras`: 쿼리 실행 계획에 대한 부가 정보를 제공한다.
	- MySQL이 적용할 수 있는 쿼리 최적화를 나타내므로 중요하다.