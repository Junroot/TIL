---
title: 7-고급 매핑
tags:
  - 도서/자바-ORM-표준-JPA-프로그래밍
---
## 상속 관계 매핑

- 관계형 데이터베이스에는 객체지향 언어에서 다루는 상속이라는 개념이 없다.
- 슈퍼타입 서브타입 논리 모델을 실제 물리 모델인 테이블로 구현하는 방법 3가지
	- 조인 전략: 모두 테이블로 만들고 조회할 때 조인을 사용한다.
	- 단일 테이블 전략: 테이블을 하나만 사용해서 통합한다.
	- 구현 클래스마다 테이블 전략: 서브 타입마다 하나의 테이블을 만든다.

### 조인 전략

- 엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략
- 주의 점: 타입을 구분하기 위한 컬럼으 추가 되어야 한다.
- ![](assets/Pasted%20image%2020241202234154.png)
- ![](assets/Pasted%20image%2020241202234202.png)
	- `@Inheritance(strategy = InheritanceType.JOINED)`: 조인 전략 매핑을 사용하기 위한 어노테이션
	- `@DiscriminatorColumn(name ="DTYPE")`: 구분 컬럼을 지정한다. 이 컬럼으로 저장된 자식 테이블을 구분할 수 있다.
	- `@DiscriminatorValue("M")`: 엔티티를 저장할 때 구분 컬럼에 입력할 값을 지정한다.
- 자식 테이블의 기본 키 컬럼명을 변경하고 싶으면 `@PrimaryKeyJoinColumn`을 사용하면 된다.
	- ![](assets/Pasted%20image%2020241202235937.png)
- 장점
	- 테이블이 정규화된다.
	- 외래 키 참조 무결성 제약조건을 활용할 수 있다.
	- 저장공간을 요율적으로 사용한다.
- 단점
	- 조회할 때 조인이 많으므로 성느이 저하될 수 있다.
	- 조회 쿼리가 복잡하다.
	- 데이털르 등록할 INSERT SQL을 두 번 실행한다.

### 단일 테이블 전략

- 주의 점: 구분 컬럼을 필수로 사용해야 한다.
- ![](assets/Pasted%20image%2020241202234553.png)
- ![](assets/Pasted%20image%2020241202234610.png)
- 장점
	- 조인이 필요 없으므로 일반적으로 조회 성능이 빠르다.
	- 조회 쿼리가 단순하다.
- 단점
	- 자식 엕티티가 매핑한 컬럼은 모두 null을 허용해야 한다.
	- 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 그러므로 상황에 따라서는 조회 성능이 오히려 느려질 수 있다.

### 구현 클래스마다 테이블 전략

- ![](assets/Pasted%20image%2020241202235317.png)
- ![](assets/Pasted%20image%2020241202235323.png)
- 장점
	- 서브 타입을 구분해서 처리할 때 효과적이다.
	- `not null` 제약조건을 사용할 수 있다.
- 단점
	- 여러 자식 테이블을 함께 조회할 때 성능이 느리다(SQL에 UNION을 사용해야 한다).
	- 자식 테이블을 통합해서 쿼리하기 어렵다.
- 이 전략은 데이터베이스 설계자와 ORM 전문가 둘 다 추천하지 않는 전략이다.

## @MappedSuperclass

- 부모 클래스는 테이블과 매핑하지 않고 부모 클래스를 상속받는 자식 클래스에게 매핑 정보만 제공하고 싶으면 `@MappedSuperclass`를 사용하면 된다.
- ![](assets/Pasted%20image%2020241203000435.png)
- 부모로부터 물려받은 매핑 정보를 정의하려면 `@AttributeOverrides`나 `@AttributeOverride`를 사용하고, 연관관계를 재정의하려면 `@AssociationOverrids`나 `@AssociationOverride`를 사용한다.
	- ![](assets/Pasted%20image%2020241203000544.png)
- `@MappedSuperclass`의 특징
	- 테이블과 매핑되지 않고 자식 클래스에 엔티티의 매핑 정볼르 상속하기 위해 사용한다.
	- `@MappedSuperclass`로 지정한 클래스는 엔티티가 아니므로 `em.find()`나 JPQL에서 사용할 수 없다.
	- 이 클래스를 직접 생성해서 사용할 일은 거의 없으므로 추상 클래스로 만드는 것을 권장한다.
- `@MappedSuperclass`를 사용하면 등록일자, 수정일자, 등록자, 수정자 같은 여러 엔티티에서 공통으로 사용하는 속성을 효과적으로 관리할 수 있다.
- 엔티티(`@Entity`)는 엔티티(`@Entity`)dlrjsk `@MappedSuperclass`로 지정된 클래스만 상속받을 수 있다.

## 복합 키와 식별 관계 매핑

### 식별 관계 vs 비식별 관계

- 식별 관계: 부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본 키 + 외래 키로 사용하는 관계
	- ![](assets/Pasted%20image%2020241203001030.png)
- 비식별 관계: 부모 테이블의 기본 키를 받아서 자식 테이블의 외래 키로만 사용하는 관계
	- 필수적 식별 관계: 외래 키에 NULL을 허용하지 않는다. 연관관계를 필수적으로 맺어야 한다.
	- 선택적 비식별 관계: 외래 키에서 NULL을 헝요한다. 연관관계를 맺을지 말지 선택할 수 있다.
	- ![](assets/Pasted%20image%2020241203001130.png)
- JPA는 식별 관계와 비식별 관계를 모두 지원한다.
	- 최근에는 비식별 관계를 주로 사용하고 꼭 필요한 곳에만 식별 관계를 사용하는 추세다.

### 복합 키: 비식별 관계 매핑

- JPA는 영속성 컨텍스트에 엔티티를 보관할 때 엔티티의 식별자를 키로 사용한다.
- 식별자를 구분하기 위해 `equals`와 `hashCode`를 사용해 동등성 비교를 한다.
	- 식별자 필드가 2개 이상이면 별도의 식별자 클래슬르 만들고 그곳에 `equals`와 `hashCode`를 구현해야 한다.
- 복합 키를 지원하기 위해 `@IdClass`와 `@EmbeddedId` 2가지 방법을 제공한다.
- `@IdClass`
	- ![](assets/Pasted%20image%2020241203002915.png)
	- 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야 한다.
		- 예제) `Parent.id1`과 `ParentId.id1`, 그리고 `Parent.id2`와 `ParentId.id2`가 같다.
	- `Serializable` 인터페이스를 구현해야 한다.
	- `equals`, `hashCode`를 구현해야 한다.
	- 기본 생성자가 있어야 한다.
	- 식별자 클래스는 public이어야 한다.
	- 복합키 조회
		- ![](assets/Pasted%20image%2020241203003129.png)
	- 연관관계 매핑을 할 때 `@JoinColumns` 어노테이션을 사용해야 한다.
		- ![](assets/Pasted%20image%2020241203003228.png)
- `@EmbeddedId`
	- `@EmbeddedId`는 좀 더 객체지향적인 방법이다.
		- ![](assets/Pasted%20image%2020241203003410.png)
		- ![](assets/Pasted%20image%2020241203003416.png)
	- `@EmbeddedId`를 적용한 식별자 클래스는 다음 조건을 만족해야 한다.
		- `@Embeddable` 어노테이션을 붙여주어야 한다.
		- `Serializable` 인터페이스를 구현해야 한다.
		- `equals`, `hashCode`를 구현해야 한다.
		- 기본 생성자가 있어야 한다.
		- 식별자 클래스를 public이어야 한다.
- `@IdClass` vs `@EmbeddedId`
	-  취향 차이
	- `@EmbeddedId`가 `@IdClass`와 비교해서 더 객체지향적이고 중복도 없어서 좋아보이지만 특정 상황에 JPQL이 조금 더 길어질 수 있다.
	- ![](assets/Pasted%20image%2020241203003647.png)

### 복합 키: 식별 관계 매핑

- ![](assets/Pasted%20image%2020241203004127.png)
- `IdClass`와 식별 관계
	- 식별자 매핑인 `@Id`와 연관관계 매핑인 `@ManyToOne`을 같이 사용한다.
	- ![](assets/Pasted%20image%2020241203004348.png)
	- ![](assets/Pasted%20image%2020241203004432.png)
- `@EmbeddedId`와 식별 관계
	- `@MapsId`: 외래키와 매핑한 연관관계를 기본 키에도 매핑하겠다는 뜻
	- ![](assets/Pasted%20image%2020241203004818.png)
	- ![](assets/Pasted%20image%2020241203004846.png)


