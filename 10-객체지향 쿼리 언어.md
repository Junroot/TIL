---
title: 10-객체지향 쿼리 언어
tags:
  - 도서/자바-ORM-표준-JPA-프로그래밍
---
## 객체지향 쿼리 소개

- JPQL 특징
	- 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리다.
	- SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.
- 다음은 JPA가 공식 지원하는 기능이다.
	- JPQL
	- Criteria 쿼리: JPQL을 편하게 작성하도록 도와주는 API, 빌더 클래스 모음
	- 네이티브 SQL: JPA에서 JPQL 대신 직접 SQL을 사용할 수 있다.
- 다음은 JPA가 공식 지원한느 기능은 아니지만 알아둘 가치가 있다.
	- QueryDSL: Criteria 쿼리처럼 JPQL을 편하게 작성하도록 도와주는 빌더 클래스 모음, 비표준 오픈소스 프레임워크다.
	- JDBC 직접 사용, MyBatis 같은 SQL 매퍼 프레임워크 사용: 필요하면 JDBC를 직접 사용할 수 있다.

### JPQL 소개

- JPQL: 엔티티 객체를 조회하는 객체지향 쿼리
- JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다.
- JPQL은 SQL보다 간결하다. 엔티티 직접 조회, 묵시적 조인, 다형서 지원으로 SQL보다 코드가 간결하다.
- ![](assets/Pasted%20image%2020250217203030.png)
- 실제 실행된 SQL
	- ![](assets/Pasted%20image%2020250217203043.png)

### Criteria 쿼리 소개

- 장점: 문자가 아닌 `query.select(m).wher(...)` 처럼 프로그래밍 코드로 JPQL을 작성할 수 있다.
	- 컴파일 시점에 오류를 발견할 수 있다.
	- IDE를 사용하면 코드 자동완성을 지원한다.
	- 동적 쿼리를 작성하기 편하다.
- ![](assets/Pasted%20image%2020250217203417.png)
- 엔티티의 필드도 문자가 아닌 코드로 작성하려면 메타 모델을 사용하면된다.
	- 자바가 제공하는 어노테이션 프로세서 기능을 사용하면 어노테이션을 분석해서 클래스를 사용할 수 있다.
	- JPA는 이 기능을 사용해서 `Member` 엔티티 클래스로부터 `Member_`라는 Criteria 전용 클래스를 생성하는데 이것을 메타 모델이라 한다.
	- ![](assets/Pasted%20image%2020250217203530.png)
- 단점: 사용하기 불편하고 Criteria로 작성한 코드가 한눈에 들어오지 않는다.

### QueryDSL 소개

- Ciriteria처럼 JPQL 빌더 역할이지만, Criteria에 비해 단순하고 사용하기 쉽다.
- ![](assets/Pasted%20image%2020250217203742.png)

### 네이티브 SQL 소개

- 네이티브 SQL: JPA에서 SQL을 직접 사용할 수 있는 기능
- JPQL을 사용해도 가끔 특정 데이터베이스에 의존하는 기능을 사용해야 할 때 사용된다.
- ![](assets/Pasted%20image%2020250217203906.png)

### JDBC 직접 사용, 마이바티스 같은 SQL 매퍼 프레임워크사용

- JPA 구현체로 JDBC 커넥션을 획득하는 방법은 다음과 같다.
	- ![](assets/Pasted%20image%2020250217204419.png)
- JPA를 우회하는 SQL에 대해서는 JPA가 전혀 인식하지 못하기 때문에, 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트를 수동으로 플러시해서 데이터베이스와 영속성 컨텍스트를 동기화하면 된다.
- 참고로 스프링 프레임워크를 사용하면 JPA와 마이바티스를 손쉽게 통합할 수 있다.
- 또한 스프링 프레임워크의 AOP를 적절히 활용해서 JPA를 우회하여 데이터베이스에 접근하는 메서드를 호출할 때마다 영속성 컨텍스트를 플러시하면 동기화 문제도 깔끔하게 해결할 수 있다.

## JPQL

### 기본 문법과 쿼리 API

- SELECT 문: `SELECT m FROM Member AS m m.username = 'Hello'`
	- 엔티티와 속성은 대소문자를 구분한다. 반면에 SELECT, FROM, AS 같은 JPQL 키워드는 대소문자를 구분하지 않는다.
	- 엔티티 이름: `Member`는 클래스 명이 아니라 엔티티 명이다. `@Entity(name="XXX")`같이 엔티티 명을 지정하지 않으면 클래스명을 기본값으로 사용한다.
	- 별칭은 필수: `Member AS m` 같이 JPQL은 별칭을 필수로 사용해야 한다.
- TypeQuery, Query
	- JPQL을 실행하려면 쿼리 객체를 만들어야 한다.
	- 타입을 명확하게 지정할 수 있으면 `TypeQuery` 객체를 사용하고, 반환 타입을 명확하게 지정할 수 없으면 `Query` 객체를 사용한다.
	- `Query` 객체는 예제처럼 조회 대상이 둘 이상이면  `Object[]` 를 반환하고, 하나면 `Object`를 반환한다. 
	- ![](assets/Pasted%20image%2020250217205824.png)
	- ![](assets/Pasted%20image%2020250217205835.png)
- 결과 조회
	- `query.getResultList()`: 결과를 List 컬렉션으로 반환한다. 만약 결과가 없음녀 빈 컬렉션을 반환한다.
	- `query.getSingleResult()`: 결과가 정확히 하나일 때 사용한다.
		- 결과가 없으면 `NoResultException` 예외가 발생한다.
		- 결과가 1개보다 많으면 `NonUniqueResultException` 예외가 발생한다.

### 파라미터 바인딩

- 이름 기준 파라미터: 이름 기준 파라미터는 앞에 `:`를 사용한다.
	- ![](assets/Pasted%20image%2020250217210356.png)
- 위치 기준: `?` 다음에 위치 값을 주면 된다. 위치 값은 1부터 시작한다.
	- ![](assets/Pasted%20image%2020250217210416.png)
- 파라미터 바인딩 방식은 선택이 아닌 필수다.
	- 파라미터 바인딩을 사용하지 않으면 SQL 인젝션 공격을 당할 수 있다.
	- 파라미터 바인딩 방식을 사용하면 
		- 파라미터의 값이 달라도 같은 쿼리로 인식해서 JPA는 JPQL을 SQL로 파싱한 결과를 재사용할 수 있다.
		- 데이터베이스도 내부에서 실행한 SQL을 파싱해서 사용하는 같은 쿼리는 파싱한 결과를 재사용할 수 있다.

### 프로젝션

- SELECT 절에 조회할 대상을 지정하는 것을 프로젝션이라 하고 `SELECT {프로젝션 대상} FROM`으로 대상을 선택한다.
- 엔티티 프로젝션
	- 조회한 엔티티는 영속성 컨텍스트에서 관리한다.
	- ![](assets/Pasted%20image%2020250217211145.png)
- 임베디드 타입 프로젝션
	- 임베디드 타입은 조회의 시작점이 될 수 없고, 엔티티가 시작점이 되어 엔티티를 통해서 임베디드 타입을 조회할 수 있다.
	- 임베디드 타입은 엔티티 타입이 아닌 값 타입이다. 이렇게 조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않는다.
	- ![](assets/Pasted%20image%2020250217211215.png)
- 스칼라 타입 프로젝션
	- 스칼라 타입: 숫자, 문자, 날짜 같은 기본 데이터 타입
	- 다음과 같은 통계 쿼리를 주로 스칼라 타입으로 조회한다.
	- ![](assets/Pasted%20image%2020250217211333.png)
- 여러 값 조회
	- 프로젝션에 여러 값을 선택하려면 `TypeQuery`를 사용할 수 없고 대신에  `Query`를 사용해야 한다.
	- 스칼라 타입 뿐만 아니라 엔티티 타입도 여러 값을 함께 조회할 수 있고, 이때 조회한 엔티티는 영속성 컨텍스트에서 관리된다.
	- ![](assets/Pasted%20image%2020250217211416.png)
- NEW 명령어
	- 여러 값 조회할 때 `UserDTO`처럼 의미 있는 객체로 변환하면 `TypeQuery`를 사용할 수 있다.
	- NEW 명령어를 사용할 때 주의점
		- 패키지 명을 포함한 전체 클래스 명을 입력해야 한다.
		- 순서와 타입이 일치하는 생성자가 필요하다.
	- ![](assets/Pasted%20image%2020250217211548.png)

### 페이징 API

- 데이터베이스마다 페이징을 처리하는 SQL 문법이 다르다.
- JPA 페이징은 당므 두 API로 추상화했다.
	- `setFirstgResult(int startPosition)`: 조회 시작 위치(0부터 시작한다)
	- `setMaxResult(int maxResult)`: 조회할 데이터 수
- ![](assets/Pasted%20image%2020250217211854.png)
- MySQL 변환 결과
	- ![](assets/Pasted%20image%2020250217211914.png)
- 페이징을 더 최적화하고 싶다면 JPA가 제공하는 페이징 API가 아닌 네이티브 SQL을 직접 사용해야 한다.

### 집합과 정렬

- 집합 함수
	- ![](assets/Pasted%20image%2020250217212354.png)
- 집합 함수 사용 시 참고사항
	- `NULL` 값은 무시하므로 통계에 잡히지 않는다.
	- 만약 값이 없는데 `SUM`, `AVG`, `MAX`, `MIN` 함수를 사용하면 `NULL` 값이 된다. 단 `COUNT`는 0이 된다.
	- `DISTINCT`를 집합 함수 안에 사용해서 중복된 값을 제거하고 나서 집합을 구할 수 있다.
	- `DISTICT`를 `COUNT`에서 사용할 때 임베디드 타입은 지원하지 않는다.
- GROUP BY, HAVING
	- ![](assets/Pasted%20image%2020250217212648.png)
- 정렬
	- ![](assets/Pasted%20image%2020250217212727.png)

### JPQL 조인

- 내부 조인
	- INNER JOIN을 사용한다. INNER는 생략할 수 있다.
	- ![](assets/Pasted%20image%2020250217213502.png)
	- 실제 SQL
		- ![](assets/Pasted%20image%2020250217213518.png)
- 외부 조인
	- OUTER LEFT JOIN을 사용한다. OUTER는 생략할 수 있다.
	- ![](assets/Pasted%20image%2020250217213723.png)
- 컬렉션 조인
	- '회원 -> 팀'으로의 조인은 다대일 조인이면서 단일 값 연관 필드를 사용한다.
	- '팀 -> 회원'으로 반대로 일대다 조인이면서 컬렉션 값 연관 필드를 사용한다.
	- ![](assets/Pasted%20image%2020250217213847.png)
- 세타 조인
	- 세타 조인은 내부 조인만 지원한다.
	- ![](assets/Pasted%20image%2020250217213929.png)
- JOIN ON 절(JPA 2.1)
	- JPA 2.1부터 조인할 때 ON 절을 지원한다.
	- ON 절을 사용하면 조인 대상을 필터링하고 조인할 수 있다.
	- 참고로 내부 조인의 ON 절은 WHERE 절ㅇ르 사용할 때와 결과가 같으므로 보통 ON절은 외부 조인에서만 사용한다.
	- ![](assets/Pasted%20image%2020250217214037.png)

### 페치 조인

- 페치 조인은 SQL에서 이야기하는 조인의 종류는 아니고 JPQL에서 성능 최적화를 위해 제공하는 기능이다.
- 엔티티 페치 조인
	- ![](assets/Pasted%20image%2020250217215751.png)
	- 실행된 SQL
		- ![](assets/Pasted%20image%2020250217215823.png)
	- 회원을 조회할 때 페치 조인을 사용해서 팀도 함께 조회했으므로 연관된 팀 엔티티는 프록시가 아닌 실제 엔티티다.
		- 따라서 연관된 팀을 사용해도 지연 로딩이 일어나지 않는다.
- 컬렉션 페치 조인
	- ![](assets/Pasted%20image%2020250217220023.png)
	- 실행된 SQL
		- ![](assets/Pasted%20image%2020250217220031.png)
		- ![](assets/Pasted%20image%2020250217220047.png)
	- 팀은 하나지만 멤버와 조인하면서 '팀A'를 2건 반환하게 된다.
- 페치 조인과 DISTINCT
	- ![](assets/Pasted%20image%2020250217220149.png)
	- distinct를 사용하면 
		- SQL에서 `SELECT DISTINCT`가 추가된다.
		- 다음으로 애플리케이션에서 엔티티 기준으로 중복을 제거한다.
- 페치 조인과 일반 조인의 차이
	- ![](assets/Pasted%20image%2020250217221336.png)
	- 일반 조인은 연관관계까지 고려하지 않는다. 단지 SELECT 절에 지정한 엔티티만 조회할 뿐이다.
		- 그래서 회원 컬렉션 조회시 다시 쿼리를 실행한다.
	- 페치 조인을 사용하면 연관된 엔티티도 함께 조회한다.
		- ![](assets/Pasted%20image%2020250217221454.png)
- 페치 조인의 특징과 한계
	- 페치 조인을 사용하면 SQL 한 번으로 연관된 엔티티들을 함께 조회할 수 있어서 SQL 호출 횟수를 줄여 성능을 최적화할 수 있다.
	- 글로벌 로딩 전략은 될 수 있으면 지연 로딩을 사용하고 최적화가 필요하면 페치 조인을 적용하는 것이 효과적이다.
	- 페치 조인 한계
		- 페치 조인 대상에는 별칭을 줄 수 없다.
		- 둘 이상의 컬렉션을 페치할 수 없다.
			- 구현체에 따라 되기도 하는데 컬렉션 \* 컬렉션의 카테시안 곱이 만들어지므로 주의해야 한다.
		- 컬렉션을 페치 조인하면 페이징 API(setFirstResult, setMaxResults)를 사용할 수 없다.
			- 하이버네이트에서 컬렉션을 페치 조인하고 페이징 API를 사용하면 경고 로그를 남기면서 메모리에서 페이징 처리를 한다. 데이터가 적음녀 상관없지만 데이터가 많으면 성능 이슈와 메모리 초과 예외가 발생할 수 있어서 위험하다.
	- 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적이다. 반면에 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하면 억지로 페치 조인을 사용하기보다는 여러 테이블에서 필요한 필드들만 조회해서 DTO로 반환하는 것이 더 효과적일 수 있다.
