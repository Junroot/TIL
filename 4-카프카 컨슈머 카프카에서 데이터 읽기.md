---
title: 4-카프카 컨슈머 카프카에서 데이터 읽기
tags:
  - 도서/카프카-핵심-가이드
---
## 카프카 컨슈머: 개념

### 컨슈머와 컨슈머 그룹

- 카프카 컨슈머는 보통 컨슈머 그룹의 일부로서 작동한다.
	- 이유: 우리는 토픽으로부터 데이터를 읽어 오는 작업을 확장할 수 있어야 한다.
- 동일한 컨슈머 그룹에 속한 여러 개의 컨슈머들이 동일한 토픽을 구독할 경우, 각각의 컨슈머는 해당 토픽에서 서로 다른 파티션의 메시지를 받는 것이다.
	- ![](assets/Pasted%20image%2020250518142209.png)
	- ![](assets/Pasted%20image%2020250518142215.png)
	- ![](assets/Pasted%20image%2020250518142225.png)
	- ![](assets/Pasted%20image%2020250518142235.png)
- 컨슈머 그룹에 컨슈머를 추가하는 것은 카프카 토픽에서 읽어오는 데이터 양을 확장하는 주된 방법이다.
- 토픽을 생성할 때 파티션을 크게 잡아주는 게 좋은 이유: 부하가 증가함에 따라서 더 많은 컨슈머를 추가할 수 있게 해주기 때문
	- 토픽에 설정된 파티션 수 이상으로 컨슈머를 투입하는 것은 아무 의미가 없는 점도 명심하라
- 새로운 컨슈머 그룹, G2를 추가하게 된다면 이 컨슈머는 G1 컨슈머 그룹에서 무엇을 하고 있든지 상관없이 T1 토픽의 모든 메시지를 받게 된다.
	- ![](assets/Pasted%20image%2020250518142501.png)

### 컨슈머 그룹과 파티션 리밸런스

- 리밸런스: 컨슈머에 할당된 파티션을 다른 컨슈머에게 할당해주는 작업
- 리밸런스가 발생하는 상황
	- 새로운 컨슈머가 컨슈머 그룹에 추가
	- 컨슈머가 종료되거나 크래시가 난 경우
	- 컨슈머 그룹이 읽고 있는 토픽이 변경 되었을 때 (예를 들어, 운영자가 토픽에 새 파티션을 추가했을 경우)
- 리밸런스에는 컨슈머 그룹이 사용하는 파티션 할당 전략에 따라 2가지가 있다.
	- 조급한 리밸런스(eager rebalance)
		- 실행되는 와중에 모든 컨슈머는 읽기 작업을 멈추고 자신에게 할당된 모든 파티션에 대한 소유권을 포기한 뒤, 컨슈머 그룹에 다시 참여하여 완전히 새로운 파티션 할당을 전달받는다.
		- 이러한 방식은 근본적으로 전체 컨슈머 그룹에 대해 짧은 시간 동안 작업을 멈추게한다.
		- ![](assets/Pasted%20image%2020250518144752.png)
	- 협력적 리밸런스(cooperative rebalnce)
		- 한 컨슈머에게 할당되어 있던 파티션만을 다른 컨슈머에 재할당한다.
		- 리밸런싱이 2개 이상의 단계에 걸쳐서 수행된다.
			1. 우선 컨슈머 그룹 리더가 다른 컨슈머들에게 각자에게 할당된 파티션 중 일부가 재할당될 것이라고 통보하면, 컨슈머들은 해당 파티션에서 데이터를 읽어오는 작업을 멈추고 해당 파티션에 대한 소유권을 포기한다.
			2. 컨슈머 그룹 리더가 이 포기된 파티션을 새로 할당한다.
		- 재할당되지 않은 파티션에서 레코드를 읽어서 처리하던 컨슈머들은 작업에 방해받지 않고 하던 읽을 계속할 수 있을 것이다.
- 컨슈머가 소유권을 유지하는 방식
	- 해당 컨슈머 그룹의 그룹 코디네이터(group coordinator) 역할을 지정받은 카프카 브로커에 하트비트를 전송한다.
	- 하트비트는 컨슈머의 백그라운드 스레드에 의해 전송되며, 일정한 간격을 두고 전송되는한 연결이 유지되고 있는 것으로 간주한다.
	- 만약 컨슈머가 일정 시간 하트비트를 전송하지 않는다면, 세션 타임아웃이 발생하면서 그룹 코디네이터는 해당 컨슈머가 죽었다고 간주하고 리밸런스를 실행한다. 이 몇 초 동안 죽은 컨슈머에 할당되어 있던 파티션은 아무 메시지도 처리되지 않는다.
	- 컨슈머를 깔끔하게 닫아줄 경우 컨슈머는 그룹 코디네이터에게 그룹을 낙나다고 통지하는데, 그러면 그룹 코디네이터는 즉시 리밸런스를 실행함으로써 처리가 정지되는 시간을 줄인다.
- 파티션은 어떻게 컨슈머에게 할당되는가?
	- 컨슈머가 그룹에 참여하고 싶을 때는 그룹 코디네이터에게 `JoinGroup` 요청을 보낸다.
	- 가장 먼저 그럽에 참여한 컨슈머가 그럽 리더가 된다.
	- 리더는 그룹 코디네이터로부터 해당 그룹 안에 있는 모든 컨슈머의 목록을 받아서 각 컨슈머에게 파티션의 일부를 할당해 준다.
	- 카프카에는 몇 개의 파티션 할당 정책이 기본적으로 내장되어 있다.
	- 컨슈머 그룹 리더는 파티션 할당이 결정되면 할당 내역을 그룹 코디네이터에게 전달하고, 그룹 코디네이터는 다시 이 정보를 모든 컨슈머에게 전파한다.
		- 각 컨슈머 입장에서는 자기에게 할당된 내역만 보인다.
		- 리더만 클라이언트 프로세스 중 유일하게 그룹 내 켠슈머와할당 내역을 전부 볼 수 있다.
- 카프카 2.4이후로 조급한 리밸런스가 기본값이었지만, 3.1부터는 협력적 리밸런스가 기본값이 되었다.

### 정적 그룹 멤버십

- 기본적으로, 컨슈머가 갖는 컨슈머 그룹의 멤버십은 일시적이다.
- 컨슈머에 `group.instance.id` 값을 잡아주면 컨슈머 그룹의 정적인 멤버가 되도록 해준다.
	- 컨슈머가 정적 멤버로서 컨슈머 그룹에 처음 참여하면 평소와 같이 해당 그룹이 사용하고 있느 파티션 할당 전략에 따라 파티션이 할당된다.
	- 하지만 이 컨슈머가 꺼질 경우, 자동으로 그럽을 떠나지 않는다.
	- 그리고 컨슈머가 다시 그룹에 조인하면 멤버십이 그대로 유지되기 때문에 리밸런스가 발생할 필요 없이 예전에 할당받아썬 파티션들을 그대로 재할당받는다.
- 그룹 코디네이터는 그룹 내 각 멤버에 대한 파티션 할당을 캐시해 두고 있기 때문에 정적 멤버가 다시 조인해 들어온다고 해서 리밸런스를 발생시키지는 않는다.
- 만약 같은 `group.instance.id` 값을 갖는 두 개의 컨슈머가 같은 그룹에 조인할 경우 에러가 발생할 것이다.
- 정적 그룹 멤버십이 편리한 케이스: 각 컨슈머에 할당된 파티션의 내용물을 사용해서 로컬 상태나 캐시를 유지해야 할 때
- 반대로 생각하면, 각 컨슈머에 할당된 파티션들이 해당 컨슈머가 재시작한다고 해서 다른 컨슈머로 재할당되지 않는다.
	- 컨슈머를 잃어버린 파티션들로부터 메시지를 읽어오지 않을 것이기 떄문에 정지되었던 컨슈머가 다시 돌아오면 이 파티션에 저장된 최신 메시지에서 한참 뒤에 있는 밀린 메시지부터 처리하게 된다.
- 컨슈머 그룹의 정적 멤버는 종료할 때 미리 컨슈머 그룹을 떠나지 않고, `session.timeout.ms` 설정에 따라 컨슈머 그룹을 떠나게 된다.

## 카프카 컨슈머 생성하기

![](assets/Pasted%20image%2020250518151631.png)
- `bootstrap.servers`: 카프카 클러스터로의 연결 문자열
- `key.deserializer`, `value.deserializer`: 프로듀서에서 시리얼라이저와 비슷한 역할의 역직렬화 클래스
- `group.id`: `KafkaConsumer` 인스턴스가 속하는 컨슈머 그룹

## 토픽 구독하기

- `subscribe()` 메서드로 컨슈머가 1개 이상의 토픽을 구독할 수 있다.
	- ![](assets/Pasted%20image%2020250518152558.png)
- 정규식을 매개변수로 사용해서 `subscribe`를 호출하는 것이 가능하다.
	- 정규식은 다수의 토픽 이름에 매치될 수도 있으며, 만약 누군가가 정규식과 매치되는 이름을 가진 새로운 토픽을 생성할경우, 거의 즉시 리밸런스가 발생하면서 컨슈머들은 새로운 토픽으로부터 읽기 작업을 시작하게 된다.
	- 정규식을 사용해서 다수의 토픽을 구독하는 것은 카프카와 다른 시스템 사이에 데이터를 복제하는 애플리케이션이나 스트림 처리 애플리케이션에서 매우 흔하게 사용되는 기법이다.

## 폴링 루프

![](assets/Pasted%20image%2020250518153600.png)
- 우리가 `poll()`에 전달하는 매개변수는 컨슈머 버퍼에 데이터가 없을 경우 `poll()`이 블록될 수 있는 최대 시간을 결정한다.
	- 만약 이 값이 0으로 지정되거나 버퍼 안에 이미 레코드가 준비되어 있을 경우 즉시 리턴된다. 그게 아닐 경우 지정된 밀리초만큼 기다린다.
- 새 컨슈머에 처음으로 `poll()`을 호출하면 컨슈머는 `GroupCoordinator`를 찾아서 컨슈머 그룹에 참가하고, 파티션을 할당받는다. 리밸런스 역시 연관된 콜백들과 함께 여기서 처리된다.
- `poll()`이 `max.poll.internval.ms`에 지정된 시간 이상으로 호출되지 않을 경우, 컨슈머는 죽은 것으로 판정되어 컨슈머 그룹에서 퇴출된다.
	- 따라서 폴링 루프 안에 예측 불가능한 시간 동안 블록되는 작업을 수행하는 것은 피해야 한다.

### 스레드 안정성

- 하나의 스레드에서 동일한 그룹 내에 여러 개의 컨슈머를 생성할 수는 없으며, 같은 컨슈머를 다수의 스레드가 안전하게 사용할 수도 없다.
	- 하나의 스레드당 하나의 컨슈머가 원칙이다.
- 컨슈머 로직을 자체적인 객체로 감싼 다음 자바의 `ExecutorService`를 사용해서 각자의 컨슈머를 가지는 다수의 스레드를 시작시키면 좋다.
- 또 달느 방법으로는 이벤트를 받아서 큐에 넣는 컨슈머 하나와 이 큐에서 이벤트를 꺼내서 처리하는 여러 개의 워커 스레드를 사용하는 것이다.
