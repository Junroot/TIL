---
title: 5-프로그램 내에서 코드로 카프카 관리하기
tags:
  - 도서/카프카-핵심-가이드
---
- 0.11 부터 프로그램적인 관리 기능 API를 제공하기 위한 목적으로 `AdminClient`가 추가되었다.

## AdminClient 개요

### 비동기적이고 최종적 일관성을 가지는 API

- 카프카의 `AdminClient`는 비동기적으로 작동한다.
- 카프카 컨트롤러로부터 브로커로의 메타데이터 전파가 비동기적으로 이루어지기 때문에, `AdminClient` API가 리턴하는 `Future` 객체들은 컨트롤러의 상태가 완전히 업데이트된 싲머에 완료된 것으로 간주한다.
	- 이 시점에 모든 브로커가 전부 다 새로운 상태에 대해 알고 있지는 못할 수 있기 때문에, `listTopics` 요청은 최신 상태를 전달받지 않은 브로커에 의해 처리될 수 있다.
	- 이러한 속성을 최종적 일관성(eventual consistency)이라고 한다.
	- 최종적 일관성: 최종적으로 모든 브로커는 모든 토픽에 대해 알게 될 것 이지만, 정확히 그게 언제가 될지에 대해서는 아무런 보장도 할 수 없다.

### 옵션

- `AdminClient`의 각 메서드는 메서드별로 특정한 `Options` 객체를 인수로 받는다.
- 이 객체들은 브로커가 요청을 어떻게 처리할지에 대해 서로 다른 설정을 담는다.

### 수평 구조

- 모든 어드민 작업은 `KafkaAdminClient`에 구현되어 있는 아파치 카프카 프로토콜을 사용해서 이루어진다.

### 추가 참고 사항

 - 클러스터의 상태를 변경하는 모든 작업(create, delete, alter)은 컨트롤러에 의해 수행된다.
 - 클러스터 상태를 읽기만 하는 작업(list, describe)은 아무 브로커에서나 수행될 수 있으며 클라이언트 입자에서 보이는 가장 부하가 적은 브로커로 전달된다.
 - 카프카 2.5을 기준으로, 대부분의 어드민 작업인 `AdminClient`를 통해서 수행되거나 아니면 주키퍼에 저장되어 있는 메타데이터를 직접 수정하는 방식으로 이루어진다.
 - 주키퍼를 직접 수정하는 것은 절대 쓰지 말 것을 권장한다.

## AdminClient 사용법: 생성, 설정, 닫기

- 정적 메서드인 `create` 메서드는 설정값을 담고 있는 `Properties` 객체를 인수로 받는다.
	- 반드시 있어야 하는 설정은 클러스터에 대한 URI 하나뿐이다.
	- ![](assets/Pasted%20image%2020250615200511.png)
- `AdminClient`를 시작했으면, `close`를 호출해서 결국엔 닫아야 한다.
	- `close` 메서드를 호출할 때는 아직 진행중인 작업이 있을 수 있어, 타입아웃 매개변수를 받는다.
	- `close`를 호출하면 다른 메서드를 호출해서 요청을 보낼 수 는 없지만, 클라이언트는 타임아웃이 만료될 때까지 응답을 기다릴 것이다.
	- 타임아웃이 발생하면 모든 진행중인 작동을 멈추고 모든 자원을 해제한다.
	- 타임아웃 없이 `close`를 호출한다는 것은 얼마가 되었든 모든 진행중인 작업이 완료될 때까지 대기하게 된다는 의미다.

### client.dns.lookup

- 기본적으로 카프카는 부트스트랩 서버 설정에 포함된 호스트명을 기준으로 연결을 검증하고, 해석하고, 생성한다.
- DNS 별칭을 사용하는 경우
	- 모든 브로커들을 부트스트랩 서버 설정에 일일이 지정하는 것보다 이 모든 브로커 전체를 가리킬 하나의 DNS 별칭을 만들 수 있다.
	- 이것은 편리하지만, SASL을 사용해서 인증하려고할 때 중간자 공격으로 처리하여 인증을 거부한다.
	- 이러한 경우 `client.dns.lookup=resolve_canonical_bootstrap_servers_only` 설정을 잡아 주면, 클라이언트는 DNS 별칭을 '펼치게' 되기 때문에 DNS 별칭을 포함된 모든 브로커 이름이 일일이 부트스트랩 서버 목록에 넣어 준 것고 ㅏ동일하게 된다.
- 다수의 IP 주소로 연결되는 DNS 이름을 사용하는 경우
	- 최근 네트워크 아키텍처에 모든 브로커를 프록시나 로드 밸런서 뒤로 숨기는 것은 매우 흔하다.
	- 이와 같은 이유 떄문에 `broker1.host.com`를 여러 개의 IP 주소로 연결하는 것은 매우 흔하다.
	- 기본적으로, 카프카 클라이언트는 해석된 첫 번째 호스트명으로 연결을 시도한다. 따라서, 해석된 IP 주소가 사용 불능일 경우 브로커가 멀쩡학 ㅔ작동하고 있는데도 클라이언트는 연결에 실패할 수 있다.
	- 바로 이러한 이유 때문에 클라이언트가 로드 밸런싱 계층의 고가용성을 충분히 활용할 수 있도록 `client.dns.lookup=use_all_dns_ips`를 사용하는 것이 권장된다.

### request.timeout.ms

- 애플리케이션이 `AdminClient`의 응답을 기다릴 수 있는 시간의 최대값을 정의한다.(기본값은 120초)
	- 이 시간에는 클라이언트가 재시도가 가능한 에러를 받고 재시도하는 시간이 포함된다.
- `Options` 객체에 해당 메서드에만 해당하는 타임아웃값을 설정할 수 있다.

## 설정 관리

- 설정 관리는 `ConfigResource` 객체를 사용해서 할 수 있다.
- 설정 가능한 자원에는 브로커, 브로커 로그, 토픽이 있다.
- ![](assets/Pasted%20image%2020250615204750.png)
- 토픽 설정이 기본값이 아닌 것으로 취급하는 경우는 다음과 같다.
	- 사용자가 토픽의 설정값을 기본값이 아닌 것으로 잡아준 경우
	- 브로커 단위 설정이 수정된 상태에서 톺기이 생성되어 기본값이 아닌 값을 브로커 설정으로부터 상속받았을 경우

## 컨슈머 그룹 관리

### 컨슈머 그룹 살펴보기

- 컨슈머 그룹의 목록 조회
	- ![](assets/Pasted%20image%2020250615205736.png)
	- `valid()` 메서드로 리턴되는 모음은 클러스터가 에러없이 리턴한 컨슈머 그룹만 포함한다.
	- `errors()` 세버드를 사용해서 모든 예외를 가져올 수 있다.
	- 만약 우리가 다른 예제에서 본 것 처럼 `all()` 메서드를 호출한다면, 클러스터가 리턴한 에러 중 맨 첫 번째 것만 예외 형태로 발생한다.
- 특정 그룹에 대해 상세한 정보 조회
	- ![](assets/Pasted%20image%2020250615205902.png)
	- 그룹 멤버와 멤버별 식별자와 호스트명, 멤버별로 할당된 파티션, 할당 알고리즘, 그룹 코디네이터의 호스트명이 포함된다.
- 컨슈머 그룹의 오프셋 정보 조회
	- ![](assets/Pasted%20image%2020250615210116.png)

### 컨슈머 그룹 수정하기

- 오프셋 토픽의 오피셋 값을 변경한다 해도 컨슈머 그룹에 변경 여부가 전달되지 않는다는 점을 명심해라.
- 컨슈머가 모르는 오프셋 변경을 방지하기 위해, 카프카에서는 현재 작업이 돌아가고 있느 컨슈머 그룹에 대한 오프셋을 수정하는 것을 허용하지 않는다.
	- 아래 `alterConsumerGroupOffsets`가 실패하는 가장 흔한 이유 중 하나는 컨슈머 그룹을 미리 정지시키지 않아서다.
	- 만약 컨슈머 그룹이 여전히 돌아가고 있는 중이라면, 컨슈머 코디네이터 입장에서는 컨슈머 그룹에 대한 오프셋 변경 시도가 곧 그룹의 멤버가 아닌 클라이언트가 오프셋을 커밋하려 드는 것으로 간주한다. 이 경우, `UnknownmemberIdException`이 발생한다.
- ![](assets/Pasted%20image%2020250615210832.png)