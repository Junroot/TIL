# 테스트를 위한 애플리케이션 컨텍스트 관리

- 테스트는 가능한 독립적으로 매번 새로은 객체를 만들어서 사용하는 것이 원칙이다. 하지만 애플리케이션 컨텍스트처럼 생성이 많은 시간과 자원이 소모되는 경우에는 테스트 전체가 공유하는 오브젝트를 만들기도 한다. 이때도 테스트는 일관성있는 실행 겨로가를 보장해야 하고, 테스트의 실행 순서가 결과에 영향에 미치지 않아야 한다.
- 애플리케이션 컨텍스트는 초기화되고 나면 내부 상태가 바뀌는 일은 거의 없다. 따라서 애플리케이션 컨텍스트는 한 번만 만들고 여러 테스트가 공유해서 사용해도 된다. JUnit에서 제공하는 `@BeforeClass` 스태틱 메소드를 사용해도되지만 스프링이 직접 제공하는 애플리케이션 컨텍스트 테스트 지원 기능을 사용하는 것이 더 편리하다. 이를 스프링 테스트 컨텍스트 프레임워크라고 한다.
- 스프링 테스트 컨텍스트 프레임워크는  테스트 개수에 상관없이 한 번만 만들어서 테스트 메소드에 공유하기 떄문에 수행 속도가 빨라진다.
    
    ```java
    @ContextConfiguration(locations="/applicationContext.xml")
    public class UserDaoTest {
    	@Autowired
    	private ApplicationContext context;
    
    	@BeforeEach
    	public void setUp() {
    		System.out.println(this.context); // 1
    		System.out.println(this); // 2
    	}
    }
    ```
    
    1. 매번 같은 주소값이 나온다.
    2. 테스트 메소드를 실행할 때마다 새로운 테스트 오브젝트를 만들기 때문에 매번 다른 주소 값이 나온다.

- 또한 여러 개의 테스트 클래스가 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면, 스프링은 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유하게 해준다.
    
    ```java
    @ContextConfiguration(locations="/applicationContext.xml")
    public class UserDaoTest { }
    
    @ContextConfiguration(locations="/applicationContext.xml")
    public class GroupDaoTest { }
    ```
    
- 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록한다. 따라서 애플리케이션 컨텍스트에는 ApplicationContext 타입의 빈이 존재하는 셈이고 오토와이어링이 가능하다. 또한 애플리케이션 컨텍스트가 갖고 있는 빈을 DI 받을 수 있으면 굳이 컨텍스트를 가져와 `getBean()`을 사용하는 것이 아니라, 아예 빈을 DI 받을 수도 있다.
- 테스트는 그 실행 순서와 환경에 영향을 받지 않아야 한다. 어쩔 수 없이 컨텕스트의 빈 오브젝트를 수정하는 작업이 필요하다면 테스트 메소드에 `@DirtiesContext` 애노테이션을 붙여주면 된다. 이 애노테이션은 테스트가수행되고 나면 스프링은 현 테스트 컨텍스트를 강제로 제거한다. 이후에 같은 컨텍스트를 사용하는 테스트가 진해오딘다면, 이때는 새로운 컨텍스트가 만들어진다. 따라서 다른 테스트에는 영향을 주지 않고 안전하게 컨텍스트를 조작하는 테스트를 만들 수 있다.