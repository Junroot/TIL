# MockMvc가 E2E 테스트라고 할 수 없는 이유

사실 여러가지 이유가 있겠지만, 오늘 확실히 체감되는 부분이 있어서 기록한다. MockMvc 테스트는 테스트 코드의 트랜잭션과 프로덕션 코드의 트랜잭션을 공유하고 있어서, 실제로 DB까지 저장되지 않은 경우에도 영속성 컨택스트에만 존재한다면 값을 반환할 수 있다는 문제점이 있다. 

```java
@BeforeEach
public void setUp(WebApplicationContext webApplicationContext, RestDocumentationContextProvider restDocumentation) throws Exception {
    super.setUp(webApplicationContext, restDocumentation);

    games.add(gameRepository.save(new Game("League Of Legends1", Collections.singletonList(IMAGE_1))));
    games.add(gameRepository.save(new Game("League Of Legends2", Arrays.asList(IMAGE_1, IMAGE_2))));
    games.add(gameRepository.save(new Game("League Of Legends3", images)));

    games.get(0).addNames(Arrays.asList(ALTERNATIVE_NAME1, ALTERNATIVE_NAME2));
    games.get(1).addNames(Collections.singletonList(ALTERNATIVE_NAME3));
}

@DisplayName("단일 게임 조회")
@Test
void findGameById() throws Exception {

    mockMvc.perform(get("/api/games/" + games.get(0).getId())
            .accept(MediaType.APPLICATION_JSON_VALUE))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.id").value(games.get(0).getId()))
        .andExpect(jsonPath("$.name").value(games.get(0).getName()))
        .andExpect(jsonPath("$.images").value(IMAGE_1))
        .andExpect(jsonPath("$.alternativeNames").value(hasSize(2)))
        .andExpect(jsonPath("$.alternativeNames").value(containsInAnyOrder(ALTERNATIVE_NAME1, ALTERNATIVE_NAME2)))

        .andDo(document("read-game",
            responseFields(fieldWithPath("id").description("게임 Id"),
                fieldWithPath("name").description("게임 이름"),
                fieldWithPath("images").description("게임 이미지 목록"),
                fieldWithPath("alternativeNames").description("대체 이름"))));
}
```

위의 예시에서 `Game` 의 대체 이름은 `AlternativeGameName` 이라는 엔티티로 데이터를 관리한다. 하지만 실수로 cascade 옵션을 추가하지 않아서 `AlternativeGameName` 을 DB에 저장하지 않았는데도, 테스트가 잘 통과했다. 실제로 sql 로깅을 봐도 DB에 저장되지 않는 것을 확인했다. 따라서, MockMvc 테스트가 E2E 테스트로 사용될 수 없다는 점을 제대로 느꼈다.