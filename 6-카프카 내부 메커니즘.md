---
title: 6-카프카 내부 메커니즘
tags:
  - 도서/카프카-핵심-가이드
---
## 클러스터 멤버십

- 카프카는 현재 클러스터의 멤버인 브로커들의 목록을 유지하기 위해 아파치 주키퍼를 사용한다.
- 각 브로커는 브로커 설정 파일에 저장되었거나, 자동으로 생성된 고유 식별자를 가진다.
- 브로커 프로세스는 시작될 때마다 주키퍼에 Ephemeral 노드의 형태롤 ID를 등록한다.
- 컨트롤러들과 몇몇의 생태계 툴들은 브로커가 등록되는 주키퍼의 `/brokers/ids` 경로를 구독함으로써 브로커가 추가되거나 제거될 때마다 알림을 받는다.
	- 만약 동일한 ID를 가진 다른 브로커를 시작한다면, 에러가 발생한다.
- 브로커가 정지하면 브로커를 나타내는 ZNode는 삭제되지만, 브로커의 ID는 다른 자료구조에 남아 있게 된다.
	- 그렇기 때문에 만약 특정한 브로커가 완전히 유실되어 동일한 ID를 가진 새로운 브로커를 투입시킬 경우, 곧바로 클러스터에 유실된 브로커의 자리를 대신해 이전 브로커의 토픽과 파티션들을 할당받는다.
	- 참고: Ephemeral 노드는 ZNode의 한 종류이다.

## 컨트롤러

- 컨트롤러는 일반적인 카프카 브로커의 기능에 더해서 파티션 리더를 선출하는 역할을 추가적으로 맡는다.
	- 클러스터에서 가장 먼저 시작되는 브로커는 주키퍼 `/controller`에 Ephemeral 노드를 생성함으로써 컨트롤러가 된다.
- 브로커들이 주키퍼의 컨트롤러 노드에 뭔가 변동이 생겼을 때 알림을 받기 위해 이 노드에 와치를 설정한다. 이렇게 함으로써 우리는 클러스터 안에 한 번에 단 한 개의 컨트롤러만 있도록 보장할 수 있다.
- 컨트롤러 브로커가 멈추거나 주키퍼와의 연결이 끊어질 경우, 이 Ephemeral 노드는 삭제된다.
	- 컨트롤러가 사용하는 주키퍼 클라이언트가 `zookeeper.session.timeout.ms`에 설정된 값보다 더오랫동안 주키퍼에 하트비트를 전송하지 않는 것도 여기에 해당한다.
	- Ephermeral 노드가 삭제될 경우, 클러스터 안의 다른 브로커들은 주키퍼에 설정된 와치를 통해 컨트롤러가 없어졌다는 것을 알아차리게되며 주키퍼에 컨트롤러 노드를 생성하려고 시도하게 된다. 주키퍼에 가장 먼저 새로운 노드를 생성하는 데 성공한 브로커가 다음 컨트롤러가 된다.
- 브로커는 새로운 컨트롤러가 선출될 때마다 주키퍼의 조건적 증가 연산에 의해 증가된 에포크 값을 전달받게 된다. 브로커는 현재 컨트롤러의 에포크 값을 알고 있기 때문에, 만약 더 낮은 에포크 값을 가진 컨트롤러로부터 메시지를 받을 경우 무시한다.
	- 이것은 컨트롤러 브로커가 오랫동안 가비지 수집 때문에 멈춘 사이 주키퍼 사이의 연결이 끊어질 수 있기 때문에 중요하다.
	- 이전 컨트롤러가 작업을 재개할 경우, 새로운 컨트롤러가 선출되었다는 것을 알지 못한 채 브로커에 메시지를 보낼 수 있다. 이러한 컨트롤러를 좀비라고 부른다. 컨트롤러가 전송하는 메시지에 컨트롤러 에포크를 포함하면 브로커는 예전 컨트롤러가 보내온 메시지를 무시할 수 있다.
	- 에포크는 좀비를 방지하는 방법이기도 하다.
- 브로커가 컨트롤러가 되면, 클러스터 메타데이터 관리와 리더 선출을 시작하기 전에 먼저 주키퍼로부터 최신 레플리카 상태 맵을 비동기로 읽어온다.
- 브로커가 클러스터를 나갔다는 사실을 컨트롤러가 알아차리면, 컨트롤러는 해당 브로커가 리더를 맡고 있었던 모든 파티션에 대해 새로운 브로커를 할당해주게 된다.

### KRaft: 카프카의 새로운 래프트 기반 컨트롤러

- 주키퍼 방식의 카프카는 필요로 하는 파티션 수까지 확장될 수 없는 원인으로 KRaft 로 만들게 되었다.
	- 브로커, 컨트롤러, 주키퍼 간에 메타데이터 불일치가 발생할 수 있다.
		- 컨트롤러가 주키퍼에 메타데이터를 쓰는 작업은 동기적으로 이루어지지만, 브로커 메시지를 보내는 작업은 비동기적으로 이루어진다. 또한, 주키퍼로부터 업데이트를 받는 과정 역시 비동기적으로 이루어지기 때문이다.
	- 컨트롤러가 재시작될 때마다 주키퍼로부터 모든 브로커와 파티션에 대한 메타데이터를 읽어와야 한다. 그러고 나서 이 메타데이터를 모든 브로커로 전송한다. 이는 병목이 된다.
	- 메타데이터 소유권 관련 내부 아키텍처가 그리 좋지 못하다.
	- 주키퍼는 그 자체로 분산 시스템이며, 카프카와 마찬가지로 운영을 위해서는 어느 정도 기반 지식이 있어야 한다. 그렇기 때문에 카프카를 사용하려는 개발자들은 두 개의 분산 시스템에 대해 배워야 한다.
- KRaft의 핵심 아이디어는 카프카 그 자체에 사용자가 상태를 이벤트 스트림으로 나타낼 수 있도록 하는 로그 기반 아키텍처를 도입한다는 점이다.
	- 이러한 표현 방법의 장점은 카프카 커뮤니티에게 익숙한 것이다. 즉, 다수의 컨슈머를 사용해서 이벤트를 replay함으로써 최신 상태를 빠르게 따라잡을 수 있다.
- KRaft에서 컨트롤러 노드들은 메타데이터 이벤트 로그를 관리하는 래프트 쿼럼이 된다.
	- 이 로그는 메타데이터의 변경 내역을 저장한다.
	- 현재 주키퍼에 저장되어 있는 모든 정보들이 여기에 저장될 것이다.
- 메타데이터 로그의 리더 역할을 맡고 있는 컨트롤러는 액티브 컨트롤러라고 부른다.
	- 액티브 컨트롤러는 브로커가 보내온 모든 RPC 호출을 처리한다.
	- 팔로워 컨트롤러들은 액티브 컨트롤러에 쓰여진 데이터를 복제하며, 액티브 컨트롤러에 장애가 발생했을 시에 즉시 투입될 수 잇도록 주비 상태를 유지한다.
	- 이제 모든 컨트롤러들이 모두 최신 상태를 가지고 있으므로, 컨트롤러 장애 복구는 모든 상태를 새 컨트롤러로 이전하는 기나긴 리로드 기간을 필요로 하지 않는다.
- 다른 브로커들이 새로도입된 MetadataFetch API를 사용해서 액티브 컨트롤러로부터 변경 사항을 pull한다.
- 브로커 프로세스는 시작시 주키퍼가 아닌, 컨트롤러 쿼럼에 등록한다.
	- 그리고 운영자가 등록을 해제하지않는 한 이를 유지한다. 따라서 브로커가 종료되면, 오프라인 상태로 들어가는 것일 뿐 등록은 여전히 유지된다.
	- 온라인 상태지만 최신 메타데이터로 최신 메타데이터로 최신 상태를 유지하고 있지는 않은 브로커의 경오 펜스된 상태(fenced state)가 되어 클라이언트 요청을 처리할 수 없다.
	- 브로커에 새로 도입된 펜스된 상태는 클라이언트가 더 이상 리더가 아닌, 하지만 최신 상태에서 너무 떨어지는 바람에 자신이 리더가 아니라는 것조차 인식을 못 하는 브로커에 쓰는 것을 방지한다.
