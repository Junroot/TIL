# 스프링 시큐리티

## 스프링 시큐리티 활성화하기

- 스프링 시큐리티 스타터를 프로젝트 빌드 파일에 추가만 했을 때는 다음의 보안 구성이 제공된다.
	- 모든 HTTP 요청 경로는 인증되어야 한다.
	- 어던 특정 역할이나 권한이 없다.
	- 로그인 페이지가 따로 없다.
	- 스프링 시큐리티의 HTTP 기본 인증을 사용해서 인증된다.
	- 사용자는 하나만 있으며, 이름은 user다. 비밀번호는 암호화해 로그에 남는다.

## 스프링 시큐리티 구성하기

- https://www.baeldung.com/spring-deprecated-websecurityconfigureradapter
- 스프링 시큐리티 configuration

```kotlin
@EnableWebSecurity  
class SecurityConfig {  
  
   @Bean  
   fun filterChain(http: HttpSecurity): SecurityFilterChain {  
      http.authorizeRequests()  
         .antMatchers("/design", "orders")  
         .access("hasRole('ROLE_USER')")  
         .antMatchers("/", "/**").access("permitAll")  
         .and()  
         .httpBasic()  
      return http.build()  
   }  
  
   @Bean  
   fun userDetailService(): UserDetailsService {  
      val user1 = User.builder()  
         .username("user1")  
         .password("{noop}password1")  
         .authorities("ROLE_USER")  
         .build()  
      val user2 = User.builder()  
         .username("user2")  
         .password("{noop}password2")  
         .authorities("ROLE_USER")  
         .build()  
      return InMemoryUserDetailsManager(user1, user2)  
   }  
}
```

- 스프링 시큐리티에서는 여러 가지의 사용자 스토어 구성 방법을 제공한다.
	- 인메모리 사용자 스토어
	- JDBC 기반 사용자 스토어
	- LDAP 기반 사용자 스토어
	- 커스텀 사용자 명세 서비스
- `UserDetailsService`: 사용자 명세를 가져오는 인터페이스
	- `InMemoryUserDetailsManager`: 인메모리 사용자 스토어
	- `password()`: 스프링 5부터는 비밀번호를 반드시 암호화해야된다. 테스트 용도로 위 예제처럼 `{noop}`를 지정하면 비밀번호를 암호화하지 않을 수 있다.
- `SecurityFilterChain`: HTTP 요청에 매칭 시킬 수 있는 필터 체인을 정의한다.
- `HttpSecurity`: HTTP 요청에 대한 웹 기반 보안을 구성할 수 있다.

### 인메모리 사용자 스토어

- 테스트 목적이나 간단한 애플리케이션에는 편리하다.
- 그러나 사용자 정보의 추가나 변경이 쉽지 않다. 사용자의 추가, 삭제, 변경을 해야 한다면 보안 구성 코드를 변경한 후 애플리케이션을 다시 빌드하고 배포, 설치해야 한다.

### JDBC 기반의 사용자 스토어

```kotlin
@Bean  
fun userDetailService(): UserDetailsService {  
   return JdbcUserDetailsManager(dataSource)  
}
```

- 사용자 정보를 찾을 때 스프링 시큐리티의 내부 코드에서 기본적으로 다음 쿼리를 수행한다.
	- `JdbcUserDetailsManager` 클래스 참고

- 사용자 인증 정보 조회 쿼리

```sql
select username,password,enabled 
from users 
where username = ?
```

- 사용자 권한 조회 쿼리

```sql
select username,authority 
from authorities 
where username = ?
```

- 사용자 그룹 권한 조회 쿼리

```sql
select g.id, g.group_name, ga.authority 
from groups g, group_members gm, group_authorities ga 
where gm.username = ? 
	and g.id = ga.group_id 
	and g.id = gm.group_id
```

- 스프링 시큐리티 5 버전부터는 의무적으로 `PasswordEncoder`를 사용해서 비밀번호를 암호해야된다.
- 아래와 같이 스프링 시큐리티의 SQL 쿼리를 우리 SQL 쿼리로 대체할 수 있다.
	- 사용자 정보 인증 쿼리에서는 username, password, enabled 열의 값을 반환해야 한다.
	- 사용자 권한 쿼리에서는 해당 사용자 이름과 부여된 권한을 포함하는 0개 또는 다수의 행을 반환할 수 있다.
	- 그룹 권한 쿼리에서는 각각 그룹 id, 그룹 이름, 권한 열을 갖는 0개 또는 다수의 행을 반환할 수 있다.

```kotlin
@Bean  
fun userDetailService(): UserDetailsService {  
   val jdbcUserDetailsManager = JdbcUserDetailsManager(dataSource)  
   jdbcUserDetailsManager.setUsersByUsernameQuery("select username, password, enabled from users where username=?")  
   jdbcUserDetailsManager.setAuthoritiesByUsernameQuery("select username, authority from authorities where username=?")  
   return jdbcUserDetailsManager  
}
```

- spring security 5부터는 유저마다 다른 패스워드 인코딩 알고리즘을 사용할 수 있도록 했다.
	- 인코딩된 암호 앞에 접두어로 알고리즘을 식별한다.
	- 아래의 예에서는 bcrypt로 인코딩 암호다.

```
{bcrypt}$2b$12$FaLabMRystU4MLAasNOKb.HUElBAabuQdX59RWHq5X.9Ghm692NEi
```

- 암호 해시에 접두어가 없으면 기본 인코더를 사용하도록 설정할 수도 있다.
	- https://www.baeldung.com/spring-security-5-password-storage
	- 설정하지 않으면 접두어가 없으면 예외가 발생한다.
	- 기본 인코더는 `DelegationPasswordEncoder`를 구현해서 빈 등록할 수 있다.
	- `DelegatingPasswordEncoder.setDefaultPasswordEncoderForMatchs()` 메서드를 통해서 등록한다.
	- 따로 빈 등록을 하지않으면 `PasswordEncoderFactories.createDelegatingPasswordEncoder()`를 통해서 생성한다.

```kotlin
@Bean  
fun delegatingPasswordEncoder(): PasswordEncoder {  
   val encodingId = "bcrypt"  
   val encoders: MutableMap<String, PasswordEncoder> = mutableMapOf()  
   encoders[encodingId] = BCryptPasswordEncoder()  
  
   encoders["pbkdf2"] = Pbkdf2PasswordEncoder()  
   encoders["scrypt"] = SCryptPasswordEncoder()  
   encoders["argon2"] = Argon2PasswordEncoder()  
  
   val delegatingPasswordEncoder = DelegatingPasswordEncoder(encodingId, encoders)  
   delegatingPasswordEncoder.setDefaultPasswordEncoderForMatches(CustomPasswordEncoder())  
   return delegatingPasswordEncoder  
}
```

- `PasswordEncoder`를 구현하면 `DelegatingPasswordEncoder`에 인코더나 기본 인코더로 설정할 수 있다.
	- 아래의 예에서는 암호화를 하지 않고 로그를 찍고 있는데, 실제 개발에서는 당연히 이렇게 구현하면 안된다.

```kotlin
class CustomPasswordEncoder : PasswordEncoder {  
  
   companion object: KLogging()  
  
   override fun encode(rawPassword: CharSequence?): String {  
      logger.info { rawPassword }  
      return rawPassword.toString()  
   }  
  
   override fun matches(rawPassword: CharSequence?, encodedPassword: String?): Boolean {  
      return encode(rawPassword) == encodedPassword  
   }  
}
```

### LDAP 기반 사용자 스토어

- 기본적으로 사용자와 그룹 모두의 LDAP 기본 쿼리는 비어 있어서 쿼리에 의한 검색이 LDAP 계층의 루트부터 수행된다.
- `userSearchBase()`, `groupSearchBase()` 메서드를 사용해서 쿼리의 기준점을 지정하여 계층을 변경할 수 있다.
- 비밀번호를 비교하는 방법으로 LDAP 인증을 하고자 할 때는 다음과 같이 `passwordCompare()` 메서드를 호출하면 된다.
- `passwordAttribute()`를 사용해서 비밀번호 속성의 이름을 지정할 수 있다.
- `passwordEncoder()` 메서드를 호출하여 암호화에 사용할 인코더를 지정할 수 있다.

```kotlin
@Autowired  
fun configure(auth: AuthenticationManagerBuilder) {  
   auth.ldapAuthentication()  
      .userSearchBase("ou=people")  
      .userSearchFilter("(uid={0})")  
      .groupSearchBase("ou=groups")  
      .groupSearchFilter("member={0}")  
      .passwordCompare()  
      .passwordEncoder(BCryptPasswordEncoder())  
      .passwordAttribute("userPasscode")  
}
```

- 기본적으로 스프링 시큐리티의 LDAP 인증에서는 로컬 호스트의 33389 포트로 LDAP 서버가 접속된다고 간주한다.
- `contextSource()` 메서드를 사용해서 해당 서버의 위치를 구성할 수 있다.

```kotlin
auth.ldapAuthentication()  
   .userSearchBase("ou=people")  
   .userSearchFilter("(uid={0})")  
   .groupSearchBase("ou=groups")  
   .groupSearchFilter("member={0}")  
   .contextSource()  
      .url("ldap://tacocloud.com:389/dc=tacocloud,dc=com")  
   .and()  
   .passwordCompare()  
      .passwordEncoder(BCryptPasswordEncoder())  
      .passwordAttribute("userPasscode")
```

- LDAP 서버가 시작될 때 classpath에서 LDIF 파일로부터 데이터를 로드한다.
	- LDIF 파일: 일반 텍스트 파일에서 LDAP 데이터를 나타내는 표준화된 방법
	- 각 레코드는 하나 이상의 줄로 구성되며, 각 줄을 한 쌍으로 된 name:value를 포함한다.
	- `ldif()` 메서드를 사용해서 LDIF 파일을 찾을 수 있는 경로를 지정할 수 있다.

```kotlin
@Autowired  
fun configure(auth: AuthenticationManagerBuilder) {  
   auth.ldapAuthentication()  
      .userSearchBase("ou=people")  
      .userSearchFilter("(uid={0})")  
      .groupSearchBase("ou=groups")  
      .groupSearchFilter("member={0}")  
      .contextSource()  
         .url("ldap://localhost:8389/dc=tacocloud,dc=com")  
         .ldif("classpath:users.ldif")  
      .and()  
      .passwordCompare()  
         .passwordEncoder(BCryptPasswordEncoder())  
         .passwordAttribute("userPasscode")  
}
```

### 사용자 인증의 커스터마이징

- `UserDetails`를 구현한 클래스는 기본 사용자 정보를 스프링 시큐리티에 제공한다.

```kotlin
@Entity  
class User(  
   @Id  
   @GeneratedValue(strategy = GenerationType.IDENTITY)  
   val id: Long?,  
   val username: String,  
   val password: String,  
   val fullname: String,  
   val street: String,  
   val city: String,  
   val state: String,  
   val zip: String,  
   val phoneNumber: String  
) : UserDetails {  
  
   companion object {  
      val AUTHORITIES = mutableListOf(SimpleGrantedAuthority("ROLE_USER"))  
   }  
  
   override fun getAuthorities(): MutableCollection<out GrantedAuthority> {  
      return AUTHORITIES  
   }  
  
   override fun getPassword(): String {  
      return password  
   }  
  
   override fun getUsername(): String {  
      return username  
   }  
  
   override fun isAccountNonExpired(): Boolean {  
      return true  
   }  
  
   override fun isAccountNonLocked(): Boolean {  
      return true  
   }  
  
   override fun isCredentialsNonExpired(): Boolean {  
      return true  
   }  
  
   override fun isEnabled(): Boolean {  
      return true  
   }  
}
```

### 사용자 명세 서비스 생성하기

- `UserDetailsService` 인터페이스를 구현한 클래스를 빈으로 등록하면 해당 클래스를 사용자 인증을 위한 클래스로 사용된다.

```kotlin
@Service  
class UserRepositoryUserDetailsService(  
   private val userRepository: UserRepository  
) : UserDetailsService {  
  
   override fun loadUserByUsername(username: String): UserDetails {  
      val user = userRepository.findByUsername(username)  
      if (user != null) {  
         return user  
      }  
      throw UsernameNotFoundException("User '$username' not found")  
   }  
}
```