# 스프링 시큐리티

## 스프링 시큐리티 활성화하기

- 스프링 시큐리티 스타터를 프로젝트 빌드 파일에 추가만 했을 때는 다음의 보안 구성이 제공된다.
	- 모든 HTTP 요청 경로는 인증되어야 한다.
	- 어던 특정 역할이나 권한이 없다.
	- 로그인 페이지가 따로 없다.
	- 스프링 시큐리티의 HTTP 기본 인증을 사용해서 인증된다.
	- 사용자는 하나만 있으며, 이름은 user다. 비밀번호는 암호화해 로그에 남는다.

## 스프링 시큐리티 구성하기

- https://www.baeldung.com/spring-deprecated-websecurityconfigureradapter
- 스프링 시큐리티 configuration

```kotlin
@EnableWebSecurity  
class SecurityConfig {  
  
   @Bean  
   fun filterChain(http: HttpSecurity): SecurityFilterChain {  
      http.authorizeRequests()  
         .antMatchers("/design", "orders")  
         .access("hasRole('ROLE_USER')")  
         .antMatchers("/", "/**").access("permitAll")  
         .and()  
         .httpBasic()  
      return http.build()  
   }  
  
   @Bean  
   fun userDetailService(): UserDetailsService {  
      val user1 = User.builder()  
         .username("user1")  
         .password("{noop}password1")  
         .authorities("ROLE_USER")  
         .build()  
      val user2 = User.builder()  
         .username("user2")  
         .password("{noop}password2")  
         .authorities("ROLE_USER")  
         .build()  
      return InMemoryUserDetailsManager(user1, user2)  
   }  
}
```

- 스프링 시큐리티에서는 여러 가지의 사용자 스토어 구성 방법을 제공한다.
	- 인메모리 사용자 스토어
	- JDBC 기반 사용자 스토어
	- LDAP 기반 사용자 스토어
	- 커스텀 사용자 명세 서비스
- `UserDetailsService`: 사용자 명세를 가져오는 인터페이스
	- `InMemoryUserDetailsManager`: 인메모리 사용자 스토어
	- `password()`: 스프링 5부터는 비밀번호를 반드시 암호화해야된다. 테스트 용도로 위 예제처럼 `{noop}`를 지정하면 비밀번호를 암호화하지 않을 수 있다.
- `SecurityFilterChain`: HTTP 요청에 매칭 시킬 수 있는 필터 체인을 정의한다.
- `HttpSecurity`: HTTP 요청에 대한 웹 기반 보안을 구성할 수 있다.

### 인메모리 사용자 스토어

- 테스트 목적이나 간단한 애플리케이션에는 편리하다.
- 그러나 사용자 정보의 추가나 변경이 쉽지 않다. 사용자의 추가, 삭제, 변경을 해야 한다면 보안 구성 코드를 변경한 후 애플리케이션을 다시 빌드하고 배포, 설치해야 한다.

### JDBC 기반의 사용자 스토어

```kotlin
@Bean  
fun userDetailService(): UserDetailsService {  
   return JdbcUserDetailsManager(dataSource)  
}
```

- 사용자 정보를 찾을 때 스프링 시큐리티의 내부 코드에서 기본적으로 다음 쿼리를 수행한다.
	- `JdbcUserDetailsManager` 클래스 참고

- 사용자 인증 정보 조회 쿼리

```sql
select username,password,enabled 
from users 
where username = ?
```

- 사용자 권한 조회 쿼리

```sql
select username,authority 
from authorities 
where username = ?
```

- 사용자 그룹 권한 조회 쿼리

```sql
select g.id, g.group_name, ga.authority 
from groups g, group_members gm, group_authorities ga 
where gm.username = ? 
	and g.id = ga.group_id 
	and g.id = gm.group_id
```

- 스프링 시큐리티 5 버전부터는 의무적으로 `PasswordEncoder`를 사용해서 비밀번호를 암호해야된다.
- 아래와 같이 스프링 시큐리티의 SQL 쿼리를 우리 SQL 쿼리로 대체할 수 있다.
	- 사용자 정보 인증 쿼리에서는 username, password, enabled 열의 값을 반환해야 한다.
	- 사용자 권한 쿼리에서는 해당 사용자 이름과 부여된 권한을 포함하는 0개 또는 다수의 행을 반환할 수 있다.
	- 그룹 권한 쿼리에서는 각각 그룹 id, 그룹 이름, 권한 열을 갖는 0개 또는 다수의 행을 반환할 수 있다.

```kotlin
@Bean  
fun userDetailService(): UserDetailsService {  
   val jdbcUserDetailsManager = JdbcUserDetailsManager(dataSource)  
   jdbcUserDetailsManager.setUsersByUsernameQuery("select username, password, enabled from users where username=?")  
   jdbcUserDetailsManager.setAuthoritiesByUsernameQuery("select username, authority from authorities where username=?")  
   return jdbcUserDetailsManager  
}
```

- spring security 5부터는 유저마다 다른 패스워드 인코딩 알고리즘을 사용할 수 있도록 했다.
	- 인코딩된 암호 앞에 접두어로 알고리즘을 식별한다.
	- 아래의 예에서는 bcrypt로 인코딩 암호다.

```
{bcrypt}$2b$12$FaLabMRystU4MLAasNOKb.HUElBAabuQdX59RWHq5X.9Ghm692NEi
```

- 암호 해시에 접두어가 없으면 기본 인코더를 사용하도록 설정할 수도 있다.
	- https://www.baeldung.com/spring-security-5-password-storage
	- 설정하지 않으면 접두어가 없으면 예외가 발생한다.
	- 기본 인코더는 `DelegationPasswordEncoder`를 구현해서 빈 등록할 수 있다.
	- `DelegatingPasswordEncoder.setDefaultPasswordEncoderForMatchs()` 메서드를 통해서 등록한다.
	- 따로 빈 등록을 하지않으면 `PasswordEncoderFactories.createDelegatingPasswordEncoder()`를 통해서 생성한다.

```kotlin
@Bean  
fun delegatingPasswordEncoder(): PasswordEncoder {  
   val encodingId = "bcrypt"  
   val encoders: MutableMap<String, PasswordEncoder> = mutableMapOf()  
   encoders[encodingId] = BCryptPasswordEncoder()  
  
   encoders["pbkdf2"] = Pbkdf2PasswordEncoder()  
   encoders["scrypt"] = SCryptPasswordEncoder()  
   encoders["argon2"] = Argon2PasswordEncoder()  
  
   val delegatingPasswordEncoder = DelegatingPasswordEncoder(encodingId, encoders)  
   delegatingPasswordEncoder.setDefaultPasswordEncoderForMatches(CustomPasswordEncoder())  
   return delegatingPasswordEncoder  
}
```

- `PasswordEncoder`를 구현하면 `DelegatingPasswordEncoder`에 인코더나 기본 인코더로 설정할 수 있다.
	- 아래의 예에서는 암호화를 하지 않고 로그를 찍고 있는데, 실제 개발에서는 당연히 이렇게 구현하면 안된다.

```kotlin
class CustomPasswordEncoder : PasswordEncoder {  
  
   companion object: KLogging()  
  
   override fun encode(rawPassword: CharSequence?): String {  
      logger.info { rawPassword }  
      return rawPassword.toString()  
   }  
  
   override fun matches(rawPassword: CharSequence?, encodedPassword: String?): Boolean {  
      return encode(rawPassword) == encodedPassword  
   }  
}
```