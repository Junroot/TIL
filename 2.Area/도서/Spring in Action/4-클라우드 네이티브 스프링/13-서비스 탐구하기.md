# 서비스 탐구하기

## 마이크로서비스 이해하기

- 단일 애플리케이션의 문제점
	- 코드 전체를 파악하기 어렵다.
	- 테스트가 복잡해진다.
	- 라이브러리 간의 충돌이 생기기 쉽다.
	- 확장 시 비효율적이다. 확장 목적으로 더 많은 서버에 애플리케이션을 배포해야 할 때는 애플리케이션의 일부가아닌 전체를 배포해야 한다.
	- 적용할 기술을 결정할 때도 애플리케이션 전체를 고려해야 한다.
	- 프로덕션으로 이양하기 위해 많은 노력이 필요하다. 단일 애플리케이션은 크기와 복잡도 때문에 더 엄격한 개발 프로세스와 테스트가 필요하다.
- 마이크로서비스 아키텍처
	- 코드를 이해하기 쉽다.
	- 테스트가 쉽다.
	- 라이브러리 비호환성 문제가 생기지 않는다.
	- 독자적으로 규모를 조정할 수 있다. 마이크로서비스의 규모가 더 커야 한다면, 다른 마이크로서비스에 영향을 주지 않고 메모리 할당이나 인스턴스의 수를 더 크게 조정할 수 있다.
	- 각 마이크로서비스에 적용할 기술을 다르게 선택할 수 있다.
	- 마이크로서비스는 언제든 프로덕션으로 이양할 수 있다.
- 마이크로서비스 아키텍처는 분산 아키텍처이므로 네트워크 지연과 같은 문제들이 발생할 수 있다.
- 애플리케이션이 상대적으로 작거나 간단하면 단일 애플리케이션으로 재발하는 것이 좋다. 그리고 점차 규모가 커질 때 마이크로서비스 아키텍처로 변경하는 것을 고려할 수 있다.

## 서비스 레지스트리 설정하기

- 서비스 레지스트리: 마이크로서비스가 서로를 찾을 때 사용되는 마이크로서비스
- 유레카: 넷플릭스 오픈 소스인 스프링 서비스 레지스트리
- some-service 인스턴스가 시작될 때 해당 서비스는 자신의 이름을 유레카에 등록한다.
	- 등록되는 인스턴스는 여러개 생성될 수 있고 모두 같은 이름으로 유레카에 등록된다.
	- other-service가 some-service를 사용할 때는 some-service의 호스트 이름과 포트 정보를 하드코딩하지 않고, some-service라는 이름을 유레카에서 찾으면 된다.
	- other-service는 some-service의 어떤 인스턴스를 사용할지 결정해야 된다. 이때 클라이언트 측에서 로드 밸런싱 알고리즘을 적용하는 것이 좋고, 이때 사용할 수 있는 것이 넷플릭스 프로젝트인 리본이다.
	- ![](assets/Pasted%20image%2020230919210713.png)

- 중앙 집중화된 로드 밸런서가 아닌 클라이언트 측의 로드밸런서를 사용하는 이유
	- 각 클라이언트에 하나의 로컬 로드 밸런서가 있으므로 클라이언트의 수에 비례하여 자연스럽게 로드 밸런서의 크기가 조정된다.
	- 서버에 연결된 모든 서비스에 획질적으로 같은 구성을 사용하는 대신, 각 클라이언트에 가장 적합한 로드 밸런싱 알고리즘을 사용하도록 구성할 수 있다.
- 유레카 서버 스타터 의존성
	- ![](assets/Pasted%20image%2020230919211729.png)
	- ![](assets/Pasted%20image%2020230919211735.png)
	- ![](assets/Pasted%20image%2020230919211756.png)
- 부트스트랩 클래스에 `@EnableEurekaServer` 애노테이션을 추가하면 실행가능하다.

```kotlin
@EnableEurekaServer  
@SpringBootApplication  
class ServiceRegistryApplication  
  
fun main(args: Array<String>) {  
    runApplication<ServiceRegistryApplication>(*args)  
}
```

- ![](assets/Pasted%20image%2020230919212332.png)