# 리액티브 API 개발하기

- 스프링 WebFlux: 스프링 5의 새로운 리액티브 웹 프레임워크

## 스프링 WebFlux 사용하기

- 스프링MVC 같은 전형적인 서블릿 기반의 웹 프레임워크는 스레드 블로킹과 다중 스레드로 수행된다.
	- 기본적으로 하나의 요청 당 하나의 스레드가 처리하고, 하나의 스레드 내에서 대부분의 상호 작용이 블록킹된다.
	- ![](assets/Pasted%20image%2020230904210443.png)
- 블로킹 웹 프레임워크는 요청량의 증가에 따른 확장이 어렵다.
	- 처리가 느린 작업 스레드로 인해 스레드 풀로 반환되어 또 다른 요청 처리를 준비하는 데 많은 시간이 걸린다.
- 비동기 웹 프레임워크는 적은 수의 스레드로 더 높은 확장성을 성취한다. 
	- 이벤트 루핑(event looping)이라는 기법을 적용한 프레임워크는 한 스레드당 많은 요청을 처리할 수 있어서 한 연결당 소요 비용이 더 경제적이다.
	- 데이터베이스나 네트워크 작업과 같은 집중적인 작업의 콜백과 요청들은 모두 이벤트로 처리된다.
	- 비용이 드는 작업이 필요할 때 이벤트 루프는 해당 작업이 콜백을 등록하여 병행으로 수행되게하고 다른 이벤트 처리로 넘어간다.
	- ![](assets/Pasted%20image%2020230904204146.png)

### 스프링 WebFlux 개요

- WebFlux는 리액티브 프로그래밍 모델을 스프링 MVC에 억지로 집어넣는 대신에 가능한 많은 것을 스프링 MVC로부터 가져와서 별도의 리액티브 웹 프레임워크를 만들기로 결정했다.
- ![](assets/Pasted%20image%2020230906210559.png)
	- 왼쪽이 스프링 MVC 스택, 오른쪽이 스프링 WebFlux 스택
	- 스프링 WebFlux는 서블릿 API에 연결되지 않으므로 실행하기 위해 서블릿 컨테이너를 필요하지 않는다. 대신에 블로킹이 없는 어떤 웹 컨테이너도 실행될 수 있다.
	- 스프링 MVC 애노테이션들은 WebFlux와 공유된다.
	- RouterFunction은 애노테이션 대신 함수형 프로그래밍 패러다임으로 컨트롤러를 정의하는 대안 프로그래밍 모델이다.
	- WebFlux를 사용할 때는 기본적인 내장 서버가 톰캣 대신 Netty가 된다.
		- Netty는 몇 안되는 비동기적인 이벤트 중심의 서버 중 하나며, 리액티브 웹 프레임워크에 잘 맞는다.
	- 컨트롤러 메서드는 도메인 타입이나 컬렉션 대신 `Mono`나 `Flux`같은 리액티브 타입을 인자로 받거나 반환한다. 또한 `Observable`, `Single`, `Completable` 과 같은 RxJava 타입도 처리할 수 있다.
- 스프링 MVC도 컨트롤러 메서드로 `Mono`나 `Flux`를 반환할 수 있다. 
	- 하지만 WebFlux는 요청이 이벤트 루프로 처리되는 반면,
	- 스프링 MVC는 다중 스레드에 의존하여 다수의 요청을 처리하는 서블릿 기반 웹 프레임워크다.

### 리액티브 컨트롤러 작성하기

- 의존성 추가

```xml
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-webflux</artifactId>  
</dependency>
```

- 아래 사진과 같이 `Flux` 반환 타입을 가진 컨트롤러의 메서드를 추가할 수 있다.
	- ![](assets/Pasted%20image%2020230906212910.png)
	- 이 때 `TacoRepository`는 `ReactiveCrudRepository`를 상속하도록 해야된다.
		- ![](assets/Pasted%20image%2020230906213010.png)
		- ![](assets/Pasted%20image%2020230906220304.png)
	- `@RestController`와 `@GetMapping`을 그대로 사용할 수 있다는 것을 확인할 수 있다.
- 리액티브하게 입력 처리하기
	- ![](assets/Pasted%20image%2020230906221426.png)
	- `saveAll()`메서드는 `Mono`나 `Flux`를 포함해서 리액티브 스트림의 `Publisher` 인터페이스를 구현한 어떤 타입도 인자로받을 수 있다.
	- `saveAll()` 메서드는 `Mono<Taco>`를 입력으로 받으므로 요청 몸체로부터 `Taco` 객체가 분석되는 것을 기다리지 않고 즉시 호출된다. 그리고 리퍼지터리 또한 리액티브이므로 `Mono`를 받아 즉시 `Flux<Taco>`를 반환한다.
	- 이전 Spring MVC의 입력이었을 경우
		- 요청 페이로드가 완전하게 분석되어 `Taco` 객체를 생성하는데 까지 블록킹되고, 리포지토리의 `save()` 메서드의 호출이 끝날 때 까지 블록킹된다.