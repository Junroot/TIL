# 리액터 개요

- 애플리케이션 코드를 개발할 때는 명령형과 리액티브의 두 가지 형태로 코드를 작성할 수 있다.
	- 명령형: 순차적으로 연속된 작업이 있으며, 각 작업은 한 번에 하나씩 그리고 이전 작업 다음에 실행된다.
	- 리액티브: 데이터 처리를 위해 일련의 작업들이 정의되지만, 이 작업들은 병렬로 실행될 수 있다. 그리고 각작업은 부분 집합의 데이터를 처리할 수 있으며, 처리가 끝난 데이터를 다음 작업에 넘겨주고 다른 부분 집합의 데이터로 계속 작업할 수 있다.

## 리액티브 프로그래밍 이해하기

- 명령형 프로그래밍
	- 한 번에 하나씩 만나는순서대로 실행되는 명령어들로 코드를 작성
	- 프로그램에서는 하나의 작업이 완전히 끝나기를 기다렸다가 그당므 작업을 수행한다.
	- 각 단계마다 처리되는 데이터는 전체를 처리할 수 있도록 사용할 수 있어야한다.
	- 하지만 이 작업이 원격지 서버로부터 데이터베이스에 데이터를 쓰거나 가져오는 것이라면 이 작업이 완료될 때까지 아무 것도 할 수 없다.
- 자바를 비롯해서 대부분의 프로그래밍 언어는 동시 프로그래밍을 지원한다.
	- 그러나 다중 스레드로 동시성을 관리하는 것은 복잡해져서 쉽지 않다.
- 리액티브 프로그래밍은 함수적이면서 선언적이다.
	- 순차적으로 수행되는 작업 단계를 나타낸 것이 아니라 데이터가 흘러가는 파이프라인이나 스트림을 포함한다.
	- 리액티브 스트림은 데이터 전체를 사용할 수 있을 때까지 기다리지 않고 사용 가능한 데이터가 있을 때마다 처리되므로 사실상 입력되는 데이터는 무한할 수 있다.

### 리액티브 스트림 정의하기

- 리액티브 스트림은 차단되지 않는 백 프레셔(backpressure)를 갖는 비동기 스트림 처리의 표준을 제공하는 것이 목적이다.
- 자바 스트림 vs. 리액티브 스트림
	- 자바 스트림으 대개 동기화되어 있고 한정된 데이터로 작업을 수행한다.
	- 리액티브 스트림은 무한 데이터셋을 비롯해서 어떤 크기의 데이터셋이건 비동기 처리를 지원한다. 그리고 실시간으로 데이터를 처리하며, 백 프레셔를 사용해서 데이터 전달 폭주를 막는다.
- 리액티브 스트림은 4개의 인터페이스인 `Publisher`, `Subscriber`, `Subscription`, `Processor`로 요약할 수 있다.
- `Publisher`는 하나의 `Subscription`당 하나의 `Subscriber`에 발행하는 데이터는 생성한다.
- `Publisher` 인터페이스에는 `Subscriber`가 `Publisher`를 구독 신청할 수 있는 `subscribe()` 메서드 한 개가 선언되어 있다.
	- ![](assets/Pasted%20image%2020230730181819.png)
- `Subscriber`가 구독 신청되면 `Publisher`로부터 이벤츠를 수신할 수 있다.
	- `Subscriber`가 수신할 첫 번째 이벤트는 `onSubsribe()` 호출을 통해 이루어진다.
	- `Publisher`가 `onSubsribe()`를 호출할 때 이 메서드의 인자로 `Subscription` 객체를 `Subscriber`에 전달한다.
	- `Subscriber`는 `Subscription` 객체를 통해서 구독을 관리할 수 있다.
	- ![](assets/Pasted%20image%2020230730182113.png)
- `Subscriber`는 `Subscription`의 `request()`를 호출하여 전송되는 데이터를 요청하거나, 또는 더 이상 데이터를 수신하지 않고 취소한다는 것을 나타내기 위해 `cancel()`을 호출할 수 있다.
	- `request()`를 호출할 때 `Subscriber`는 받고자 하는 데이터 항목 수를 나타내는 `long` 타입의 값을 인자로 전달한다. 바로 이것이 백 프레셔이며, `Subscriber`가 처리할 수 있는 것보다 더 많은 데이터를 `Publisher`가 전송하는 것을 막아준다.
	- 요청된 수의 데이터를 `Publisher`가 전송한 후에 `Subscriber`는 다시 `request()`를 호출하여 더 많은 요청을 할 수 있다.
	- ![](assets/Pasted%20image%2020230730182525.png)
- `Subscriber`의 데이터 요청이 완료되면 데이터가 스트림을 통해 전달되기 시작한다. 이때 `onNext()` 메서드가 호출되어 `Publisher`가 전송하는 데이터가 `Subscriber`에게 전달되며, 만일 에러가 생길 떄는 `onError()`가 호출된다.
- `Publisher`에서 전송할 데이터가 없고 더 이상의 데이터를 생성하지 않는다면 `Publisher`가 `onComplete()`를 호출하여 작업이 끝났다고 `Subscriber`에게 알려준다.
- `Processor` 인터페이스는 `Subscriber` 인터페이스와 `Publisher` 인터페이스를 결합한 것이다.
	- `Subscriber` 역할로 `Processor`는 데이터를 수신하고 처리한다. 그다음에 역할을 바꾸어 `Publisher` 역할로 처리 결과를 자신의 `Subscriber` 들에게 발행한다.
	- ![](assets/Pasted%20image%2020230730183119.png)
- 리액티브 스트림 인터페이스는 스크림을 구성하는 기능이 없다. 이에 따라 프로젝트 리액터에서는 리액티브 스트림을 구성하는 API를 제공하여 리액티브 스트림 인터페이스를 구현하였다.

## 리액터 시작하기

```kotlin
Mono.just("Craig")  
   .map { n -> n.uppercase() }  
   .map { cn -> "Hello, $cn!" }  
   .subscribe { message -> println(message) }
```

- 위 리액티브 코드는 데이터가 전달되는 파이프라인을 구성하는 것이다.
	- 파이프라인의 각 단계에선느 어떻게 하든 데이터가 변겨오딘다.
	- 각 오퍼레이션은 같은 스레드로 실행되거나 다른 스레드로 실행될 수 있다.
- 리액터의 두 가지 핵심 타입
	- `Flux`: 0, 1 또는 다수의 데이터를 갖는 파이프라인을 나타낸다.
	- `Mono`: 하나의 데이터 항목만 갖는 데이터셋에 최적화된 리액티브 타입이다.
	- 두 타입 모두 리액티브 스트림의 `Publisher` 인터페이스를 구현한 것이다.
	- 위의 예에서는 세 개의 `Mono`가 있으며, `just()` 오퍼레이션은 첫 번째 것을 생성한다.

### 리액티브 플로우의 다이어그램

![](assets/Pasted%20image%2020230730190249.png)

### 리액터 의존성 추가하기

```xml
<dependency>  
   <groupId>io.projectreactor</groupId>  
   <artifactId>reactor-core</artifactId>  
</dependency>  
  
<dependency>  
   <groupId>io.projectreactor</groupId>  
   <artifactId>reactor-test</artifactId>  
</dependency>
```