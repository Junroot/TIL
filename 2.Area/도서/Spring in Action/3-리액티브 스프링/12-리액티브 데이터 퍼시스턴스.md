# 리액티브 데이터 퍼시스턴스

- 컨트롤러부터 데이터베이스에 이르기까지 데이터의 전체 플로우가 리액티브하고 블로킹되지 않는 것이 중요하다.
- 만일 블로킹되는 리퍼지터리에 의존하는 스프링 WebFlux 리액티브 컨트롤러를 작성한다면, 이 컨트롤러는 해당 리퍼지터리의 데이터 생성을 기다리느라 블로킹될 것이다.

## 스프링 데이터 리액티브 개념 이해하기

- 현재는 카산드라, 몽고DB, 카우치베이스, 레디스로 데이터를 저장할 때 리액티브 프로그래밍 모델을 지원한다.
- 관계현 데이터베이스나 JPA는 리액티브 리퍼지터리가 지원되지 않는다.
	- 스프링 데이터 JPA로 리액티브 프로그래밍 모델을 지원하려면 관계형 데이터베이스와 JDBC 드라이버 역시 블로킹되지 않는 리액티브 모델을 지원해야 한다.

### 스프링 데이터 리액티브 개요

- 스프링 데이터 리액티브의 리퍼지터리는 도메인 타입이나 컬렉션 대신 `Mono`나 `Flux`를 인자로 받거나 반환하는 메서드를 갖는다.

```java
Flux<Ingredient> findByType(Ingredient.Type Type);
Flux<Taco> saveAll(Publisher<Taco> tacoPublisher);
```

### 리액티브와 리액티브가 아닌 타입 간의 변환

- 데이터베이스가 리액티브를 지원하지 않는 경우라도 블로킹 되는 방식으로 가져와서 가능한 빨리 리액티브 타입으로 변환하여 상위 컴포넌트들이 리액티브의 장점을 활용하게 할 수 있다.

- 조회 예시

```java
List<Order> orders = repo.findByUser(someUser);
Flux<Order> orderFlux = Flux.fromIterable(orders);

Order order = repo.findById(id);
Mono<Order> orderMono = Mono.just(order);
```

- 저장 예시

```java
Taco taco = tacoMono.block();
tacoRepo.save(taco);

Iterable<Taco> tacos =tacoFlux.toIterable();
tacoRepo.saveAll(tacos);
```

- 더 리액티한 방법: 구독하면서 발행되는 요소 각각에 원하는 오퍼레이션을 수행하는 방법

```java
tacoFlux.subscribe(taco -> {
	tacoRepo.save(taco);
});
```

## 리액티브 카산드라 리퍼지터리 사용하기

- 카산드라: 분산처리, 고성능, 상시 가용, 궁극적인 일관성을 갖는 NoSQL 데이버베이스
	- 데이터를 테이블에 저장된 행으로 처리
	- 한 노드가 모든 데이터를 갖지는 않지만, 특정 행은 다수의 노드에 걸쳐 복제될 수 있으므로 단일 장애점을 없애준다.

### 스프링 데이터 카산드라 활성화하기

