# 목과 테스트 취약성

## 목과 스텁 구분

### 테스트 대역 유형

- 목: 외부로 나가는 상호 작용을 ***모방***하고 ***검사***한다. 이러한 상호 작용은 SUT가 상태를 변경하기 위한(사이드 이펙트가 있는) 의존성을 호출하는 것에 해당한다.
	- 목과 스파이로 분류할 수 있다. 스파이는 수동으로 작성하는 반면, 목은 목 프레임워크의 도움을 받아 생성한다.
- 스텁: 내부로 들어오는 상호 작용을 ***모방***한다. 이러한 상호 작용은 SUT가 입력 데이터를 얻기 위한 의존성을 호출하는 것에 해당한다.
	- 스텁, 더미, 페이크로 분류할 수 있다.
	- 더미: 널값이나 가짜 문자열과 같이 단순하고 하드코딩된 값이다.
	- 스텁: 시나리오마다 다른 값을 반환하게끔 구성할 수 있도록 필요한 것을 다 갖춘 완전한 의존성이다.
	- 페이크: 대다수의 목적은 스텁과 같다. 아직 존재하지 않는 의존성을 대체하고자 구현하는 생성에 대한 차이점이 있다.

### 도구로서의 목과 테스트 대역으로서의 목

- 도구로서의 목: 목 라이브러리의 클래스. 
- 도구로서의 목은 목과 스텁 두 가지 유형의 테스트 대역을 생성할 수 있다.

### 스텁으로 상호 작용을 검증하지 말라

- 스텁과의 상호 작용을 검증하는 것은 취약한 세트를 야기하는 일반적인 안티 패턴이다.
- 테스트에서 거짓 양성을 피하고 리팩터링 내성을 향상시키는 방법은 구현 세부 사항이 아니라 최종 결과를 검증하는 것뿐이다.
	- 최종 결과는 이상적으로 비개발자들에게 의미가 있어야한다.
- 스텁에서 내부로 들어오는 상호 작용은 SUT가 실제 결과를 생성하기 위한 구현 세부 사항이다.
- 최종 결과가 아닌 사항을 검증하는 관행을 과잉 명세라고 부른다.
- 또한 목을 쓰는 경우에도 항상 테스트 취약성을 초래하는 것은 아니지만, 대다수는 그렇다.

### 목과 스텁 함께 쓰기

- 때로는 목과 스텁의 특성을 모두 나타내는 테스트 대역을 만들 필요가 있다.
- 테스트 대역은 목이면서 스텁이지만, 여전히 목이라고 부른다. 목이라는 사실이 스텁이라는 사실보다 더 중요하기 때문이다.

### 목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?

- 목과 스텁의 개념은 명령 조회 분리(CQS, Command Query Separation) 원칙과 관련이 있다.
- CQRS는 CQS에서 확장된 개념이다. CQS는 메서드 단위에서 분리하는 반면, CQRS는 객체나 시스템 단위에서 분리하는 점이 다르다.
- CQS 원칙에 따르면 모든 메서드는 명령이거나 조회여야 하며, 이 둘을 혼용해서는 안된다.
	- 명령은 사이드 이펙트를 일으키고 반환 값이 없다.
	- 조회는 사이드 이페그가 없고 반환 값이 있다.
- 항상 CQS 원칙을 따를 수있는 것은 아니다. (예: `stack.Pop()`)

## 식별할 수 있는 동작과 구현 세부 사항

- 테스트에 거짓 양성이 있는 주요 이유는 코드의 구현 세부 사항과 결합돼 있기 때문이다.
	- 이러한 강결합을 피하는 방법은 코드가 생성한느 최종 결과를 검증하고 구현 세부 사항과 테스트를 가능한 한 떨어뜨리는 것뿐이다.

### 식별할 수 있는 동작은 공개 API와 다르다

- 모든 제품 코드는 2차원으로 분류할 수 있다.
	- 공개 API 또는 비공개 API
	- 식별할 수 있는 동작 또는 구현 세부 사항
- 코드가 시스템의 식별할 수 있는 동작이려면 다음 중 하나를 해야 한다.
	- 클라이언트가 목표를 달성하는 데 도움이 되는 연산을 노출하라. 연산은 계산을 수행하거나 사이드 이펙트를 초래하거나 둘 다 하는 메서드다.
	- 클라이언트가 목표를 달성하는 데 도움이 되는 상태를 노출하라. 상태는 시스템의 현재 상태다.
- 클라이언트는 동일한 코드베이스, 외부 애플리케이션, 사용자 인터페이스 등의 클라이언트 코드가 있다.
- 구현 세부 사항은 이 두 가지 중 아무것도 하지 않는다.
- 이상적으로 시스템의 공개 API는 식별할 수 있는 동작과 일치해야 하며, 모든 구현 세부 사항은 클라이언트 눈에 보이지 않아야 한다.
- 그러나 종종 시스템의 공개 API가 식별할 수 있는 동작의 범위를 넘어 구현 세부 사항을 노출하기 시작한다. 이러한 시스템의 구현 세부 사항은 공개 API로 유출된다.

### 구현 세부 사항 유출: 연산의 예

- 클라이언트가 목표를 달성하는 데 도움이 되는 작업을 노출하라.
- 클라이언트가 목표를 달성하는 데 도움이 되는 상태를 노출하라.
- 단일한 목표를 달성하고자 클래스에서 호출해야 하는 연산의 수가 1보다 크면 해당 클래스에서 구현 세부 사항을 유출할 가능성이 있다.