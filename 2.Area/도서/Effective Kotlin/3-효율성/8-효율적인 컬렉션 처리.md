# 효율적인 컬렉션 처리

## 하나 이상의 처리 단계를 가진 경우에는 스퀀스를 사용하라

- 시퀀스 처리 함수들을 사용하면, 데코레이터 패턴으로 꾸며진 새로운 시퀀스가 리턴된다.
- 컬렉션 처리 연산은 호출할 때 연산이 이루어지는 반면, 시퀀스 처리 함수는 최종 연산이 이루어지기 전까지는 각 단계에서 연산이 일어나지 않는다.
- 시퀀스의 지연 처리 장점
	- 자연스러운 처리 순서를 유지한다.
	- 최소한만 연산한다.
	- 무한 시퀀스 형태로 사용할 수 있다.
	- 각각의 단계에서 컬렉션을 만들어 내지 않는다.

### 순서의 중요성

- 시퀀스 처리는 요소 하나하나에 지정한 연산을 한꺼번에 적용한다.
	- element-by-element order 또는 lazy order라고 부른다.
- 이터러블은 요소 전체를 대상으로 연산을 차근차근 적용해 나간다.
	- step-by-step order 또는 eager order라고 부른다.
- 컬렉션 처리 함수를 사용하지 않고, 고전적인 반복문과 조건문을 활용해서 구현한다면, 시퀀스 처리인 element-by-element order와 같다.
	- 따라서 시퀀스 처리에서 사용되는 element-by-element order가 훨씬 자연스러운 처리다.

### 최소 연산

- 컬렉션에 어떤 처리를 적용하고, 앞의 요소 10개만 필요한 상황은 굉장히 자주 접할 수 있는 상황이다.
- 이터러블 처리는 기본적으로 중간 연산이라는 개념이 없으므로, 원하는 처리를 컬렉션 전체에 적용한 뒤, 앞의 요소 10개를 사용해야 한다.
- 시퀀스는 중간 연산이라는 개념을 갖고 있으므로, 앞의 요소 10개에만 원하는 처리를 적용할 수 있다.

### 무한 시퀀스

- 무한 시퀀스를 만들고, 필요한 부분까지만 값을 추출하는 것도 가능하다.
- `generateSequence`를 사용하는 방법
	- `generateSequence`는 '첫 번째 요소'와 '그 다음 요소를 계산하는 방법'을 지정해야 한다.
	- ![](assets/Pasted%20image%2020230711112714.png)
- `sequence`를 사용하는 방법
	- `sequence`는 중단 함수로 요소들을 지정한다.
	- 시퀀스 빌더는 중단 함수 내부에서 `yield`로 값을 하나씩 만들어 낸다.
	- ![](assets/Pasted%20image%2020230711113247.png)
- 무한 시퀀스를 실제로 사용할 떄는 값을 몇 개 사용할지 지정해야 한다.
	- `take`, `first`, `find`, `any`, `all`, `none`, `indexOf` 등

### 각각의 단계에서 컬렉션을 만들어 내지 않음

- 처리 단계가 많아지고 큰 컬렉션이면, 컬렉션 처리보다는 시퀀스 처리를 사용하는 것이 좋다.
	- 컬렉션 처리는 각 단계에서 결과를 만들어서 메모리를 많이 사용한다.
	- 코드 실행 성능도 향상된다.