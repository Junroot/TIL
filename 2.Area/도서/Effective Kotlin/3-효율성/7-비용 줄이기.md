# 비용 줄이기

- 최적화를 초기 단계에서부터 하는 것은 얻는 것보다 잃는 것이 많은 경우가 많다.
- 가독성과 성능 사이에서 트레이드 오프가 발생할 때, 개발하는 컴포넌트에서 무엇이 더 중요한지 스스로 답할 수 있어야 한다.

## 불필요한 객체 생성을 피하라

- 객체 생성은 언제나 비용이 들어간다.
- JVM에서는 하나의 가상 머신에서 동일한 문자열을 처리하는 코드가 여러개 있다면, 기존의 문자열을 재사용한다.
- `Integer`나 `Long`처럼 박스화한 기본 자료형도 작은 경우에는 재사용한다. (기본적으로 `Int`는 -128~127 범위를 캐시해 둔다.)

### 객체 생성 비용은 항상 클까?

- 객체를 wrap하면 더 많은 용량을 차지한다.
	- 64비트 JDK 기준: 헤더(12바이트) + 객체에 대한 레퍼런스 공간(-Xmx32G까지는 4바이트, -Xmx32G부터는 8바이트)
	- 5배 이상의 공간을 차지할 수 있다.
- 요소가 캡슐화되어 있다면, 접근에 추가적인 함수 호출이 필요하다.
	- 처리속도가 빠르지만, 티끌 모아 태산이 발생할 수 있다.
- 객체가 생성되고, 메모리 영역에 할당되고, 이에 대한 레퍼런스를 만드는 등의 작업이 필요하다. 적은 비용이지만, 모이면 큰 비용이 된다.

### 객체 선언

- 매 순간 객체를 생성하지 않고, 객체를 재사용하는 간단한 방법은 객체 선언(싱글톤)을 사용하는 것이다.
	- ![](../1-좋은%20코드/assets/Pasted%20image%2020230621112152.png)

### 캐시를 활용하는 팩토리 함수

- 팩토리 함수는 캐시를 가질 수 있다.
	- 팩토리 함수는 항상 같은 객체를 리턴하게 만들 수도 있다.
- 모든 순수 함수는 캐싱을 활용할 수 있다.(메모이제이션)
- 단점: 캐시를 위한 `Map`을 젖아해야 하므로, 더 많은 메모리를 사용한다.
	- 메모리가 필요할 때 GC가 자동으로 메모리를 해제해 주는 `SoftReference`를 사용하면 더 좋다.
	- `WeakReference`: GC가 값을 정리하는 것을 막지 안흔다. 따라서 다른 레퍼런스가 이를 사용하지 않으면 곧바로 제거한다.
	- `SoftReference`: GC가 값을 정리할 수도 있고, 정리 하지 않을 수도 있다. 일반적인 JVM 구현으 ㅣ경우, 메모리가 부족해서 추가로 필요한 경우에만 정리한다.

> SoftReference를 이용해 캐싱을 구현한 예시: https://o7planning.org/13695/java-softreference#a64445222

### 무거운 객체를 외부 스코프로 보내기

- 연산을 외부로 추출해서 값 계산을 추가로 하지 않게 만든다.
	- ![](../1-좋은%20코드/assets/Pasted%20image%2020230622103637.png)
- 아래의 예시도 함수를 사용할 때마다 `Regex` 객체를 계속해서 새로 만들어서, 성능적으로 문제를 일으킨다.
	- ![](../1-좋은%20코드/assets/Pasted%20image%2020230622103733.png)
- 정규 표현식을 톱레벨로 보내서 문제를 해결한다.
	- ![](../1-좋은%20코드/assets/Pasted%20image%2020230622103753.png)

### 지연 초기화

- 무거운 클래스를 만들 때는 지연되게 만드는 것이 좋다.
	- ![](../1-좋은%20코드/assets/Pasted%20image%2020230622104014.png)
- 지연 초기화의 단점: 클래스가 무거운 객체를 가졌지만, 메서드의 호출은 빨라야 하는 경우에 불리하다. 첫 호출 때 응답 시간이 굉장히 길어진다.

### 기본 자료형 사용하기

- 코틀린/JVM 컴파일러에서 wrap한 자료형이 사용되는 경우
	- nullable 타입을 연산할 때
	- 타입을 제네릭으로 사용할 때
- 숫자에 대한 작업이 여러 번 반복될 때만 의미가 있다.
- 성능이 그렇게까지 중요하지 않은 코드에서는 큰 의미가 없는 최적화다. 다만 라이브러리를 구현한다면, 성능이 중요할 수 있다.