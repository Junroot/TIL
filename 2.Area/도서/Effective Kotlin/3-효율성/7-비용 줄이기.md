# 비용 줄이기

- 최적화를 초기 단계에서부터 하는 것은 얻는 것보다 잃는 것이 많은 경우가 많다.
- 가독성과 성능 사이에서 트레이드 오프가 발생할 때, 개발하는 컴포넌트에서 무엇이 더 중요한지 스스로 답할 수 있어야 한다.

## 불필요한 객체 생성을 피하라

- 객체 생성은 언제나 비용이 들어간다.
- JVM에서는 하나의 가상 머신에서 동일한 문자열을 처리하는 코드가 여러개 있다면, 기존의 문자열을 재사용한다.
- `Integer`나 `Long`처럼 박스화한 기본 자료형도 작은 경우에는 재사용한다. (기본적으로 `Int`는 -128~127 범위를 캐시해 둔다.)

### 객체 생성 비용은 항상 클까?

- 객체를 wrap하면 더 많은 용량을 차지한다.
	- 64비트 JDK 기준: 헤더(12바이트) + 객체에 대한 레퍼런스 공간(-Xmx32G까지는 4바이트, -Xmx32G부터는 8바이트)
	- 5배 이상의 공간을 차지할 수 있다.
- 요소가 캡슐화되어 있다면, 접근에 추가적인 함수 호출이 필요하다.
	- 처리속도가 빠르지만, 티끌 모아 태산이 발생할 수 있다.
- 객체가 생성되고, 메모리 영역에 할당되고, 이에 대한 레퍼런스를 만드는 등의 작업이 필요하다. 적은 비용이지만, 모이면 큰 비용이 된다.

### 객체 선언

- 매 순간 객체를 생성하지 않고, 객체를 재사용하는 간단한 방법은 객체 선언(싱글톤)을 사용하는 것이다.
	- ![](../1-좋은%20코드/assets/Pasted%20image%2020230621112152.png)

### 캐시를 활용하는 팩토리 함수

- 팩토리 함수는 캐시를 가질 수 있다.
	- 팩토리 함수는 항상 같은 객체를 리턴하게 만들 수도 있다.
- 모든 순수 함수는 캐싱을 활용할 수 있다.(메모이제이션)
- 단점: 캐시를 위한 `Map`을 젖아해야 하므로, 더 많은 메모리를 사용한다.
	- 메모리가 필요할 때 GC가 자동으로 메모리를 해제해 주는 `SoftReference`를 사용하면 더 좋다.
	- `WeakReference`: GC가 값을 정리하는 것을 막지 안흔다. 따라서 다른 레퍼런스가 이를 사용하지 않으면 곧바로 제거한다.
	- `SoftReference`: GC가 값을 정리할 수도 있고, 정리 하지 않을 수도 있다. 일반적인 JVM 구현으 ㅣ경우, 메모리가 부족해서 추가로 필요한 경우에만 정리한다.

> SoftReference를 이용해 캐싱을 구현한 예시: https://o7planning.org/13695/java-softreference#a64445222

### 무거운 객체를 외부 스코프로 보내기

- 연산을 외부로 추출해서 값 계산을 추가로 하지 않게 만든다.
	- ![](../1-좋은%20코드/assets/Pasted%20image%2020230622103637.png)
- 아래의 예시도 함수를 사용할 때마다 `Regex` 객체를 계속해서 새로 만들어서, 성능적으로 문제를 일으킨다.
	- ![](../1-좋은%20코드/assets/Pasted%20image%2020230622103733.png)
- 정규 표현식을 톱레벨로 보내서 문제를 해결한다.
	- ![](../1-좋은%20코드/assets/Pasted%20image%2020230622103753.png)

### 지연 초기화

- 무거운 클래스를 만들 때는 지연되게 만드는 것이 좋다.
	- ![](../1-좋은%20코드/assets/Pasted%20image%2020230622104014.png)
- 지연 초기화의 단점: 클래스가 무거운 객체를 가졌지만, 메서드의 호출은 빨라야 하는 경우에 불리하다. 첫 호출 때 응답 시간이 굉장히 길어진다.

### 기본 자료형 사용하기

- 코틀린/JVM 컴파일러에서 wrap한 자료형이 사용되는 경우
	- nullable 타입을 연산할 때
	- 타입을 제네릭으로 사용할 때
- 숫자에 대한 작업이 여러 번 반복될 때만 의미가 있다.
- 성능이 그렇게까지 중요하지 않은 코드에서는 큰 의미가 없는 최적화다. 다만 라이브러리를 구현한다면, 성능이 중요할 수 있다.

## 함수 타입 파라미터를 갖는 함수에 inline 한정자를 붙여라

- `inline` 한정자는 컴파일 시점에 '함수를 호출하는 부분'을 '함수의 본문'으로 대체한다.
- `inline` 한정자를 사용하면, 얻는 장점
	- 타입 아규먼트에 `reified` 한정자를 붙여서 사용할 수 있다.
	- 함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작한다.
	- 비직역 리턴을 사용할 수 있다.

### 타입 아규먼트를 reified로 사용할 수 있다

- JVM 바이트 코드에는 제네릭이 존재하지 않다.
	- 구버전의 자바에는 제네릭이 없기 때문이다.
	- 따라서 컴파일 하면, 제네릭 타입과 관련된 내용이 제거 된다.
	- ![](assets/Pasted%20image%2020230703183559.png)
- 함수를 인라인으로 만들면, 함수 호출이 본문으로 대체되므로, `reified`한정자를 지정하면 타입 파라미터를 사용한 부분이 타입 아규먼트로 대체된다.
	- ![](assets/Pasted%20image%2020230703183658.png)

### 함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작한다

- `inline` 한정자를 붙이면 함수 호출과 리턴을 위해 점프하는 과정과 백스택을 추적하는 과정이 없기 때문에 조금 더 빠르다.
	- 코틀린/JVM에서는 함수 타입 파라미터를 JVM 익명 클래스 또는 일반 클래스를 기반으로 객체로 만들어 낸다.
		- `()->Unit`은 `Function0<Unit>`로 컴파일
		- `()->Int`는 `Function0<Int>`로 컴파일
		- `(Int)->Int`는 `Function1<Int, Int>`로 컴파일
		- `(Int, Int)->Int`는 `Function2<Int, Int, Int>`로 컴파일
	- 함수 본문을 객체로 wrap하면, 코드의 속도가 더 느려진다.
- `inline` 한정자를 붙이면 함수 리터럴 내부에서 지역 변수를 캡처할 때, 객체로 wrapping할 필요가 없어서 더 빠르다.
	- `inline`을 사용하지 않으면, 컴파일 과정 중에 지역 변수를 캡처하기 위해서 레퍼런스 객체로 wrapping 된다. 아래 사진이 관련된 코드다.
	- ![](assets/Pasted%20image%2020230703185646.png)
- 일반적으로 함수 타입의 파라미터가 어떤 식으로 동작하는지 이해하기 어려우므로, 함수 타입 파라미터를 활용해서 유틸리티 함수를 만들 때는 그냥 인라인을 붙여 준다 생각해도 좋다.