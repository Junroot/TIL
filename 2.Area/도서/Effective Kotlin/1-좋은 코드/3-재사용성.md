# 재사용성

## knowledge를 반복해서 사용하지 말라

- 프로젝트에세 이미 있던 코드를 복사해서 붙여넣고 있다면, 무언가가 잘못된 것이다.

### knowledge

- knowledge: 의도적인 정보
- 프로젝트를 진행할 때 정의한 모든 것
- 알고리즘의 작동 방식, UI의 형태, 우리가 원하는 결과 등
- knowledge는 코드, 설정, 템플릿 등으로 표현할 수 있다.
- 프로그램에서 중요한 knowledge 두 가지
	- 로직: 프로그램이 어떤 식으로 동작하는지와 프로그램이 어떻게 보이는지
	- 공통 알고리즘: 원하는 동작을 하기 위한 알고리즘
- 비즈니스 로직은 시간이 지나면서 계속해서 변하지만, 공통 알고리즘은 한 번 정의된 이후에는 크게 변하지 않는다.

### 모든 것은 변화한다

- 변화하는 이유
	- 회사가 사용자의 요구 또는 습관을 더 많이 알게 되었다.
	- 디자인 표준이 변화했다.
	- 플랫폼, 라이브러리, 도구 등이 변화해서 이에 대응해야 한다.
- 오늘날 대부분의 프로젝트는 몇 달마다 요구 사항과 내부적인 구조를 계속해서 변경한다.
- 변화할 때 가장 큰 적은 knowledge가 반복되어 있는 부분이다.
	- 여러 부분에 반복되 어있는 코드를 변경하려면 검색 중 실수가 발생할 수도 있고, 무엇보다 귀찮다.
	- 또한 일부가 과거에 약간 다른 반식으로 이미 변경되어 있을 수 있다.
- knowledge 반복은 피로젝트의 확장성을 막고, 쉽게 깨지게 만든다.

### 언제 코드를 반복해도 될까?

- 얼핏보면 knowledge 반복처럼 보이지만 ,실질적으로 다른 knowledge를 나타내므로 추출하면 안되는 부분은 반복을 줄이면 안된다.
- 다른 knowledge를 나타내는지는 "함께 변경될 가능서이 높은가? 따로 변경될 가능성이 높은가?"라는 질문으로 결졍할 수 있다.
- 비즈니스 규칙이 다른 곳(source)에서 왔다면, 독립적으로 변경될 가능성이 높다.

### 단일 책임 원칙

- 잘못된 코드 추출로부터 우리를 보호할 수 있는 규칙
- 두 액터가 같은 클래스를 변경하는 일은 없어야 한다.
- 개발자는 수정해야할 함수가 자신이 해야 하는 일 이외의 책임을 갖고 있을 거라는 것은 예측하지 못할 수 있다.
- 책임에 따라 클래스를 구분해서 만들어야한다.
- 또는, 확장 함수를 활용하여 서로 다른 모듈에 배치할 수 있다.
- 단일 책임 원칙은 두 가지 사실을 알려준다.
	- 서로 다른 곳에서 사용하는 knowledge는 독립적으로 변경할 가능성이 많다. 따라서 비슷한 처리를 하더라도, 완전히 다른 knowledge로 취급하는 것이 좋다.
	- 다른 knowledge는 분리해 두는 것이 좋다. 그렇지 않으면, 재사용해서는 안 되는 부분을 재사용하려는 유혹이 발생할 수 있다.

## 일반적인 알고리즘을 반복해서 구현하지 말라

- 이미 있는 것을 활용하면, 단순하게 코드가 짧아진다는 것이외에도 다양한 장점이 있다.
	- 코드 작성 속도가 빨라진다.
	- 구현을 따로 읽지 않아도, 함수의 이름 등만 보고도 무엇을 하는지 확실하게 알 수 있다.
	- 직접 구현할 때 발생할 수 있는 실수를 줄일 수 있다.
	- 제작자들이 한 번만 최적화하면, 이러한 함수를 활용하는 모든 곳이 최적화의 혜택을 받을 수 있다.


### 표준 라이브러리 살펴보기

- 가장 대표적인 라이브러리는 표준 라이브러리인 stdlib이다.
- `map` 함수
- 자바빈 패턴을 사용하는 것보다는 팩토리 메서드를 활용하거나, 기본 생성자를 활용하는 것이 좋다.

> 자바빈 패턴: 인자 없는 생성자를 호출하여 기본 객체를 만든 다음, 세터를 이용하여 필드 값을 채워나가는 패턴
> 단점1: 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로, 객체 일관성이 일시적으로 깨질 수 있다.
> 단점2: 불변 객체로 만들 수 없다.
> 자바빈 패턴을 대신 빌더 패턴이나, kotlin의 기본 값이 있는 생성자를 이용하는 것이 좋다.

### 나만의 유틸리티 구현하기

- 표준 라이브러리에 없는 알고리즘이 필요할 수도 있다.
- 이는 널리 알려진 추상화이므로 범용 유틸리티 함수로 정의하는 것이 좋다.
- 많이 사용되는 알고리즘을 추출하는 방법
	- 확장 함수
	- 톱레벨 함수
	- 프로퍼티 위임
	- 클래스
- 확장 함수가 다른 방법들과 비교해서 갖는 장점
	- 함수는 상태를 유지하지 않으므로, 행위를 나타내기 좋다.
	- 톱레벨 함수와 비교해서, 확장 함수는 구체적인 타입이 있는 객체에만 사용을 제한할 수 있다.
	- 수정할 객체를 아규먼트로 전달받아 사용하는 것보다는 확장 리시버로 사용하는 것이 가독성 측면에서 좋다.
	- 확장 함수는 객체에 정의한 함수보다 객체를 사용할 때, 자동 완성 기능 등으로 제안이 이루어지므로 쉽게 찾을 수 있다.