# 객체 생성

## 생성자 대신 팩토리 함수를 사용하라

- 팩토리 함수: 생성자 역할을 대신 해주는 함수
- 팩토리 함수의 장점
	- 생성자와 다르게, 함수에 이름을 붙일 수 있다.
	- 생성자와 다르게, 함수가 원하는 형태의 타입을 리턴할 수 있다. 또한 인터페이스 뒤에 실제 객체의 구현을 숨길 수 있다.
	- 생성자와 다르게, 호출될 때마다 새 객체를 만들 필요가 없다.
		- 싱글턴 패턴, 캐싱 메커니즘
	- 팩토리 함수는 아직 존재하지 않는 객체를 리턴할 수도 있다.
	- 객체 외부에 팩토리 함수를 만들면, 그 가시성을 원하는 대로 제어할 수 있다.
	- 팩토리 함수는 인라인으로 만들 수 있으며, 그 파라미터들을 reified로 만들 수 있다.
	- 팩토리 함수는 생성자로 만들기 복잡한 객체도 만들어 낼 수 있다.
	- 팩토리 함수를 사용하면, 즉시 기본 생성자를 호출할 필요가 없어진다.
- 상속 관계에서 슈퍼클래스의 생성자가 필요한 경우
	- 슈퍼클래스도 팩토리 함수를 만들어서 사용해야된다.

### Companion 객체 팩토리 함수

- companion 객체를 사용하는 방법

```kotlin
class MyLinkedList<T>(  
   val head: T,  
   val tail: MyLinkedList<T>?  
) {  
   companion object {  
      fun <T> of(vararg elements: T): MyLinkedList<T> {  
         /* */  
      }  
   }  
}
```

- 이름을 가진 생성자라고 부른다.
- 이름 규칙
	- `from`: 파라미터를 하나 받고, 같은 타입의 인스턴스 하나를 리턴
	- `of`: 파라미터를 여러 개 받고, 이를 통합해서 인스턴스를 만들어주는 함수
	- `valueOf`: `from` 또는 `of`와 비슷한 기능을 하면서도, 의미를 좀 더 쉽게 읽을 수 있게 이름을 붙인 함수
	- `instance` 또는 `getInstance`: 싱글턴으로 인스턴스 하나를 리턴
	- `createInstance` 또는 `newInstance`: 싱글턴이 적용되지 않아서, 함수를 호출할 때 마다 새로운 인스턴스를 만들어서 리턴한다.
	- `getType`: `getInstance` 처럼 동작하지만, 팩토리 함수가 다른 클래스에 있다.
	- `newType`: `newInstnace`처럼 동작하지만, 팩토리 함수가 달느 클래스에 있을 때 사용한다.
- compoanion 객체는 인터페이스를 구현할 수 있다.
- companion 객체 팩토리는 값을 가질 수 있다.
	- 캐싱이나, 테스트를 위한 가짜 객체 생성을 할 수 있다.

### 확장 팩토리 함수

- 다른 파일에 함수를 만들어야 하는 경우 상요할 수 있다.
- 팩토리 메서드를 확장하려면 적어도 비어이는 컴패니언 객체가 필요하다.

```kotlin
fun Tool.Companion.createBigTool() : BigTool {  
   // ...  
}  
  
interface Tool {  
   companion object  
}
```