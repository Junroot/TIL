# 클래스 설계

## 상속보다는 컴포지션을 사용하라

### 간단한 행위 재사용

- 재사용을 위해 상속을 사용했을 때 단점
	- 상속은 하나의 클래스만을 대상으로 할 수 있다. 상속을 사용해서 행위를 추출하다 보면, 많은 함수를 갖는 거대한 BaseXXX 클래스를 만들게 되고, 굉장히 깊고 복잡한 계층 구조가 만들어진다.
	- 상속은 클래스의 모든 것을 가져오게 된다. 따라서 불필요한 함수를 갖는 클래스가 만들어질 수 있다.
		- 인터페이스 분리 원칙 위반
	- 상속은 이해하기 어렵다. 작동 방식을 이해하기 위해 슈퍼클래스를 여러 번 확인해야 한다.
- 재사용을 위해 컴포지션을 사용했을 때 장점
	- 코드의 실행을 더 명확하게 예측할 수 있다.
	- 하나의 클래스 내부에서 여러 기능을 재사용할 수 있다.

### 모든 것을 가져올 수밖에 없는 상속

- 클래스의 일부분만 재사용하기 위한 목적으로는 컴포지션을 사용하는 것이 좋다.
- 상속은 인터페이스 분리 원칙에 위반되고, 슈퍼클래스의 동작을 깨버리므로 리스코프 치환 원칙에도 위반된다.
- 만약 타입 계층 구조를 표현해야 한다면, 인터페이스를 활용해서 다중 상속을 하는 것이 좋을 수도 있다.

### 캡슐화를 깨는 상속

- 상속을 사용하면 내부적인 구현 방법 변경에 의해 클래스의 캡슐화가 깨질 수 있다.
- 상속 대신 컴포지션을 사용하게 되면 다형성이 사라지는데, 이는 위임 패턴을 사용해서 해결할 수 있다.
	- 위임 패턴: 클래스가 인터페이스를 상속받게 하고, 포함한 객체의 메서드들을 활용해서, 인터페이스에서 정의한 메서드를 구현하는 패턴
	- 포워딩 메서드: 위임 패턴을 통해 구현된 메서드
	- 코틀린에서는 위임 패턴을 쉽게 구현할 수 있는 문법을 제공한다.

```kotlin
class CounterSet<T>(  
   private val innerSet: MutableSet<T> = mutableSetOf()  
) : MutableSet<T> by innerSet {  
   var elementsAdded: Int = 0  
      private set  
  
   override fun add(element: T): Boolean {  
      elementsAdded++  
      return innerSet.add(element)  
   }  
  
   override fun addAll(elements: Collection<T>): Boolean {  
      elementsAdded += elements.size  
      return innerSet.addAll(elements)  
   }  
}
```

### 오버라이딩 제한하기

- 개발자가 상속용으로 설계되지 않은 클래스를 상속하지 못하게 하려면, `final`을 사용하면 된다.
- `open` 클래스는 `open` 메서드만 오버라이드할 수 있다.