# 클래스 설계

## 상속보다는 컴포지션을 사용하라

### 간단한 행위 재사용

- 재사용을 위해 상속을 사용했을 때 단점
	- 상속은 하나의 클래스만을 대상으로 할 수 있다. 상속을 사용해서 행위를 추출하다 보면, 많은 함수를 갖는 거대한 BaseXXX 클래스를 만들게 되고, 굉장히 깊고 복잡한 계층 구조가 만들어진다.
	- 상속은 클래스의 모든 것을 가져오게 된다. 따라서 불필요한 함수를 갖는 클래스가 만들어질 수 있다.
		- 인터페이스 분리 원칙 위반
	- 상속은 이해하기 어렵다. 작동 방식을 이해하기 위해 슈퍼클래스를 여러 번 확인해야 한다.
- 재사용을 위해 컴포지션을 사용했을 때 장점
	- 코드의 실행을 더 명확하게 예측할 수 있다.
	- 하나의 클래스 내부에서 여러 기능을 재사용할 수 있다.

### 모든 것을 가져올 수밖에 없는 상속

- 클래스의 일부분만 재사용하기 위한 목적으로는 컴포지션을 사용하는 것이 좋다.
- 상속은 인터페이스 분리 원칙에 위반되고, 슈퍼클래스의 동작을 깨버리므로 리스코프 치환 원칙에도 위반된다.
- 만약 타입 계층 구조를 표현해야 한다면, 인터페이스를 활용해서 다중 상속을 하는 것이 좋을 수도 있다.

### 캡슐화를 깨는 상속

- 상속을 사용하면 내부적인 구현 방법 변경에 의해 클래스의 캡슐화가 깨질 수 있다.
- 상속 대신 컴포지션을 사용하게 되면 다형성이 사라지는데, 이는 위임 패턴을 사용해서 해결할 수 있다.
	- 위임 패턴: 클래스가 인터페이스를 상속받게 하고, 포함한 객체의 메서드들을 활용해서, 인터페이스에서 정의한 메서드를 구현하는 패턴
	- 포워딩 메서드: 위임 패턴을 통해 구현된 메서드
	- 코틀린에서는 위임 패턴을 쉽게 구현할 수 있는 문법을 제공한다.

```kotlin
class CounterSet<T>(  
   private val innerSet: MutableSet<T> = mutableSetOf()  
) : MutableSet<T> by innerSet {  
   var elementsAdded: Int = 0  
      private set  
  
   override fun add(element: T): Boolean {  
      elementsAdded++  
      return innerSet.add(element)  
   }  
  
   override fun addAll(elements: Collection<T>): Boolean {  
      elementsAdded += elements.size  
      return innerSet.addAll(elements)  
   }  
}
```

### 오버라이딩 제한하기

- 개발자가 상속용으로 설계되지 않은 클래스를 상속하지 못하게 하려면, `final`을 사용하면 된다.
- `open` 클래스는 `open` 메서드만 오버라이드할 수 있다.

## 데이터 집합 표현에 data 한정자를 사용하라

- `data` 한정자를 붙이면, 다음과 같은 몇 가지 함수가 자동으로 생성된다.
	- `toString`
	- `equals`와 `hashCode`
	- `copy`
	- `componentN`(component1, component2 등)
- `componentN` 함수로 객체를 해제할 때 단점
	- 위치를 잘못 지정하면, 문제가 발생할 수 있다.
	- 읽는 사람에게 혼동을 줄 수 잇다. 특히 람다 표현식과 함께 활용될 때 문제가 된다.
		- ![](assets/Pasted%20image%2020230609114019.png)

### 튜플 대신 데이터 클래스 사용하기

- `Pair`와 `Triple`은 몇 가지 지역적인 목적으로 인해 남아있다.
	- 값에 간단하게 이름을 붙일 때
	- 표준 라이브러리에서 볼 수 있는 것처럼 미리 알 수 없는 aggregate(집합)를 표현할 때
- 위 경우를 제외하면 무조건 데이터 클래스를 사용하는 것이 좋다.
- 데이터 클래스를 사용했을 때 장점
	- 데이터 클래스를 리턴 함수가 있다면, 함수의 리턴 타입이 더 명확해지고 전달하기 쉬워진다. 또한, 사용자가 데이터 클래스에 적혀있는 것과 다른 이름을 활용해 변수를 해제하면, 경고가 출력된다.
	- 데이터 클래스를 좁은 스코프를 갖게 하고 싶다면, 가시성에 재한을 걸어 둘 수 있다.

## 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라

- SAM(Single-Abstract Method): 메서드가 하나만 있는 인터페이스
- 연산 또는 액션을 전달할 때 SAM 대신 함수 타입을 사용하면 얻는 장점
	- 람다 표현식 또는 익명 함수로 전달이 가능하다.
	- 함수 레퍼런스 또는 제한된 함수 레퍼런스로 전달이 가능하다.
	- 선어된 함수 타입을 구현한 객체로 전달이 가능하다.
- type alias 를 사용하면, 함수 타입도 이름을 붙일 수 있다.
	- 이름을 붙이면, IDE의 지원을 받을 수 있다.
	- ![](assets/Pasted%20image%2020230609120039.png)
### 언제 SAM을 사용해야 할까?

- 코틀린이 아닌 다른 언어(자바)에서 사용할 클래스를 설계할 때
- 함수 타입으로 만들어진 클래스는 자바에서 타입 별칭칭과 IDE의 지원 등을 제대로 받을 수 없다.
- 코틀린 함수 타입에서 `Unit`을 리턴하는 경우, 다른 언어에서는 명시적으로 `Unit`을 리턴해야된다.
	- ![](assets/Pasted%20image%2020230609120445.png)