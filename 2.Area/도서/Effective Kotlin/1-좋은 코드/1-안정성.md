# 안정성

## 가변성을 제한하라

- 상태를 구현하는 방법
	- `var` 프로퍼티 사용
	- `mutable` 객체 사용 (`MutableList`, `MutableSet` 등)
- 상태를 가질 때 문제점
	- 상태를 추적해야되기 때문에, 프로그램을 이해하고 디버그하기 힘들어진다.
	- 시점에 따라서 값이 달라질 수 있으므로, 코드의 실행을 추론하기 어려워진다.
	- 멀티스레드 프로그램일 때는 적절한 동기화가 필요하다.
	- 모든 상태를 테스트해야 하므로, 테스트하기 어렵다.
	- 상태 변경이 일어날 때, 이러한 변경을 다른 부분에 알려야 하는 경우가 있다.

> 코루틴: 프로그램의 실행 흐름을 일시적으로 중단하고, 나중에 중단한 시점부터 실행을 재개할 수 있는 멀티 태스킹 기법. 코틀린 공식 라이브러리 중에 이를 지원하는 라이브러리가 있다.
> https://kotlinlang.org/docs/coroutines-overview.html

### 코틀린에서 가변성 제한하기

- 읽기 전용 프로퍼티(val) 사용하기
	- 읽기 전용 프로퍼티에 mutable 객체를 담고 있으면 여전히 상태가 존재하니 유의한다.
	- 읽기 전용 프로퍼티에서 사용자 정의 getter를 사용하면 상태가 존재할 수 있으니 유의한다.(사용자 정의 getter에 var 프로퍼티를 사용하는 경우)
	- val은 var로 오버라이드할 수 있다.
	- 읽기 전용 프로퍼티에서 사용자 정의 getter를 사용하면 스마트 캐스트가 불가능해진다.
	- val 프로퍼티는 여전히 변경될 수 있지만, 참조 자체를 변경할 수는 없으므로 동기화 문제를 줄일 수 있다.

```kotlin
interface Element {  
   val active: Boolean  
}  
  
class ActualElement: Element {  
   override var active: Boolean = false  
  
   fun toggle() {  
      active = !active  
   }  
}
```

- 가변 컬렉션과 읽기 전용 컬렉션 구분하기
	- mutable이 붙은 인터페이스는 대응되는 읽기 전용 인터페이스를 상속받아서, 변경을 위한 메서드를 추가한 것이다.
	- 읽기 전용 컬렉션은 실제로 불변하게 만들지 않았다. 
	- 내부적으로 immutable 하지 않은 컬렉션을 외부적으로 immutable하게 보이게 만들어서 안정성을 얻는다.
	- 읽기 전용 컬렉션을 가변 컬렉션으로 다운캐스팅하면 계약을 위반하고, 추상화를 무시하게 된다.
		- ![](assets/Pasted%20image%2020230413145533.png)
		- `listOf()`는 자바의 `List` 인터페이스를 구현한 `Array.ArrayList` 인스턴스를 리턴한다. 자바의 `List`는 `add`와 `set`같은 메서드를 제공해서, `MutableList`로 다운캐스팅이 가능한데, `Array.ArrayList`는 이러한 연산을 구현하고 있지 않다. 다운캐스팅을 사용하면 문제가 될 수 있다.
	- 읽기 전용에서 mutable로 변경해야 한다면, 복제를 통해서 새로은 mutable 컬렉션을만드는 list.toMutableList를 활용해야 한다.
		- ![](assets/Pasted%20image%2020230413150146.png)

- immutable 객체의 장점
	- 한 번 정의된 상태가 유지되므로, 코드를 이해하기 쉽다.
	- immutable 객체는 공유했을 때도 충돌이 따로 이루어지지 않으므로, 병렬 처리를 안전하게 할 수 있다.
	- immutable 객체에 대한 참조는 변경되지 않으므로, 쉽게 캐시할 수 있다.
	- immutable 객체는 방어적 복사본을 만들 필요가 없다. 또한 객체를 복사할 때 낖은 복사를 따로 하지 않아도 된다.
	- immutable 객체는 다른 객체를 만들 때 활용하기 좋다.
	- immutable 객체는 set 또는 map의 키로 사용할 수 있다. 아래 사진은 가변 객체가 set 과 map에서 사용할 수 없는 이유다.
	- ![](assets/Pasted%20image%2020230413150556.png)

- immutable 객체의 단점
	- 변경이 필요하면 자신의 일부를 수정한 새로운 객체를 만들어 내는 메서드를 가져야 한다.

```kotlin
class User(  
   val name: String,  
   val surname: String  
) {  
   fun withSurname(surname: String) = User(name, surname)  
}
```

- 데이터 클래스의 copy
	- data 한정자는 copy라는 이름의 메서드를 만들어준다.
	- copy 메서드: 모든 기본 생성자 프로퍼티가 같은 새로운 객체를 만들어 낼 수 있다.

### 다른 종류의 변경 가능 지점

- 변경할 수 있는 리스트를 만드는 선택지
	- mutable 컬렉션 만들기
	- var로 읽고 쓸 수 있는 프로퍼티 만들기
- mutable 컬렉션 만들기
	- 리스트 구현 내부에 변경 가능 지점이 있어서, 멀티스레드 처리가 이루어질 경우, 내부적으로 적절한 동기화가 되었는지 확실하게 알 수 없다.
- var로 읽고 쓸 수 있는 프로퍼티 만들기
	- 멀티스레드 처리의 안정성이 더 좋다.
	- 사용자 정의 setter를 통해 변경을 추적하기 쉽다.
	- setter를 private로 만들어서 객체 밖에서 리스트가 변경되는 것을 막을 수도 있다.
	- ![](assets/Pasted%20image%2020230413154745.png)

### 변경 가능 지점 노출하지 말기

- 상태를 나타내는 mutable 객체를 외부에 노출하는 것은 굉장히 위험하다.
- ![](assets/Pasted%20image%2020230413155239.png)

- mutable 객체를 외부에 노출하는 경우 처리 방법
	- 방어적 복제: copy 메서드 활용
		- ![](assets/Pasted%20image%2020230413155339.png)
	- 읽기 전용 슈퍼타입으로 업캐스트
		- ![](assets/Pasted%20image%2020230413155413.png)
