# 안정성

## 가변성을 제한하라

- 상태를 구현하는 방법
	- `var` 프로퍼티 사용
	- `mutable` 객체 사용 (`MutableList`, `MutableSet` 등)
- 상태를 가질 때 문제점
	- 상태를 추적해야되기 때문에, 프로그램을 이해하고 디버그하기 힘들어진다.
	- 시점에 따라서 값이 달라질 수 있으므로, 코드의 실행을 추론하기 어려워진다.
	- 멀티스레드 프로그램일 때는 적절한 동기화가 필요하다.
	- 모든 상태를 테스트해야 하므로, 테스트하기 어렵다.
	- 상태 변경이 일어날 때, 이러한 변경을 다른 부분에 알려야 하는 경우가 있다.

> 코루틴: 프로그램의 실행 흐름을 일시적으로 중단하고, 나중에 중단한 시점부터 실행을 재개할 수 있는 멀티 태스킹 기법. 코틀린 공식 라이브러리 중에 이를 지원하는 라이브러리가 있다.
> https://kotlinlang.org/docs/coroutines-overview.html

### 코틀린에서 가변성 제한하기

- 읽기 전용 프로퍼티(val) 사용하기
	- 읽기 전용 프로퍼티에 mutable 객체를 담고 있으면 여전히 상태가 존재하니 유의한다.
	- 읽기 전용 프로퍼티에서 사용자 정의 getter를 사용하면 상태가 존재할 수 있으니 유의한다.(사용자 정의 getter에 var 프로퍼티를 사용하는 경우)
	- val은 var로 오버라이드할 수 있다.
	- 읽기 전용 프로퍼티에서 사용자 정의 getter를 사용하면 스마트 캐스트가 불가능해진다.
	- val 프로퍼티는 여전히 변경될 수 있지만, 참조 자체를 변경할 수는 없으므로 동기화 문제를 줄일 수 있다.

```kotlin
interface Element {  
   val active: Boolean  
}  
  
class ActualElement: Element {  
   override var active: Boolean = false  
  
   fun toggle() {  
      active = !active  
   }  
}
```

- 가변 컬렉션과 읽기 전용 컬렉션 구분하기
	- mutable이 붙은 인터페이스는 대응되는 읽기 전용 인터페이스를 상속받아서, 변경을 위한 메서드를 추가한 것이다.
	- 읽기 전용 컬렉션은 실제로 불변하게 만들지 않았다. 
	- 내부적으로 immutable 하지 않은 컬렉션을 외부적으로 immutable하게 보이게 만들어서 안정성을 얻는다.
	- 읽기 전용 컬렉션을 가변 컬렉션으로 다운캐스팅하면 계약을 위반하고, 추상화를 무시하게 된다.
		- ![](assets/Pasted%20image%2020230413145533.png)
		- `listOf()`는 자바의 `List` 인터페이스를 구현한 `Array.ArrayList` 인스턴스를 리턴한다. 자바의 `List`는 `add`와 `set`같은 메서드를 제공해서, `MutableList`로 다운캐스팅이 가능한데, `Array.ArrayList`는 이러한 연산을 구현하고 있지 않다. 다운캐스팅을 사용하면 문제가 될 수 있다.
	- 읽기 전용에서 mutable로 변경해야 한다면, 복제를 통해서 새로은 mutable 컬렉션을만드는 list.toMutableList를 활용해야 한다.
		- ![](assets/Pasted%20image%2020230413150146.png)

- immutable 객체의 장점
	- 한 번 정의된 상태가 유지되므로, 코드를 이해하기 쉽다.
	- immutable 객체는 공유했을 때도 충돌이 따로 이루어지지 않으므로, 병렬 처리를 안전하게 할 수 있다.
	- immutable 객체에 대한 참조는 변경되지 않으므로, 쉽게 캐시할 수 있다.
	- immutable 객체는 방어적 복사본을 만들 필요가 없다. 또한 객체를 복사할 때 낖은 복사를 따로 하지 않아도 된다.
	- immutable 객체는 다른 객체를 만들 때 활용하기 좋다.
	- immutable 객체는 set 또는 map의 키로 사용할 수 있다. 아래 사진은 가변 객체가 set 과 map에서 사용할 수 없는 이유다.
	- ![](assets/Pasted%20image%2020230413150556.png)

- immutable 객체의 단점
	- 변경이 필요하면 자신의 일부를 수정한 새로운 객체를 만들어 내는 메서드를 가져야 한다.

```kotlin
class User(  
   val name: String,  
   val surname: String  
) {  
   fun withSurname(surname: String) = User(name, surname)  
}
```

- 데이터 클래스의 copy
	- data 한정자는 copy라는 이름의 메서드를 만들어준다.
	- copy 메서드: 모든 기본 생성자 프로퍼티가 같은 새로운 객체를 만들어 낼 수 있다.

### 다른 종류의 변경 가능 지점

- 변경할 수 있는 리스트를 만드는 선택지
	- mutable 컬렉션 만들기
	- var로 읽고 쓸 수 있는 프로퍼티 만들기
- mutable 컬렉션 만들기
	- 리스트 구현 내부에 변경 가능 지점이 있어서, 멀티스레드 처리가 이루어질 경우, 내부적으로 적절한 동기화가 되었는지 확실하게 알 수 없다.
- var로 읽고 쓸 수 있는 프로퍼티 만들기
	- 멀티스레드 처리의 안정성이 더 좋다.
	- 사용자 정의 setter를 통해 변경을 추적하기 쉽다.
	- setter를 private로 만들어서 객체 밖에서 리스트가 변경되는 것을 막을 수도 있다.
	- ![](assets/Pasted%20image%2020230413154745.png)

### 변경 가능 지점 노출하지 말기

- 상태를 나타내는 mutable 객체를 외부에 노출하는 것은 굉장히 위험하다.
- ![](assets/Pasted%20image%2020230413155239.png)

- mutable 객체를 외부에 노출하는 경우 처리 방법
	- 방어적 복제: copy 메서드 활용
		- ![](assets/Pasted%20image%2020230413155339.png)
	- 읽기 전용 슈퍼타입으로 업캐스트
		- ![](assets/Pasted%20image%2020230413155413.png)
## 변수의 스코프를 최소화하라

- 상태를 정의할 때는 변수와 프로퍼티의 스코프를 최소화하는 것이 좋다.
	- 프로퍼티보다는 지역 변수를 사용하는 것이 좋다.
	- 최대한 좁은 스코프를 갖게 변수를 사용한다. 
- 스코프를 좁게 만드는 것이 좋은 이유: 프로그램을 추적하고 관리하기 쉽다.
	- mutable 프로퍼티가 좁은 스코프에 걸쳐 있을수록, 그 변경을 추적하는 것이 쉽다.
	- 변수의 스코프 범위가 너무 넓으면, 다른 개발자에 의해 변수가 잘못 사용될 수 있다.
- 변수는 정의할 때 초기화하는 것이 좋다. if, when ,try-catch, Elvis 표현식 등을 활용하면, 최대한 변수를 정의할 때 초기화할 수 있다.
- 여러 프로퍼티를 한꺼번에 설정해야 하는 경우에는 구조분해 선언을 활용하는 것이 좋다.

### 캡처링

- 변수 스코프를 유의하지 않으면 시퀀스 사용시 캡처링으로인해 의도하지 않는 동작이 나올 수 있다.
	- 아래 예시는 시퀀스의 filter가 지연 처리되면서 모두 최종적은 prime 값으로 필터링되고 있다.
	- ![](assets/Pasted%20image%2020230414152943.png)
> `generateSequence(seed: T?, nextFunction: (T) -> T?): Sequence<T>` seed부터 시작해서 nextFunction으로 다음 값을 구하는 시퀀스 생성
> https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/generate-sequence.html

> `yield(value: T)` Iterator에게 다음 값을 전달
> https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence-scope/yield.html

> `drop()`: 시퀀스의 첫번째 값 제거
> https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/drop.html

## 최대한 플랫폼 타입을 사용하지 말라

- 자바에서 `String` 타입을 리턴하는 메서드가 있는 경우
	- `@Nullable` 어노테이션이 붙어 있으면, 코틀린에서 `String?`으로 변경
	- `@NotNull` 어노테이션이 붙어 있으면, 코틀린에서 `String`으로 변경
	- 아무것도 붙어있지 않는다면 문제가 될 수 있다.
- 플랫폼 타입: 다른 프로그래밍 언어에서 전달되어서 nullable 인지 아닌지 알 수 없는 타입
- 자바를 코틀린과 함께 사용할 때, 자바 코드를 직접 조작할 수 있다면, 가능한 `@Nullable`과 `@NotNull` 어노테이션을 붙여서 사용해라.
	- ![](assets/Pasted%20image%2020230424105305.png)
- 현재 다음과 같은 여러 어노테이션을 지원하고 있다.([참고](https://kotlinlang.org/docs/java-interop.html#nullability-annotations))
	- [JetBrains](https://www.jetbrains.com/idea/help/nullable-and-notnull-annotations.html) (`@Nullable` and `@NotNull` from the `org.jetbrains.annotations` package)
	- [JSpecify](https://jspecify.dev/) (`org.jspecify.nullness`)
	- Android (`com.android.annotations` and `android.support.annotations`)
	- JSR-305 (`javax.annotation`, more details below)
	- FindBugs (`edu.umd.cs.findbugs.annotations`)
	- Eclipse (`org.eclipse.jdt.annotation`)
	- Lombok (`lombok.NonNull`)
	- RxJava 3 (`io.reactivex.rxjava3.annotations`)

- 코틀린 코드에서는 플랫폼 타입은 안전하지 않으므로, 최대한 빨리 제거하는 것이 좋다.
	- 10번 라인처럼 플랫폼 타입을 바로 제거하면, 자바에서 값을 가져오는 위치에서 NPE가 발생해서 null이 발생하는 위치를 쉽게 추적할 수 있다.
	- 18번 라인처럼 플랫폼 타입 사용을 오래 유지시키면, 실제로 값을 사용할 때 NPE가 발생해서 null이 발생하는 위치를 추적하기 어렵다.
	- ![](assets/Pasted%20image%2020230424110439.png)
	- ![](assets/Pasted%20image%2020230424110451.png)
## inferred 타입으로 리턴하지 말라

- 할당 할 때 inferred 타입은 정확하게 오른쪽에 있는 피연산자에 맞게 설정된다.
	- 절대로 슈퍼클래스 또는 인터페이스로는 설정되지 않는다.
	- ![](assets/Pasted%20image%2020230424111731.png)
- 원하는 타입보다 제한된 타입이 설정되었다면, 타입을 명시적으로 지정해서 문제를 해결할 수 있다.
- 리턴 타입은 API를 잘 모르는 사람에게 전달해 줄 수 있는 중요한 정보다.
	- 따라서 리턴 타입은 외부에서 확인할 수 있게 명시적으로 지정해 주는 것이 좋다.