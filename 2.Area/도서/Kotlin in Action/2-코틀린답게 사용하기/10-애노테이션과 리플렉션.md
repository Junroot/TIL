# 애노테이션과 리플렉션

## 애노테이션 선언과 적용

### 애노테이션 적용

- 코틀린에서 `@Deprecated` 애노테이션은 대신할 수 있는 패턴을 제시할 수 있다.

```kotlin
@Deprecated("Use new(index) instead.", ReplaceWith("new(index)"))  
fun deprecated(index: Int) {  
   println("deprecated: index")  
}  
  
fun new(index: Int) {  
   println("new: $index")  
}
```

![](assets/Pasted%20image%2020230329190933.png)

- 애노테이션의 인자로는 원시 타입의 값, 문자열, enum, 클래스 참조, 다른 애노테이션 클래스, 그리고 지금까지 말한 요소들로 이뤄진 배열이 들어갈 수 있다.
	- 클래스 애노테이션 인자로 지정할 때는 `@MyAnnotation(MyClass::class)` 처럼 `::class`를 클래스 이름 뒤에 넣어야 한다.
	- 다른 애노테이션을 인자로 지정할 때는 인자로 들어가는 애노테이션의 이름 앞에 `@`를 넣지 말아야된다. 앞에서 본 예제의 `ReplaceWith`는 애노테이션이다.
	- 배열을 인자로 사용하는 경우 자동으로 가변 길이 인자로 변환된다.
- 애노테이션 인자를 컴파일 시점에 알 수 있어야 한다.
- 프로퍼티를 애노테이션 인자로 사용하려면 그 앞에 `const` 변경자를 붙여야한다.
	- 컴파일러는 `const` 가 붙은 프로퍼티를 컴파일 시점 상수로 취급한다.
	- `const` 가 붙은 프로퍼티는 파일의 맨위나 `object` 안에 선언해야 하며, 원시 타입이나 `String`으로 초기화해야만 한다.

### 애노테이션 대상

- 사용 지점 대상 선언으로 애노테이션을 붙일 요소를 정할 수 있다.

![](assets/Pasted%20image%2020230329195217.png)

- 사용 지점 대상을 지정할 때 지원하는 대상 목록은 다음과 같다.
	- `property`: 프로퍼티 전체. 자바에서 선언된 애노테이션은 이 사용 지점 대상을 사용할 수 없다.
	- `field`: 프로퍼티에 의해 생성되는 (뒷받침하는) 필드
	- `get`: 프로퍼티 게터
	- `set`: 프로퍼티 세터
	- `receiver`: 확장 함수느 프로퍼티의 수신 객체 파라미터
	- `param`: 생성자 파라미터
	- `setparam`: 세터 파라미터
	- `delegate`: 위임 프로퍼티의 위임 인스턴스를 담아둔 필드
	- `file`: 파일 안에 선언된 최상위 함수와 프로퍼티를 담아두는 클래스
- `file` 대상을 사용하는 애노테이션은 `package` 선언 앞에서 파일의 최상위 수준에서만 사용할 수 있다.
	- 파일에 있는 최상위 선언을 담는 클래스의 이름을 바꿔주는 `@file:JvmName("StringFunctions")`
- 애노테이션 인자로 임의의 식을 허용한다.

![](assets/Pasted%20image%2020230329195625.png)

- 자바 API를 애노테이션으로 제어하기
	- `@JvmName`: 코틀린 선언이 만들어내는 자바 필드나 메소드 이름을 변경한다.
	- `@JvmStatic`: 메소드, 객체 선언, 동반 객체를 자바 정적 메소드로 노출한다.
	- `@JvmOverloads`: 디폴트 파라미터 값이 있는 함수에 대해 컴파일러가 자동으로 오버로딩한 함수를 생성해준다.
	- `@JvmField`: 프로퍼티에 사용하면 게터나 세터가 없는 public 자바 필드로 프로퍼티를 노출시킨다.