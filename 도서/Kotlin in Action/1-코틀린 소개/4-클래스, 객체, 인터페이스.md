# 클래스, 객체, 인터페이스

## 클래스 계층 정의
- 코틀린 인터페이스는 자바 8 인터페이스와 비슷하다.
- 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메소드를 오버라이드할 때는 `override` 변경자를 붙여줘야 된다.
	- 실수로 상위 클래스의 메소드를 오버라이드하는 경우를 방지해준다.
- 한 클래스에서 두 인터페이스를 함께 구현했을 때,  같은 디폴트 메소드가 있다면 컴파일 오류가 발생한다. 이 경우는 하위 클래스에 직접 구현하게 강제한다.
- 상위 타입의 메소드 호출하는 방식은 아래를 참고한다.
```kotlin
class Button : Clickable, Focusable {  
   override fun click() {  
      println("I was Clicked")  
   }  
  
   override fun showOff() {  
      super<Clickable>.showOff()  
      super<Focusable>.showOff()  
   }  
}
```

## open, final, abstract 변경자: 기본적으로 final
- 취약한 기반 클래스(fragile base class): 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 꺠져버린 경우
- 어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙을 제공하지 않는다면 그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메소드를 오버라이드할 위험이 있다.
- 인터페이스는 항상 열려 있으며 `final`로 변경할 수 없다.

|상속 제어 변경자|이 변경자가 붙은 멤버는|설명|
|----------|------|----------|
|final|오버로이드할 수 없음|클래스 멤버의 기본 변경자다.
|open|오버라이드할 수 있음|반드시 open을 명시해야 오버라이드할 수 있다.|
|abstract|반드시 오버라이드해야 함|추상 클래스의 멤버에만 이 변경자를 붙일 수 있다. 추상 멤버에는 구현이 있으면 안 된다.|
|override|상위 클래스나 상위 인스턴스의 멤버를 오버라이드하는 중|오버라이드하는 멤버는 기본적으로 열려있다. 하위 클래스의 오버라이드를 금지하려면 final을 명시해야 한다.|

## 가시성 변경자: 기본적으로 공개
- 어떤 클래스의 기반 타입 목록에 들어있는 타입이나제네릭 클래스의 타입 파라미터에 있는 타입의 가시성은 그 클래스의 가시성과 같거나 더 높아야된다.
- 메소드의 시그니처에 사용된 모든 타입의 가시성은 그 메소드의 가시성과 같거나 더 높아야 한다.
- 코틀린의 선언과 그에 해당하는 자바 선언에 차이가 존재한다.
	- 코틀린에서 `private` 클래스를 자바에서 패키지 전용 클래스로 컴파일한다.
	- 코틀린에서 `internal` 변경자는 바이트코드상에서는 `public`이 된다. 따라서, 코틀린에서 접근할 수 없는 대상을 자바에서 접근할 수 있는 경우가 생긴다.
		- 하지만 코틀린컴파일러가 `internal` 멤버의 이름을 보기 나쁘게 바꾼다.
	- 코틀린에서 `protected`는 하위 클래스만 볼 수 있지만, 자바에서는 같은 패키지에 속한 코드는 볼 수 있다.

|변경자|클래스 멤버|최상위 선언|
|-|-|-|
|public(기본 가시성임)|모든 곳에서 볼 수 있다.|모든 곳에서 볼 수 있다.|
|internal|같은 모듈 안에서만 볼 수 있다.|같은 모듈 안에서만 볼 수 있다.|
|protected|하위 클래스 안에서만 볼 수 있다.|(최상위 선언에 적용할 수 없음)|
|private|같은 클래스 안에서만 볼 수 있다.|같은 파일 안에서만 볼 수 있다.|

## 내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스
- 중첩 클래스: 바깥쪽 클래스에 대한 참조를 저장하지 않음
- 내부 클래스: 바깥쪽 클래스에 대한 참조를 저장함

|클래스 B안에 정의된 클래스 A|자바에서는|코틀린에서는|
|-|-|-|
|중첩 클래스|static class A|class A|
|내부 클래스|class A|inner class A|

![](assets/Pasted%20image%2020230126115701.png)

- 코틀린에서 바깥쪽 클래스의 인스턴스를 가리키는 참조에 접근하려면 아래와 같이 써야된다.

```kotlin
class Outer {  
   inner class Inner {  
      fun getOuterReference():  Outer = this@Outer  
   }  
}
```

## 봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한
- 코틀린 컴파일러는 `when`을 사용해 타입의 값을 겁사할 때 꼭 디폴트 분기인 `else` 분기르 ㄹ 덧붙이게 강제한다.
	- 디폴트 분기가 있으면 이런 클래스 계층에 새로운 하위 클래스를 추가하더라도 컴파일러가 `when`이 모든 경우를 처리하는지 제대로 검사할 수 없다.
- `sealed` 클래스는 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다.
- `sealed` 클래스의 하위 클래스를 정의할 때는 반드시 같은 파일에서 정의를 해야된다.
- `when`식에서 `sealed`클래스의 모든 하위 클래스를 처리한다면 디폴트 분기가 필요없다.
- `sealed` 클래스에 속한 값에 대해 디폴트 분기를 사용하지 않고 `when` 식을 사용하면 나중에 `sealed` 클래스의 상속 계층에 새로운 하위 클래스를 추가해도 `when` 식이 컴파일되지 않는다. 
- `sealed` 클래스는 2가지 가시성 변경자의 생성자를 가질 수 있다.
	- `protected`(기본값), `private`
```kotlin
sealed class Expr {  
   class Num(val value: Int) : Expr()  
   class Sum(val left: Expr, val right: Expr) : Expr()  
}
```

