# 함수 정의와 호출

## 코틀린에서 컬렉션 만들기

- 코틀린은 자신만의 컬렉션 기능을 제공하지 않는다.
  - 표준 자바 컬렉션을 활용하면 자바 코드와 상호작용하기가 훨씬 쉽다.
- 코틀린에서는 자바보다 더 많은 기능을 쓸 수 있다.

## 함수를 호출하기 쉽게 만들기

### 이름 붙인 인자

- 코틀린으로 작성한 함수를 호출할 때는 함수에 전달하는 인자 중 일부의 이름을 명시할 수 있다. 
- 호출 시 인자 중 어느 하나라도 이름을 명시하고 나면 혼동을 막기 위해 그 뒤에 오는 모든 인자는 이름을 꼭 명시해야 한다.
- 자바로 작성한 코드를 호출할 때는 이름 붙인 인자를 사용할 수 없다.
  - 클래프 파일에 함수 파라미터정보를 넣은 것은 자바 8 이후 추가된 선택적 특징인데, 코틀린은 JDK 6와 호환된다.

### 디폴트 파라미터 값

- 코틀린에서는 함수 선언에서 파라미터의 디폴트 값을 지정할 수 있으므로 자바의 오버로딩이 많아지는 문제를 피할 수 있다.
- 자바에는 디폴트 파라미터 값이라는 개념이 없어서 코틀린 함수를 자바에서 호출하는 경우에는 코틀린 함수가 디폴트 파라미터 값을 제공하더라도 모든 인자를 명시해야 한다.
  - 코틀린 함수에 `@JvmOverloads` 애노테이션을 추가하면 코틀린 컴파일러가 자동으로 맨 마지막 파라미터로부터 파라미터를 하나씩 생략한 오버로딩한 자바 메소드를 추가해준다.

### 정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티 

- 코틀린에서는 함수를 직접 소스 파일의 최상위 수준, 모든 다른 클래스의 밖에 위치시킬 수 있다.
- 코틀린 컴파일러는 컴파일할 때, 새로운 클래스를 정의해준다. 최상위 함수는 이 클래스의 정적인 메소드가 된다.
- 코틀린 최상위 함수가 포함되는 클래스의 이름을 바꾸고 싶다면 파일에 `@JvmName` 애노테이션을 추가하면 된다.
  - `@JvmName` 애노테이션은 파일의 맨 앞, 패키지 이름 선언 이전에 위치해야 한다.
- 함수와 마찬가지로 프로퍼티도 파일의 최상위에 놓을 수 있다.
  - 이런 프로퍼티 값은 정적 필드에 저장된다.
  - 겉으로는 상수처럼 보이는데, 실제로는 getter를 사용해야 한다면 자연스럽지 못하다.
  - `const` 변경자를 추가하면 프로퍼티를 `public static final` 필드로 컴파일하게 만들 수 있다.

## 메소드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티

### 확장 함수

- 확장 함수: 어떤 클래스의 멤버 메소드인 것 처럼 호출할 수 있지만 그 클래스의 밖에 선언된 함수
- 수신 객체 타입(receiver type): 확장 함수의 클래스 이름
- 수신 객체(receiver object): 확장 함수가 호출이 되는 대상이 되는 객체
- 확장 함수가 캡슐화를 깨지는 않는다. 확장 함수 안에서는 클래스 내부에서만 사용할 수 있는 private 멤버와 protected 멤버를 사용할 수 없다.

```kotlin
fun String.middle() = get(this.length / 2)

fun main() {
	val name = "junroot"
	print(name.middle())
}
```

### 임포트와 확장 함수

- 확장 함수를 사용하기 위해서는 그 함수를 다른 클래스나 함수와 마찬가지로 임포트해야만 한다.
- 한 파일 안에서 다른 여러 패키지에 속해있는 이름이 같은 함수를 가져와 사용해야 하는 경우 이름을 바꿔서 임포트하면 이름 충돌을 막을 수 있다.

```kotlin
import extension.middle as m

fun main() {
	val name = "junroot"
	name.m()
}
```

### 자바에서 확장 함수 호출

- 내부적으로 확장 함수는 수신 객체를 첫 번째 인자로 받는 정적 메소드다.
- 그래서 확장 함수를 호출해도 다른 어댑터 객체나 실행 시점 부가 비용이 들지 않는다.

### 확장 함수로 유틸리티 함수 정의

- 확장 함수는 단지 정적 메소드 호출에 대한 syntatic sugar일 뿐이다.

- 그래서 클래스가 아닌 더 구체적인 타입을 수신 객체 타입으로 지정할 수도 있다.

- 아래와 같이 문자열의 컬렉션에 대해서만 호출할 수 있는 확장 함수도 만들 수 있다.

  ```kotlin
  fun Collection<String>.join(
  	separator: String = ", ", prefix: String = "", postfix: String = ""
  ) = joinToString(separator, prefix, postfix)
  ```

### 확장 함수는 오버라이드할 수 없다

- 확장 함수는 클래스의 일부가 아니다. 확장 함수는 클래스 밖에 선언된다.
- 이름과 파라미터가 완전히 같은 확장 함수를 기반 클래스와 하위 클래스에 대해 정의해도 실제로는 확장 함수를 호출할 때 수신 객체로 지정한 변수의 정적 타입에 의해 어떤 확장 함수가 호출될지 결정되지, 그 변수가 저장된 객체의 동적인 타입에 의해 확장 함수가 결정되지 않는다.
- 어떤 클래스를 확장한 함수와 그 클래스의 멤버 함수의 이름과 시그니처가 같다면 확장 함수가 아니라 멤버 함수가 호출된다.

### 확장 프로퍼티

- 확장 프로퍼티도 일반적인 프로퍼티와 같은데, 단지 수신 객체 클래스가 추가됐을 뿐이다.
- backing field가 없어서 기본 getter 구현을 제공할 수 없으므로 최소한 getter는 꼭 정의를 해야 한다.
- 마찬가지로 초기화 코드에서 계산한 값을 담을 장소가 전혀 없으므로 초기화 코드도 쓸 수 없다.