## 널 가능성

- 널 가능성(nullability): NPE를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성
- 코틀린을 비롯한 최신 언어에서 null에 대한 접근 방법은 가능한 한 이 문제를 실행 시점에서 컴파일 시점으로 옮기는 것이다.

### 널이 될 수 있는 타입

- 모든 타입은 기본적으로 널이 될 수 없는 타입이다.
- 널을 받을 수 있게 하려면 타입 이름 뒤에 물음표(`?`)를 명시해야 한다.
- 널이 될 수 있는 타입의 변수가 있다면 그에 대해 수행할 수 있는 연산이 제한된다.
	- 메소드를 직접 호출할 수 없다.
	- 널이 될 수 있는 값을 널이 될 수 없는 타입의 변수에 대입할 수 없다.
	- 널이 될 수 있는 값을 널이 될 수 없는 타입의 파라미터를 받는 함수에 전달할 수 없다.
- 널이 될 수 있는 타입은 null과 비교하고 나면 컴파일러는 그 사실을 기억하고 null이 아님을 확실한 영역에서는 해당 값을 널이 될 수 없는 타입의 값처럼 사용할 수 있다.

### 타입의 의미

- 타입: 어떤 값들이 가능한지와 그 타입에 대해 수행할 수 있는 연산의 조유를 결정한다.
- 자바에서 `String`타입의 변수에는 `String`이나 `null`이라는 두 가지 종류의 값이 들어갈 수 있다. 
	- 이 두 종류의 값은 서로 완전히 다르다.
	- 두 종류의 값에 대해 실행할 수 있는 연산도 완전히 다르다.
	- 자바의 타입 시스템이 널을 제대로 다루지 못한다.
- 자바에서 `NullPointerException` 오류를 다루는 방법
	- `@Nullable`이나 `@NotNull`을 사용한다. 하지만 이런 도구는 표준 자바 컴파일 절차의 일부가 아니기 때문에 일관성 있게 적용된다는 보장을 할 수 없다.
	- `null` 대신 자바8에 새로 도입된 `Optional` 타입 등의 `null`을 감싸는 특별한 래퍼 타입을 활용할 수 있다. 하지만 코드가 더 지저분해지고 래퍼가 추가됨에 따라 실행 시점에 성능이 저하되며 전체 에코시스템에서 일관성 있게 활용하기 어렵다.
- 코틀린은 실행 시점에 널이 될 수 있는 타입이나 널이 될 수 없는 타입의 객체는 같다.
	- 널이 될 수 있는 타입은 널이 될 수 없는 타입을 감싼 래퍼 타입이 아니다.
	- 모든 검사는 컴파일 시점에 수행한다.
	- 코틀린에서는 널이 될 수 있는 타입을 처리하는데 별도의 실행 시점 부가 비용이 들지 않는다.

### 안전한 호출 연산자: ?.

- `?.`은 null 검사와 메소드 호출을 한 번의 연산으로 수행한다.
- 호출하려는 값이 null이 아니라면 `?.`는 일반 메소드 호출처럼 작동한다. null이면 이 호출은 무시되고 null이 결과 값이 된다.
- 메소드 호출뿐 아니라 프로퍼티를 읽거나 쓸 때도 안전한 호출을 사용할 수 있다.
- 객체 그래프에서 널이 될 수 있는 중간 객체가 여럿 있다면 한 식 안에서 안전한 호출을 연쇄해서 함께 사용하면 편할 때가 자주 있다.

```kotlin
val country = this.company?.address?.country
```

### 엘비스 연산자: ?:

- null 대신 사용할 디폴트 값을 지정할 때 편리하게 상요할 수 있는 연산자
- 이항 연산자로 좌항을 계산한 값이 널인지 검사한다. 좌항 값이 널이 아니라면 좌항 값을 결과로 하고, 좌항 값이 널이면 우항 값을 결과로 한다.
- 코틀린에서는 `return`이나 `throw` 등의 연산도 식이다. 따라서 엘비스 연산자의 우항에 `return`, `throw` 등의 연산을 넣을 수 있다.

```kotlin
val address = person.company?.address?: throw IllegalArgumentException("No address")
```

### 안전한 캐스트: as?

- 어떤 값을 지정한 타입으로 캐스트한다. 값을 대상 타입으로 변환할 수 없으면 null을 반환한다.
- 안전한 캐스트를 사용할 때 일반적인 패턴은 캐스트를 수행한 뒤에 엘비스 연산자를 사용하는 것이다.

```kotlin
val otherPerson = o as? Person ?: return false
```

### 널 아님 단언: !!

- 어떤 값이든 널이 될 수 없는 타입으로 강제로 바꿀 수 있다.
- 실제 널에 대해 `!!`를 적용하면 NPE가 발생한다.
- 근본적으로 `!!`는 컴파일러에게 "나는 이 값이 null이 아님을 잘 알고 있다. 내가 잘못 생각했다면 예외가 발생해도 감수하겠다"라고 말하는 것이다.
- `!!`를 널에 대해 사용해서 발생하는 예외의 스택 트레이스에는 어떤 파일의 몇 번째 줄인지에 대한 정보는 들어있지만 어떤 식에서 예외가 발생했는지에 대한 정보는 즐어있지 않다.
	- 어떤 값이 널이있는지 확실히 하기 위해 여러 `!!` 단언문을 한 줄에 함께 쓰는 일은 피하라

```kotlin
person.company!!.address!!.country // 이런 식으로  코드를 작성하지 말라.
```

### let 함수

- 자신의 수신 객체를 인자로 전달받은 람다에게 넘긴다.
- 널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 값으로 바꿔서 람다에 전달하게 된다.
- let 함수는 값이 널이 아닌 경우에만 호출된다.

```kotlin
var email: String? = "yole@example.com"
email?.let { sendEmailTo(it) }
```

### 나중에 초기화할 프로퍼티

- 코틀린에서 클래스 안의 널이 될 수 없는 프로퍼티를 생성자 안에서 초기화하지 않고 특별한 메소드 안에서 초기화할 수는 없다.
- 이를 해결하기 위해 프로퍼티를 late-initialized 할 수 있다.
- `lateinit` 변경자를 붙이면 프로퍼티를 나중에 초기화할 수 있다.

```kotlin
class MyService {  
   fun performAction():String = "foo"  
}  
  
class MyTest {  
   private lateinit var myService: MyService  
   @BeforeAll fun setUp() {  
      myService = MyService()  
   }  
     
   @Test fun testAction() {  
      assertEquals("foo", myService.performAction())  
   }  
}
```

- 프로퍼티를 초기화하기 전에 프로퍼티에 접근하면 "lateinit property myService has not been initialized"이라는 예외가 발생한다.
- `lateinit` 프로퍼티를 의존관계 주입(DI) 프레임워크와 함께 사용하는 경우가 많다.

### 널이 될 수 있는 타입 확장

- 확장 함수의 경우 안전한 호출 없이도 널이 될 수 있는 수신 객체 타입에서 호출이 가능하다.

```kotlin
fun String?.isNullOrBlank(): Boolean = this == null || this.isBlank()
```

- 직접 확장 함수를 작성한다면 처음에는 널이 될 수 없는 타입에 대한 확장 함수를 정의하라. 나중에 대부분 널이 될 수 있는 타입에 대해 그 함수를 호출했다는 사실을 깨닫게 되면 확장 함수 안에 널을 제대로 처리하게 하면 안전하게 그 확장 함수를 널이 될 수 있는 타입에 대한 확장 함수로 바꿀 수 있다.

### 타입 파라미터의 널 가능성

- 코틀린에서는 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다.
- 따라서 타입 파라미터 `T`를 클래스나 함수 안에서 타입 이름으로 사용하면 이름 끝에 물음표가 없더라도 `T`가 널이 될 수 있는 타입이다.

![](assets/Pasted%20image%2020230221134920.png)

- 타입 파라미터가 널이 아님을 확실히 하려면 얼이 될 수 없는 타입 상한(upper bound)를 지정해야 한다.

### 널 가능성과 자바

- 자바 코드에도 애노테이션으로 표시된 널 가능성 정보가 있다.
	- 자바의 `@Nullable String`은 코틀린 쪽에서 볼 때 `String?`와 같고, 자바의 `@NotNull String`은 코틀린쪽에서 볼 때 `String`과 같다.
	- JSR-305 표준(`javax.annotation` 패키지), 안드로이드(`android.support.annotation` 패키지), 젯브레인스 도구들이 지원하는 애노테이션(`org.jetbrains.annotations`) 등이 코틀린이 이해할 수 있는 널 가능성 애노테이션들이다.
- 널 가능성 애노테이션이 자바 코드에 없는 경우, 자바의 타입은 코틀린의 플랫폼 타입(platform type)이 된다.
	- 플랫폼 타입: 코틀린이 널 관련 정보를 알 수 없는 타입
	- 코틀린에서 널이 될 수 있는 타입으로 처리해도되고 널이 될 수 없는 타입으로 처리해도 된다.
	- 만약 잘못사용하게 된다면 `NullPointerExceptoin`이 발생할 수 있다.
	- 플랫폼 타입은 코틀린 컴파일러가 `String!`과 같이 느낌표를 뒤에 붙인다.
- 코틀린 컴파일러는 public 코틀린 함수의 널이 아닌 타입인 파라미터와 수신 객체에 대한 널 검사를 추가해준다.
	- 따라서 public 함수에 널 값을 사용하면 즉시 예외가 발생한다. 이 때 `NullPointerException`이 아니라 수신 객체(`$receiver`)로 널을 받을 수 없다는 더 자세한 예외가 발생한다.
- 코틀린이 플랫폼 타입을 도입한 이유
	- 모든 자바 타입을 널이 될 수 있는 타입으로 다룰 수도 있었다.
	- 하지만 그러면 널이 될 수 없는 값에 대해서도 불필요한 널 검사가 들어간다. 이 때문에 플랫폼 타입을 도입했다.
- 코틀린에서 자바 메소드를 오버라이드할 때 그 메소드의 파라미터와 반환 타입을 널이 될 수 있 수 있는 타입으로 선언할지 널이 될 수 없는 타입으로 선언할지 결정할 수 있다.
	- 코틀린 컴파일러는 널이 될 수 없는 타입으로 선언한 모든 파라미터에 대해 널이 아님을 검사하는 단언문을 만들어준다.