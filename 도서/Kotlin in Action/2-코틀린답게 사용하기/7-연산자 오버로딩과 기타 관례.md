# 연산자 오버로딩과 기타 관례

- 관례(convention): 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기법
	- 예: 어떤 클래스 안에 `plus`라는 이름의 메소드를 정의하면 그 클래스의 인스턴스에 대해 `+` 연산자를 사용할 수 있다.
	- 이유: 기존 자바 클래스를 코틀린 언어에 적용하기 위함

## 산술 연산자 오버로딩

### 이항 산술 연산 오버로딩

- 연산자를 오버로딩하는 함수 앞에는 꼭 `operator` 키워드가 있어야 한다.

```kotlin
data class Point(val x: Int, val y: Int) {  
  
   operator fun plus(other: Point): Point {  
      return Point(x + other.x, y + other.y)  
   }  
}
```

- 프로젝트 안에서 직접 작성한 클래스에 대해 관례를 따르는 확장 함수를 만들어도 역시 잘 작동한다.
- 오버로딩 가능한 이항 산술 연산자

식|함수 이름
---|---
`a * b`|times
`a / b`|div
`a % b`|mod(1.1부터 rem)
`a + b`|plus
`a - b`|minus

- 직접 정의한 함수를 통해 구현하더라도 연산자 우선순위는 언제나 표준 숫자 타입에대한 연산자 우선순위와 같다.
- 연산자 함수와 자바
	- 자바를 코틀린에서 호출하는 경우에는 함수 이름이 코틀린의 관례에 맞아 떨어지기만 하면 항상 연산자 식을 사용해 그 함수를 호출할 수 있다.
- 코틀린 연산자가 자동으로 교환 법칙을 지원하지는 않는다.
- 비트 연산자에 대해 특별한 연산자 함수를 사용하지 않는다.
	- 중의 연산자 표기법을 지원하는 일반 함수를 사용해 비트 연산을 수행한다.
	- `shl`: 왼쪽 시프트(자바 `<<`)
	- `shr`: 오른쪽 시프트(부호 비트 유지, 자바 `>>`)
	- `ushr`: 오른쪽 시프트(0으로 부호 비트 설정, 자바 `>>>`)
	- `and`: 비트 곱(자바 `&`)
	- `or`: 비트 합(자바 `|`)
	- `xor`: 비트 배타 합(자바 `^`)
	- `inv`: 비트 반전(자바 `~`)

### 복합 대입 연산자 오버로딩

- 복합 대입 연산자: `+=`, `-=` 등

```kotlin
var p1 = Point(1, 2)  
p1 += Point(2, 3)
```

- `+=` 연산이 객체에 대한 참조를 다른 참조로 바꾸기보다 원래 객체 내부 상태를 변경하고 싶은 경우는, 반환 타입이 `Unit`인 `plusAssign` 함수를 정의하면 된다.
- 이론적으로 `+=`를 `plus`, `plusAssign` 양쪽으로 컴파일할 수 있다.
	- 두 함수가 모두 정의되어 있고, `+=`에 사용가능한 경우 컴파일러는 오류를 보고한다.
	- `var`를 `val`로 바꿔서 `plusAssign` 적용이 불가능하게 할 수 도 있다.
	- 가능하면 `plus`와 `plusAssign` 연산을 동시에 정의하지 말라.
- 코틀린 표준 라이브러리는 컬렉션에 대해 두 가지 접근 방법을 제공한다.
	- `+`, `-`는 항상 새로운 컬렉션을 반환
	- `+=`, `-=` 연산자는 항상 변경 가능한 컬렉션에 작용해 메모리에 있는 객체 상태 변화
		- 읽기 전용 컬렉션에서 `+=`와 `-=`는 변경을 적용한 복사본을 반환

### 단한 연산자 오버로딩

- 오버로딩할 수 있는 단한 산술 연산자

식|함수 이름
---|---
`+a`|times
`-a`|div
`!a`|mod(1.1부터 rem)
`++a`, `a++`|plus
`--a`, `a--`|minus

## 비교 연산자 오버로딩

### 동등성 연산자: equals

- `==` 연산자 호출을 `equals` 메소드 호출로 컴파일한다.
- `!=` 연산자를 사용하는 식도 `equals` 호출로 컴파일된다.
- `==`와 `!=`는 내부에 인자가 널인지 검사하므로 다른 연산과 달리 널이 될 수 있는 값에도 적용할 수 있다.

![](Pasted%20image%2020230303183737.png)

- `equals` 함수는 `Any`의 `equals`를 오버라이드하면서 `operator`를 붙이지 않아도 된다. `Any`의 `equals`에는 `operator`가 붙어있다.

### 순서 연산자: compareTo

- 자바에서 `Comparable` 인터페이스를 구현해야 클래스를 비교할 수 있다.
	- `Complarable`에 들어있는 `compareTo` 메소드는 한 객체와 다른 객체의 크기를 비교해 정수로 나타내준다.
- 코틀린도 똑같은 `Comparable` 인터페이스를 지원한다.
- 비교 연산자(`<`, `>`. `<=`, `>=`)는 `compareTo` 호출로 컴파일된다.
- 코틀린 표준 라이브러리 `comparaValuesBy`
	- 인자로 넣은 여러 개의 식으로 두 객체의 대소를 알려주는 0이 아닌 값이 처음 나올때까지 인자로 받은 함수를 차례로 호출해 두 값을 비교하며, 모든 함수가 0을 반환하면 0을 반환한다.

```kotlin
class Person(  
   val firstName: String, val lastName: String  
) : Comparable<Person> {  
  
   override fun compareTo(other: Person): Int {  
      return compareValuesBy(this, other, Person::lastName, Person::firstName)  
   }  
}
```

## 컬렉션과 범위에 대해 쓸 수 있는 관례

### 인덱스로 원소에 접근: get과 set

- `get()` 메소드에 `operator` 변경자를 붙이면, 각괄호를 사용한 연산을 할 수 있다.

```kotlin
data class Point(val x: Int, val y: Int) {  
  
   operator fun get(index: Int): Int {  
      return when (index) {  
         0 -> x  
         1 -> y  
         else -> throw IndexOutOfBoundsException("Invalid coordinate $index")  
      }  
   }
}
```

```kotlin
val p1 = Point(100, 200)  
println(p1[1])
```

- 2차원 행렬이나 배열을 표현하는 클래스에서 `operator fun get(rowIndex: Int, colIndex: Int)` 를 정의 하면 `matrix[row, col]`로 그 메소드를 호출할 수 있다.
- `set()`도 비슷하게 지정이 가능하다.

```kotlin
operator fun set(index: Int, value: Int) {  
   when (index) {  
      0 -> x = value  
      1 -> y = value  
      else -> throw IndexOutOfBoundsException("Invalid coordinate $index")  
   }  
}
```

### in 관례

- `in` 연산자와 대응 하는 함수는 `contains()` 다.

```kotlin
class Rectangle(val upperLeft: Point, val lowerRight: Point) {  
  
   operator fun contains(p: Point): Boolean {  
      return p.x in upperLeft.x until lowerRight.x &&  
         p.y in upperLeft.y until lowerRight.y  
   }  
}
```

```kotlin
val rect = Rectangle(Point(10, 20), Point(50, 50))  
println(Point(20, 30) in rect)
```

### rangeTo 관례

- `..` 연산자는 `rangeTo()` 함수를 간략하게 표현하는 방법이다.
- 이 연산자는 아무 클래스에나 정의할 수 있다.
- 하지만 `Comparable` 인터페이스를 구현하면 `rangeTo()`를 정의할 필요가 없다.
	- 코틀린 표준 라이브러리에는 모든 `Comparable` 객체에 대해 적용 가능한 `rangeTo` 함수가 들어있다.

```kotlin
operator fun <T: Comparable<T>> T. rangeTo (that: T) : ClosedRange<T>
```

### for 루프를 위한 iterator 관례

- `for` 루프 안에서 `in` 연산자는 의미가 다르다.
	- `iterator()` 함수를 호출해서 이터레이터를 얻은 다음, `hasNext()` 와 `next()` 호출을 반복하는 식으로 변환한다.

```kotlin
operator fun ClosedRange<LocalDate>.iterator(): Iterator<LocalDate> =  
   object : Iterator<LocalDate> {  
      var current = start  
  
      override fun hasNext(): Boolean {  
         return current <= endInclusive  
      }  
  
      override fun next(): LocalDate {  
         return current.apply {  
            current = plusDays(1)  
         }  
      }  
   }```

```kotlin
val newYear = LocalDate.ofYearDay(2017, 1)  
  
for (dayOff in newYear.minusDays(1)..newYear) {  
   println(dayOff)  
}
```