# 제네릭스

- 실체화한 타입 파라미터(reified type parameter)를 사용하면 인라인 함수 호출에서 타입 인자로 쓰인 구체적인 타입을 실행 시점에 알 수 있다.
- 일반 클래스나 함수의 경우 타입 인자 정보가 실행 시점에 사라지기 때문에 구체적인 타입을 알 수 없다.
- 선언 지점 변성(declaration-site variance)을 사용하면 기저 타입은 같지만 타입 인자가 다른 두 제네릭 타입이 있을 때, 타입 인자의 상위/하위 타입 관계에 따라 두 제네릭 타입의 상위/하위 타입 관계가 어떻게 되는지 지정할 수 있다.

## 제네릭 타입 파라미터

- 제네릭 타입의 인스턴스를 만들려면 타입 파라미터를 구체적인 타입 인자로 치환해야 한다.
- 클래스에 타입 파라미터가 여럿 있을 수도 있다.
- 코틀린 컴파일러는 보통 타입과 마찬가지로 타입 인자도 추론할 수 있다.

### 제네릭 함수와 프로퍼티

- 제네릭 함수를 호출할 때는 반드시 구체적 타입으로 타입 인자를 넘겨야 한다.
- 대부분 컴파일러가 타입 인자를 추론할 수 있다.

![](assets/Pasted%20image%2020230321182127.png)

- 제네릭 함수를 정의할 때와 마찬가지 방법으로 제네릭 확장 프로퍼티를 선언할 수 있다.
- 일반 프로퍼티는 타입 파라미터를 가질 수 없다.

![](assets/Pasted%20image%2020230321182207.png)

### 제네릭 클래스 선언

- 자바와 마찬가지로 타입 파라미터를 넣은 꺽쇠 기호를 클래스 이름 뒤에 붙이면 클래스를 제네릭하게 만들 수 있다.
- 제네릭 클래스를 확장하는 클래스를 정의하려면, 구체적인 타입을 넘길 수도 있고 타입 파라미터로 받은 타입을 넘길 수도 있다.

![](assets/Pasted%20image%2020230321182842.png)

### 타입 파라미터 제약

- 타입 파라미터 제약: 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능
- 상한(upper bound): 그 제네릭 타입을 인스턴스화할 때 사용하는 타입 인자는 그 상한 타입이거나 그 상한 타입의 하위 타입이어야 한다.
	- 자바에서는 `<T extends Number> T sum(List<T> list)`

```kotlin
fun <T: Number> List<T>.sum : T
```

- 타임 파라미터에 둘 이상의 제약을 가해야 되는 경우는 약간 다른 구문을 사용한다.

```kotlin
fun <T> ensureTrailingPeriod(seq: T) where T : CharSequence, T : Appendable {  
   // ...  
}
```

### 타입 파라미터를 널이 될 수 없는 타입으로 한정

- 아무런 상한을 정하지 않은 타입 파라미터는 결과적으로 `Any?`를 상한으로 정한 파라미터와 같다.
- `<T : Any>`라는 제약은 T 타입이 항상 널이 될 수 없는 타입이 되게 보장한다.
- `Any`를 사용하지 않고 다른 널이 될 수 없는 타입을 사용해 상한을 정해도 된다.

## 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터

- JVM 제네릭스는 타입 소거(type erasure)를 사용해서 구현된다.
- 실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않다.

### 실행 시점의 제네릭: 타입 검사와 캐스트

- 타입 소거로 인해 코틀린 제네릭 타입 인자 정보는 런타임에 지워진다.
	- 하지만 타입 소거로 전반적인 메모리 사용량이 줄어든다.
- 이는 제네릭 클래스 인스턴스가 그 인스턴슬르 생성할 때 쓰인 타입 인자에 대한 정보를 유지하지 않는다는 뜻이다.
- `List<String>`과 `List<Int>`의 경우, 컴파일러는 두 리스트를 서로 다른 차입으로 인식하지만 실행 시점에 그 둘은 완전히 같은 객체다.
	- 하지만 컴파일러가 타입 인자를 알고 올바른 타입의 값만 각 리스트에 넣도록 보장해준다.
- 타입 소거로 인해 실행 시점에 타입 인자를 검사할 수 없다.

![](assets/Pasted%20image%2020230322182037.png)

- 스타 프로젝션을 통해서 타입 인자를 명시하지 않고 리스트 타입이라는 사실은 확인할 수 있다.

![](assets/Pasted%20image%2020230322182052.png)

- `is` 뿐만 아니라 `as` 도 마찬가지다.
- 코틀린 컴파일러는 컴파일 시점에 타입 정보가 주어진 경우에는 `is` 검사를 수행하게 허용한다.

![](assets/Pasted%20image%2020230322182413.png)

### 실체화한 타입 파라미터를 사용한 함수 선언

- 인라인 함수의 타입 파라미터는 실체화되므로 실행 시점에 인라인 함수의 타입 인자를 확인할 수 있다.
- 인라인 함수에 타입 파라미터를 `reified`로 지정하면 실행시점에 타입 인자를 확인할 수 있다.

```kotlin
inline fun <reified T> isA(value: Any) = value is T
```

- 인라인 함수에는 실체화한 타입 파라미터가 여럿 있거나 실체화한 타입 파라미터와 실체화하지 않은 타입 파라미터가 함께 있을 수도 있다.
- 인라인 함수는 본문을 구현한 바이트코드를 그 함수가 호출되는 모든 지점에 삽입한다. 
	- 따라서 컴파일러는 인라인 함수를 호출하는 각 부분의 정확한 타입 인자를 알 수 있어서 바이트 코드를 삽입할 수 있다.
- 자바 코드에서는 `reified` 타입 파라미터를 사용하는 `inline` 함수를 호출할 수 없다.
- 성능을 좋게 하려면 인라인 함수의 크기를 계속 관찰해야한다. 함수가 커지면 실체화한 타입에 의존하지 않는 부분을 별도의 일반 함수로 뽑아내는 편이 낫다.

### 실체화한 타입 파라미터로 클래스 참조 대신

- 타입 인자를 파라미터로 받는 API에 대한 코틀린 어댑터를 구축하는 경우 실체화한 타입 파라미터를 자주 사용한다.

![](assets/Pasted%20image%2020230322185409.png)