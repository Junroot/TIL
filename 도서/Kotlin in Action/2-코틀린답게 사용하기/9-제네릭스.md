# 제네릭스

- 실체화한 타입 파라미터(reified type parameter)를 사용하면 인라인 함수 호출에서 타입 인자로 쓰인 구체적인 타입을 실행 시점에 알 수 있다.
- 일반 클래스나 함수의 경우 타입 인자 정보가 실행 시점에 사라지기 때문에 구체적인 타입을 알 수 없다.
- 선언 지점 변성(declaration-site variance)을 사용하면 기저 타입은 같지만 타입 인자가 다른 두 제네릭 타입이 있을 때, 타입 인자의 상위/하위 타입 관계에 따라 두 제네릭 타입의 상위/하위 타입 관계가 어떻게 되는지 지정할 수 있다.

## 제네릭 타입 파라미터

- 제네릭 타입의 인스턴스를 만들려면 타입 파라미터를 구체적인 타입 인자로 치환해야 한다.
- 클래스에 타입 파라미터가 여럿 있을 수도 있다.
- 코틀린 컴파일러는 보통 타입과 마찬가지로 타입 인자도 추론할 수 있다.

### 제네릭 함수와 프로퍼티

- 제네릭 함수를 호출할 때는 반드시 구체적 타입으로 타입 인자를 넘겨야 한다.
- 대부분 컴파일러가 타입 인자를 추론할 수 있다.

![](assets/Pasted%20image%2020230321182127.png)

- 제네릭 함수를 정의할 때와 마찬가지 방법으로 제네릭 확장 프로퍼티를 선언할 수 있다.
- 일반 프로퍼티는 타입 파라미터를 가질 수 없다.

![](assets/Pasted%20image%2020230321182207.png)

### 제네릭 클래스 선언

- 자바와 마찬가지로 타입 파라미터를 넣은 꺽쇠 기호를 클래스 이름 뒤에 붙이면 클래스를 제네릭하게 만들 수 있다.
- 제네릭 클래스를 확장하는 클래스를 정의하려면, 구체적인 타입을 넘길 수도 있고 타입 파라미터로 받은 타입을 넘길 수도 있다.

![](assets/Pasted%20image%2020230321182842.png)

### 타입 파라미터 제약

- 타입 파라미터 제약: 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능
- 상한(upper bound): 그 제네릭 타입을 인스턴스화할 때 사용하는 타입 인자는 그 상한 타입이거나 그 상한 타입의 하위 타입이어야 한다.
	- 자바에서는 `<T extends Number> T sum(List<T> list)`

```kotlin
fun <T: Number> List<T>.sum : T
```

- 타임 파라미터에 둘 이상의 제약을 가해야 되는 경우는 약간 다른 구문을 사용한다.

```kotlin
fun <T> ensureTrailingPeriod(seq: T) where T : CharSequence, T : Appendable {  
   // ...  
}
```

### 타입 파라미터를 널이 될 수 없는 타입으로 한정

- 아무런 상한을 정하지 않은 타입 파라미터는 결과적으로 `Any?`를 상한으로 정한 파라미터와 같다.
- `<T : Any>`라는 제약은 T 타입이 항상 널이 될 수 없는 타입이 되게 보장한다.
- `Any`를 사용하지 않고 다른 널이 될 수 없는 타입을 사용해 상한을 정해도 된다.