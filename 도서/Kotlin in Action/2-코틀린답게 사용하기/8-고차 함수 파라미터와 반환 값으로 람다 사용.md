# 고차 함수: 파라미터와 반환 값으로 람다 사용

## 고차 함수

- 고차 함수: 다른 함수를 인자로 받거나 함수를 반환하는 함수

### 함수 타입

- 코틀린의 타입 추론으로 인해 변수 타입을 지정하지 않아도 람다를 변수에 대입할 수 있다.
- 반환 타입이 널이 될 수 있는 타입

```kotlin
var canReturnNull: (Int, Int) -> Int? = { x, y -> null }
```

- 함수 타입 전체가 널일 될 수 있는 타입

```kotlin
var funOrNull: ((Int, Int) -> Int)? = null
```

- 함수 타입에서 파라미터 이름을 지정할 수도 있다.
	- 타입 검사 시 무시되고, 파라미터 이름이 꼭 함수 타입 선언의 파라미터 일므과 일치하지 않지만, 코드 가독성이 좋아지고 IDE 코드 자동 완성을 사용할 수 있다.

```kotlin
performRequest {  
   code, content ->  println("$code, $content")  
}

fun performRequest(  
   callback: (code: Int, content: String) -> Unit  
) {  
   // ...  
}
```

### 인자로 받은 함수 호출

![](assets/Pasted%20image%2020230320190252.png)

- 인텔리J 아이디어에서는 디버깅할 때 람다 코드 내부를 한 단계씩 실행해볼 수 있는 스마트 스테핑(smart stepping)을 제공한다.

### 자바에서 코틀린 함수 타입 사용

- 컴파일된 코드 안에서 함수 타입은 일반 인터페이스로 바뀐다.
- 코틀린 표준 라이브러리는 함수 인자의 개수에 따라 `Function0<R>`(인자가 없는 함수), `Function1<P1,R?>`(인자가 하나인 함수) 등의 인터페이스를 제공한다.
	- 각 인터페이스에는 `invoke` 메소드 정의가 하나 들어있다.
- 자바 8 람다를 넘기면 자동으로 함수 타입의 값으로 변환된다.

![](assets/Pasted%20image%2020230320191001.png)

- 자바 8 이전 자바에서는 필요한 `FunctionN` 인터페이스의 `invoke` 메소드를 구현하는 무명 클래스를 넘기면 된다.

![](assets/Pasted%20image%2020230320191006.png)

### 디폴트 값을 지정한 함수 타입 파라미터나 널이 될 수 있는 함수 타입 파라미터

- 파라미터를 함수 타입으로 선언할 때도 디폴트 값을 정할 수 있다.
- 널이 될 수 있는 함수 타입을 사용할 수도 있다.

### 함수를 함수에서 반환

- 함수를 반환하는 함수도 존재한다.
	- 상태나 다른 조건에 따라 달라질 수 있는 로직

### 람다를 활용한 중복 제거

- 전략 패턴: 함수 타입을 사용해 전략을 표현할 수 있고 경우에 따라 다른 람다 식을 넘김으로써 중복을 제거하고 여러 전략을 사용할 수 있다.

## 인라인 함수: 람다의 부가 비용 없애기

- 코틀린은 보통 람다를 무명 클래스로 컴파일하지만 그렇다고 람다 식을 사용할 때마다 새로운 클래스가 만들어지지는 않는다.
- 람다가 변수를 포획한다면 람다가 생성되는 시점마다 새로운 무명 클래스 객체가 생긴다. 이런 경우 실행 시점에 무명 클래스 생성에 따른 부가 비용이 든다.
- `inline` 변경자를 어떤 함수에 붙이면 컴파일러는 그 함수를 호출하는 모든 문장을 함수 본문에 해당하는 바이트코드로 바꿔치기 해준다.

### 인라이닝이 작동하는 방식

- 함수를 호출하는 코드를 함수를 호출하는 바이트코드 대신 함수 본문을 번역한 바이트코드로 컴파일한다.
- 함수 본문뿐 아니라 함께 파라미터로 전달된 람다의 본문도 함께 인라이닝된다.
- 인라인 함수를 호출하면서 람다를 넘기는 대신 함수 타입의 변수를 넘길 수 있다.
	- 이런 경우 인라인 함수를 호출하는 코드 위치에서는 람다 본문은 인라이닝 되지 않고, 함수 본문만 인라이닝 된다.
- 한 인라인 함수를 두 곳에서 각각 다른 다른 람다를 사용해 호출한다면 그 두 호출은 각각 따로 인라이닝 된다.

### 인라인 함수의 한계

- 파라미터로 받은 람다를 다른 변수에 저장하고 나중에 그 변수를 사용한다면 인라이닝할 수 없다.
	- 이라이닝할 수 없는 경우에는 "Illegal usage of inline-parameter"라는 메시지와 함께 인라이닝을 금지시킨다.

![](assets/Pasted%20image%2020230320200331.png)

- 둘 이상의 람다를 인자로 받는 함수에서 일부 람다만 인라이닝해야 되는 경우
	- 인라이닝 하면 안되는 람다를 파라미터로 받는다면 `noinline` 변경자를 파라미터 이름 앞에 부텨서 인라이닝을 금지할 수 있다.

```kotlin
inline fun foo(inlined: () -> Unit, noinline noInlined: () -> Unit) {  
   // ...  
}
```

- 자바에서 코틀린에 정의한 인라인 함수를 호출하면, 컴파일러는 인라인 함수를 인라이닝하지 않고 일반 함수 호출로 컴파일 한다.

### 컬렉션 연산 인라이닝

- `filter` 와 `map` 은 인라인 함수다. 따라서 그 두 함수의 본문은 인라이닝되며, 추가 객체나 클래스 생성은 없다.
	- 하지만 리스트를 걸러낸 결과를 저장하는 중간 리스트를 만든다.
- `asSequence`를 통해 리스트 대신 시퀀스를 사용하면, 람다를 저장해야 하므로 람다를 인라인하지 않는다.
	- 인라이닝되지 않기 때문에 크기가 작은 컬렉션은 오히려 일반 컬렉션 연산이 더 성능이 나을 수도 있다.
	- 스퀀스를 통해 성능을 향상시킬 수 있는 경우는 컬렉션 크기가 큰 경우 뿐이다.