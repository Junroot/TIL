# 웹 애플리케이션 개발

## 정보 보여주기

- 스프링 웹 애플리케이션에서는 데이터를 가져오고 처리하는 것이 컨트롤러의 일이다.
- 브라우저에 보여주는 데이터를 HTML로 나타내는 것은 뷰가 하는 일이다.

### 도메인 설정하기

- 도메인: 애플리케이션의 이해에 필요한 개념을 다루는 영역

```kotlin
class Ingredient(val id: String, val name: String, val type: Type) {  
  
   enum class Type {  
      WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE  
   }  
}
```

```kotlin
data class Taco(val name: String? = null, val ingredients: List<String>? = null)
```

### 컨트롤러 클래스 생성하기

- 컨트롤러: HTTP 요청을 처리하고, 브라우저에 보여줄 HTML을 뷰에 요청하거나, 또는 REST 형태의 응답 몸체에 직접 데이터를 추가한다.

```kotlin
@RequestMapping("/design")  
@Controller  
class DesignTacoController {  
  
   companion object {  
      val log = LoggerFactory.getLogger(DesignTacoController::class.java)  
   }  
  
   @GetMapping  
   fun showDesignForm(model: Model): String {  
      val ingredients = listOf(  
         Ingredient("FLTO", "Flour Tortilla", Ingredient.Type.WRAP),  
         Ingredient("COTO", "Corn Tortilla", Ingredient.Type.WRAP),  
         Ingredient("GRBF", "Ground Beef", Ingredient.Type.PROTEIN),  
         Ingredient("CARN", "Carnitas", Ingredient.Type.PROTEIN),  
         Ingredient("TMTO", "Diced Tomatoes", Ingredient.Type.VEGGIES),  
         Ingredient("LETC", "Lettuce", Ingredient.Type.VEGGIES),  
         Ingredient("CHED", "Cheddar", Ingredient.Type.CHEESE),  
         Ingredient("JACK", "Monterrey Jack", Ingredient.Type.CHEESE),  
         Ingredient("SLSA", "Salsa", Ingredient.Type.SAUCE),  
         Ingredient("SRCR", "Sour Cream", Ingredient.Type.SAUCE)  
      )  
  
      val types = Ingredient.Type.values()  
      for (type in types) {  
         model.addAttribute(  
            type.name.lowercase(),  
            filterByType(ingredients, type)  
         )  
      }  
  
      model.addAttribute("taco", Taco())  
  
      return "design"  
   }  
  
   private fun filterByType(ingredients: List<Ingredient>, type: Ingredient.Type): List<Ingredient> {  
      return ingredients.filter { it.type == type }  
   }  
}
```

- `@Slf4j`: 컴파일 시점 시에 Lombok에 제공되며, 이 클래스에서 자동으로 SLF4J Logger를 생성한다.
- `@Controller`: `DesignTacoController` 클래스가 컨트롤러로 식별되게 하며, 컴포넌트 검색을 해야 한다는 것을 나타낸다. 스프링이 해당 클래스를 찾은 후 스프링 애플리케이션 컨텍스트의 빈으로 인스턴스를 자동 생성한다.
- `@RequestMapping`: 
	- 클래스 수준으로 적용:해당 컨트롤러가 처리하는 요청의 종류를 나타낸다.
- `@Getmapping`: HTTP GET 요청이 수신될 때 그 요청을 처리하기 위해 메서드가 호출됨을 나타낸다.
	- 스프링 4.3 이전에는 이것 대신 메서드 수준의 `@RequestMapping` 애노테이션을 사용할 수 있었다.

```kotlin
@RequestMapping(method=RequestMethod.GET)
```

|애노테이션|설명|
|---|---|
|`@RequestMapping`|다목적 요청을 처리한다.|
|`@GetMapping`|HTTP GET 요청을 처리한다.|
|`@PostMapping`|HTTP POST 요청을 처리한다.|
|`@PutMapping`|HTTP PUT 요청을 처리한다.
|`@DeleteMapping`|HTTP DELETE 요청을 처리한다.|
|`@PatchMapping`|HTTP PATCH 요청을 처리한다.|

- `Model`은 컨트롤러와 데이터를 보여주는 뷰 사이에서 데이터를 운반하는 객체다.
	- `Model` 객체의 속성에 있는 데이터는 뷰가 알 수 있는 서블릿 요청 속성들도 복사된다.
- 메서드 마지막에 반환되는 `String` 값은 뷰의 논리적인 이름이다.

7.1.3~