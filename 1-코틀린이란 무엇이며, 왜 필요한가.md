---
tags:
  - 도서/Kotlin-in-Action
title: 1-코틀린이란 무엇이며, 왜 필요한가
---



## 코틀린의 주요 특성

### 대상 플랫폼: 서버, 안드로이드 등 자바가 실행되는 모든 곳

- 코틀린을 활용할 수 있는 가장 일반적인 영역
  - 서버상의 코드
  - 안드로이드 디바이스에서 실행되는 모바일 애플리케이션
- 코틀린은 개발 과정에서 수행해야 하는 모든 과업에 있어 폭넓게 생산성을 향상시켜준다.

### 정적 타입 지정 언어

- 정적 타입: 모든 프로그램 구성 요소의 타입을 컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드와 메서드를 사용할 떄마다 컴파일러가 타입을 검증해준다.
  - 성능: 실행 시점에 어떤 메서드를 호출할지 알아내는 과정이 필요 없으므로 메서드 호출이 더 빠르다.
  - 신뢰성: 컴파일러가 프로그램의 정확성을 검증하기 때문에 실행 시 프로그램이 오류로 중단될 가능성이 더 적어진다.
  - 유지 보수성: 코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있기 때문에처음 보는 코드를 다룰 떄도 더 쉽다.
  - 도구 지원: 정적 타입 지정을 활용하면 더 안전하게 리팩토링 할 수 있고, 도구는 더 정확한 코드 완성 기능을 제공할 수 있으며, IDE의 다른 지원 기능도 더 잘 만들 수 있다.
- nullable type 지원
  - null pointer exception이 발생할 수 있는 검사를 할 수 있어서 프로그램의 신뢰성을 높일 수 있다.
- 함수 타입에 대한 지원
  - 함수형 프로그래밍을 지원한다.

### 함수형 프로그래밍과 객체지향 프로그래밍

- 함수형 프로그래밍의 핵심 개념
  - 일급 시민인 함수: 함수를 일반 값처럼 다룰 수 있다. 함수를 변수에 저장할 수 있고, 함수를 인자로 다른 함수에 전달할 수 있으며, 함수에서 새로운 함수를 만들어서 반환할 수 있다.
  - 불변성: 함수형 프로그래밍에서는 일단 만들어지고 나면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용해 프로그램을 작성한다.
  - 부수 효과 없음: 함수형 프로그래밍에서는 입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 바깥 환경과 상호작용하지 않는 순수 함수를 사용한다.
- 함수형 프로그래밍의 장점
  - 코드가 간결하다.
  - 다중 스레드를 사용해도 안전하다.
  - 테스트하기 쉽다.
- 코틀린의 함수형 프로그래밍 지원
  - 함수 타입을 지원함에 따라 함수를 파라미터로 받거나 함수를 반환할 수 있다.
  - 람다 식을 지원함에 따라 번거로운 준비 코드를 작성하지 않아도 코드 블록을 쉽게 정의하고 여기저기 전달할 수 있다.
  - 데이터 클래스는 불변적인 VO를 간편하게 만들 수 있는 구문을 제공한다.
  - 코틀린 표준 라이브러리는 객체와 컬렉션을 함수형 스타일로 다룰 수 있는 API를 제공한다.

### 무료 오픈소스

- https://github.com/jetbrains/kotlin

## 코틀린 응용

### 코틀린 서버 프로그래밍

- 자바 코드와 매끄럽게 상호운용할 수 있다.
- 코틀린이 제공하는 깔끔하고 간결한 DSL 기능을 활용할 수 있다.

### 코틀린 안드로이드 프로그래밍

- 코틀린 언어의 특성과 안드로이드 프레임워크의 특별한 컴파일러 플러그인 지원을 조합하면 안드로이드 애플리케이션 개발의 생산성을 높일 수 있다.
- null 값을 정확히 추적하며 애플리케이션의 신뢰성을 높일 수 있다.
- 코틀린 컴파일러가 생성한 바이트코드는 일밪거인 자바 코드와 똑같이 효율적으로 실행되므로 성능 측면에서 아무 손해가 없다.
- 대부분의 코틀린 표준 라이브러리 함수는 인자로 받은 람다 함수를 인라이닝하여, 새로운 객체가 만들어지지 않으므로 객체 증가로 인해 GC가 늘어나서 프로그램이 자주 멈추는 일도 없다.

## 코틀린의 철학

### 실용성

- 코틀린은 실제 문제를 해결하기 위해 만들어진 실용적인 언어다. 다른 프로그래밍 언어가 채택한 이미 성공적으로 검증된 해법과 기능에 의존한다.
- 코틀린은 어느 특정 프로그래밍 스타일이나 패러다임을 사용할 것을 강제로 요구하지 않는다.
- 코틀린은 도구를 강조한다. 인텔리J 아이디어의 개발과 컴파일러의 개발이 맞물려 이뤄져있다.

### 간결성

- 코틀린은 코드에서 의미가 없는 부분을 줄이고, 언어가 요구하는 구조를 만족시키기 위해 별 뜻은 없지만 프로그램에 꼭 넣어야 하는 부수적인 요소를 줄이기 위해 많은 노력을 기울였다.
  - getter, setter, 생성자 파라미터 등
- 다양한 표준 라이브러리를 제공하여 반복되거나 길어질 수 있는 코드를 라이브러리 함수 호출로 대치할 수 있다.
- 코틀린 설계 목표에는 소스코드를 짧게 만든다는 내용은 들어있지 않다.
  - 연산자 오버로딩을 지원하지만, 언어가 제공하지 않는 연산자는 프로그래머가 정의할 수 있게 허용하지 않는다.

### 안전성

- 프로그램에서 발생할 수 있는 오류 중에서 일부 유형의 오류를 프로그램 설계가 원천적으로 방지해준다.
- 코틀린이 JVM을 사용하면서 안전성 보장
  - 메모리 안전성
  - 버퍼 오버플로우 방지
  - 동적으로 할당한 메모리를 잘못 사용함으로 발생할 수 있는 문제 예방
  - 타입 안전성
- `?` 타입을 통해 `NullPointerException` 방지
- 타입 검사와 캐스트가 한 연산자에 의해 이뤄져서, `ClassCassException` 방지

### 상호운용성

- 자바와 코틀린 코드를 프로젝트에서 원하는 대로 섞어 쓸 수 있다.
- 코틀린은 기존 자바 라이브러리를 가능하면 최대한 활용한다.
- 코틀린이 제공하는 도구도 다중 언어 프로젝트를 완전히 지원한다.

## 코틀린 도구 사용

### 코틀린 코드 컴파일

- 코틀린 소스코드: `.kt`

- 코틀린 컴파일러는 자바 컴파일러가 자바 소스코드를 컴파일할 때와 마찬가지로 코틀린 소스코드를 분석해서 `.class` 파일을 만들어낸다.

- 표준 패키징 과정

  ```shell
  kotlinc <소스파일 또는 디렉터리> -include-runtime -d <jar 이름>
  java -jar <jar 이름>
  ```

- 코틀린 컴파일러로 컴파일한 코드는 코틀린 런타임 라이브러리에 의존한다. 메이븐과 그레이들은 애플리케이션을 패키지할 때 알아서 코틀린 런타임을 포함시켜준다.

### 대화형 셸

- REPL에서 코틀린 코드를 한 줄 입력하면 즉시 그 코드를 실행한 결과를 볼 수 있다.

### 자바-코틀린 변환기

- IntelliJ IDEA에서 변환기 사용하는 법
  - `code` => `convert java file to kotlin file`
