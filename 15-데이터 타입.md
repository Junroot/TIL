---
title: 15-데이터 타입
tags:
  - 도서/Real-MySQL
---
- 컬럼의 데이터 타입과 길이를 선정할 때 가장 주의할 사항은 다음과 같다.
	- 저장되는 값의 성격에 맞는 최적의 타입을 선정
	- 가변 길이 컬럼은 최적의 길이를 지정
	- 조인 조건으로 사용되는 컬럼은 똑같은 데이터 타입으로 선정

## 문자열(CHAR와 VARCHAR)

### 저장 공간

- CHAR와 VARCHAR의 공통점은 문자열을 저장할 수 있는 데이터 타입이라는 점이고, 가장 큰 차이는 고정 길이냐 가변 길이냐다.
- CHAR(1)과 VARCHAR(1) 타입을 사용할 때 사용되는 저장 공간의 크기
	- 두 문자열 타입 모두 한 글자를 저장할 때 사용하는 문자 집합에 따라 실제 저장 공간은 1~4바이트까지 사용된다.
	- 하지만 VARCHAR 타입은 저장할 때 문자열 길이를 관리하기 위한 1~2바이트의 공간을 추가로 더 사용한다.
	- VARCHAR 타입의 길이가 255바이트 이하이면 1바이트만 사용하고, 256바이트 이상이면 2바이트를 사용한다.
	- VARCHAR 타입의 길이 표현은 2바이트보다 클 수 없기 때문에, VARHCAR 타입의 최대길이는 65,536 바이트 이상으로 설정할 수 없다.
- CHAR 타입과 VARCHAR 타입을 결정할 때 중요한 판단 기준
	- 저장되는 문자열의 길이가 대개 비슷한가?
	- 컬럼의 값이 자주 변경되는가?
- ![](assets/Pasted%20image%2020241001024509.png)
	- 위 상황에서는 아래와 같이 저장된다.
		- ![](assets/Pasted%20image%2020241001024544.png)
	- VARCHAR 타입을 사용한다면 아래와 같이 저장된다.
		- ![](assets/Pasted%20image%2020241001024556.png)
	- 여기서 fd2 컬럼의 값을 "ABCDE"로 수정한다고하면, 
		- CHAR 타입은 공간이 10바이트 준비되어 있으므로 그냥 컬럼의 값을 업데이트만 하면 된다.
		- VARCHAR 타입은 길이가 더 큰 값으로 변경될 때 레코드 자체를 다른 공간으로 옮겨서(Row migration) 저장해야 한다.
- 값의 길이가 고정적일 때는 당옇니 CHAR 타입을 사용하고, 값이 2~3바이트씩 차이가 나더라도 자주 변경될 수 있는 값은 CHAR 타입을 사용하는 것이 좋다.
- 다른 DBMS와 달리 MySQL은 CHAR(10) 또는 VARCHAR(10)으로 컬럼을 정의하면 이 컬럼은 10바이트를 저장할 수 있는게 아니라, 10글자를 저장할 수 있는 공간을 의미한다.

### 저장 공간과 스키마 변경(Online DDL)

- MySQL 서버에서는 데이터가 변경되는 도중에도 스키마를 변경할 수 있도록 Online DDL 이라는 기능을 제공한다.
- 하지만 변경 작업의 특성에 따라 SELECT는 가능하지만 INSERT나 UPDATE 같은 데이터 변경은 허용되지 않을 수도 있다.
	- VARCHAR 데이터 타입을 사용하는 컬럼의 길이를 늘리는 작업은 utf8mb4 기준 길이가 60(240 바이트)에서 64(256바이트)로 늘리는 경우 COPY 알고리즘을 사용하고 SHARED 잠금을 사용하여 데이터를 변경하지 못하도록 막고 테이블의 레코드를 복사하는 방식으로 처리한다.
	- 문자열 길이를 저장하는 공간의 크기를 2바이트로 바꿔야하기 때문이다.

### 문자 집합(캐릭터 셋)

- MySQL 서버에서 각 테이블의 컬럼은 모두 서로 다른 문자 집합을 사용해 문자열 값을 사용할 수 있다.
- 한글 기반 서비스에서는 euckr 또는 utf8mb4 문자 집합을 사용하며, 일본어인 경우에는 cp932 또는 utf8mb4를 적용하는 것이 일반적이다.
- 최근의 웹 서비스나 스마트폰 애플리케이션은 여러 나라의 언어를 동시에 지원하기 위해 기본적으로 utf8mb4를 사용하는 추세다.
- MySQL 서버에서 사용 가능한 문자 집합은 `SHOW CHARACTER SET` 명령으로 확인해 볼 수 있다.
	- latin 계열의 문자 집합은 알파벳이나 숫자, 그리고 키보드의 특수 문자로만 구성된 문자열만 저장해도 될 때 저장 공간을 절약하면서 사용할 수 있는 문자 집합이다.
	- euckr은 한국어 전용으로 사용되는 문자 집합이며, 모든 글자는 1~2바이트를 사용한다.
	- utf8mb4은 다국어 문자를 포함할 수 있는 컬럼에 사용하기에 적합하다. 컬럼의 문자 집합이 utf8mb4로 생성되면 일반적으로 디스크에 저장할 때는 한 글자를 저장하기 위해 1~4바이트까지 사용한다. 하지만 utf8mb4 문자 집합을 사용하는 문자열 값이 메모리에 기록될 때는 실제 문자열의 길이와 관계없이 문자당 4바이트로 공간이 할당되는 경우도 있다.
	- utf8은 utf8mb4의 부분 집합인데, MySQL 서버에서 utf8mb4가 도입되기 전에 주로 사용됐다. utf8 문자 집합은 한 글자를 저장하기 위해 1~3바이트까지 사용한다. 한 글자를 저장하기 위한 공간이 최대 3바이트이기 때문에 utf8mb4보다는 저장할 수 있는 문자의 범위가 좁다.
	- `SHOW CHARACTER SET` ㅁ여령의 결과에서 "Default collation" 컬럼에는 해당 문자 집합의 기본 콜레이션이 무엇인지 표시해준다.
	- ![](assets/Pasted%20image%2020241002013704.png)

#### 클라이언트로부터 쿼리를 요청했을 때의 문자 집합 변환

- MySQL 서버는 클라이언트로부터 받은 메시지가 `character_set_client`에 지정된 문자 집합으로 인코딩돼 있다고 판단하고, 받은 문자열 데이터를 `character_set_connection`에 정의된 문자 집합으로 변환한다.
- ![](assets/Pasted%20image%2020241002014843.png)
	- 첫 번째 쿼리에서 "Matt" 문자열은 `character_set_connection`으로 문자 집합이 변환된 이후 처리될 것이다.
	- 두 번째 쿼리는 인트로듀서(`_latin1`)가 사용됐으므로 "Matt" 문자열은 `character_set_connection`이 아니라 `latin1` 문자 집합으로 `first_name` 컬럼의 값과 비교가 실행된다.

#### 처리 결과를 클라이언트로 전송할 때의 문자 집합 변환

- `character_set_connection`에 정의된 문자 집합으로 변환해 SQL을 실행한 다음, MySQL 서버는 쿼리의 결과를 `character_set_results` 변수에 설정된 문자 집합으로 변환해 클라이언트로 전송한다.
- 변환 전 문자 집합과 변환해야 할 문자 집합이 똑같다면 별도의 문자 집합 변환 작업은 모두 생략한다.
	- 예시1: `character_set_client`와 `character_set_connection`의 문자 집합이 똑같은 경우
	- 예시2: `character_set_connection`과 `character_set_results`의 문자 집합이 똑같은 경우
- `character_set_client`, `character_set_connection`, `character_set_results`이라는 3개의 시스템 설정 변수는 동적 변수이다.
	- ![](assets/Pasted%20image%2020241002015725.png)

### 콜레이션(Collation)

- 콜레이션: 문자열 비교나 정렬 작업에서 영문 대소문자를 같은 것으로 처리할지, 아니면 더 크거나 작은 것으로 판단할지에 대한 규칙을 정의하는 것이다.
- 문자열 컬럼의 값을 비교하거나 정렬할 때는 항상 문자 집합뿐 아니라 콜레이션의 칠치 여부에 따라 겨로가가 달라지면, 쿼리의 성능 또한 상당한 영향을 받는다.

#### 콜레이션 이해

- 테이블이나 컬럼에 문자 집합만 지정하면 해당 문자 집합의 디폴트 콜레이션이 해당 컬럼의 콜레이션으로 지정된다.
	- 반대로 컬럼의 문자 집합은 지정하지 않고 콜레이션만 지정하면 해당 콜레이션이 소속된 문자 집합이 묵시적으로 그 컬럼의 문자 집합으로 사용된다.
- `SHOW COLLATION` 명령을 이용해 MySQL 서버에서 사용 가능한 콜레이션 목록을 확인할 수 있다.
- 콜레이션 이름은 2개 또는 3개의 파트로 구분돼 있으며, 각 파트는 다음과 같은 의미로 사용된다.
	- 3개의 파트로 구성된 콜레이션 이름(예: `utf8mb4_general_ci`)
		- 첫 번째 파트는 문자 집합의 이름이다.
		- 두 번째 파트는 해당 문자 집합의 하위 분류를 나타낸다.
		- 세 번째 파트는 대문자나 소문자의 구분 여부를 나타낸다. "ci"이면 대소문자를 구분하지 않는 콜레이션(Case Insensitive)을 의미하며, "cs"이면 대소문자를 별도의 문자로 구분하는 콜레이션(Case Sensitive)이다.
	- 2개의 파트로 구성된 콜레이션 이름(`utf8mb4_bin`)
		- 첫 번째 파트는 문자 집합의 이름이다.
		- 두 번째 파트는 항상 "bin"이라는 키워드를 가진다. 여기서 "bin"은 이진 데이터를 의미하며, 이진 데이터로 관리되는 문자열 컬럼은 별도의 콜레이션을 가지지 않는다. 따라서 비교 및 정렬은 실제 문자 데이터의 바이트 값을 기준으로 수행한다.
		- 일반적으로 각 국가의 언어는 그 나라의 국멘에게 익숙한 순서대로 문자 코드 값이 부여돼 있으므로 대소문자를 구분할 때는 "bin" 계열의 콜레이션을 적용해도 특별히 문제되지는 않는다.
- 문자열 컬럼에서 문자 집합과 콜레이션이 모두 일치해야만 조인이나 WHERE 조건이 인덱스를 효율적으로 사용할 수 있다.
	- 문자 집합이나 콜레이션이 다르다면 비교 작업에서 콜레이션 변환이 필요하기 때문에 인덱스를 효율적으로 이용하지 못할 때가 많으므로 주의해야 한다.
- "\_ci" 콜레이션의 정렬 순서
	- 대소문자 구분 없이 정렬된다.
	- ![](assets/Pasted%20image%2020241002021716.png)
- "\_cs" 콜레이션의 정렬 순서
	- 대문자 'A'와 소문자 'a'는 모두 대문자 'B'보다 먼저 정렬된다.
	- 같은  알파벳에서는 대문자가 소문자보다 먼저 정렬된다.
	- ![](assets/Pasted%20image%2020241002021756.png)
- "\_bin" 콜레이션의 정렬 순서
	- 대문자만 먼저 정렬되고 그당므으로 소문자가 정렬된다.
	- ![](assets/Pasted%20image%2020241002021911.png)
- latin1이 아니라 latin7 문자셋을 사용하면 특수문자가 알파벳보다 먼저 정렬된다.
	- ![](assets/Pasted%20image%2020241002022130.png)

#### utf8mb4 문자 집합의 콜레이션

- 다음 4개의 콜레이션은 utf8mb4 문자 집합의 콜레이션 중 하나다.
	- UCA: Unicode Collation Algorithm. 유니코드 문자열 비교 알고리즘.
	- ![](assets/Pasted%20image%2020241002022727.png)
- 콜레이션의 이름에 locale이 포함돼 있는지 여부로 언어에 종속적은 콜레이션과 언어에 비종속적인 콜레이션으로 구분할 수 있다.
	- ![](assets/Pasted%20image%2020241002023021.png)
- UCA 9.0.0 버전의 콜레이션은 이전 버전보다 빠르다고 MySQL 매뉴얼에 소개되고 있지만, 실제로 테스트해보면 그렇지 않다. 성능 영향은 없는 것으로 보인다.
- UCA 9.0.0 콜레이션은 최신 정렬 순서를 반영하고 있으므로 새로운 서비스를 개발하고 있다면 이를 사용할 것을 권장한다.
- 하지만 MySQL 8.0 이전 버전에서 MySQL 8.0으로 업그레이드하는 경우 UCA 9.0.0 사용을 주의해야 한다.
	- MySQL 5.7 버전에서는 utf8mb4 기본 콜레이션이 "utf8mb4_general_ci" 였는데 MySQL 8.0 버전부터는 utf8mb4 문자 집합의 기본 콜레이션이 "utf8mb4_0900_ai_ci"로 변경됐다.
	- 서로 다른 버전에서 생성한 테이블을 조인할 때는 콜레이션이 달라서 에러가 발생하거나 성능이 심각하게 떨어질 수 있다.
- `default_collation_for_utf8mb4` 시스템 변수로 기본 콜레이션을 변경할 수 있다.
- 또한 JDBC 드라이버의 연결 문자열에서 connectionCollation 파라미터를 설정할 수도 있다. 
	- ![](assets/Pasted%20image%2020241002023652.png)